{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://qianxiaoxinrou.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-18T07:50:49.137Z","updated":"2020-04-18T07:50:49.132Z","comments":true,"path":"404.html","permalink":"https://qianxiaoxinrou.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2020-04-18T07:48:15.496Z","updated":"2020-04-18T07:48:15.490Z","comments":true,"path":"categories/index.html","permalink":"https://qianxiaoxinrou.github.io/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-04-18T07:47:25.346Z","updated":"2020-04-18T07:47:25.336Z","comments":true,"path":"about/index.html","permalink":"https://qianxiaoxinrou.github.io/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"我的朋友们","date":"2020-04-18T07:50:06.549Z","updated":"2020-04-18T07:50:06.545Z","comments":true,"path":"friends/index.html","permalink":"https://qianxiaoxinrou.github.io/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2020-04-18T07:49:33.954Z","updated":"2020-04-18T07:49:33.948Z","comments":true,"path":"mylist/index.html","permalink":"https://qianxiaoxinrou.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-18T07:48:52.683Z","updated":"2020-04-18T07:48:52.679Z","comments":true,"path":"tags/index.html","permalink":"https://qianxiaoxinrou.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java面试题总结--基础篇 | 持续更新~~~","slug":"Java面试题总结--基础篇 | 持续更新~~~","date":"2020-04-19T06:33:29.000Z","updated":"2020-04-24T08:54:20.638Z","comments":true,"path":"2020/04/19/Java面试题总结--基础篇 | 持续更新~~~/","link":"","permalink":"https://qianxiaoxinrou.github.io/2020/04/19/Java%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93--%E5%9F%BA%E7%A1%80%E7%AF%87%20|%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0~~~/","excerpt":"牛客网Java刷题总结","text":"牛客网Java刷题总结 Java基础1 i++和++i区别123456789public static void main(String[] args) &#123; int i = 1; i = i++; int j = i++; int k = i+ ++i * i++; System.out.println(i); System.out.println(j); System.out.println(k);&#125; 结果： 1234111 明确局部变量表和操作数栈两个概念 1int i = 1 在局部变量表里将i的值赋为1 1i = i++; 将i的值（1）压入操作数栈，i自增1，变为2。 弹出栈顶元素，将1赋值给i，i变为1。 1int j = i++; 将i的值（1）压入操作数栈，i自增1，变为2。 弹出栈顶元素，将1赋值给j，j变为1. 1int k = i+ ++i * i++; 根据运算优先级判断执行顺序 将i的值（2）压入操作数栈 i值自增1，变为3，将i的值（3）压入操作数栈 将i的值（3）压入操作数栈，i自增1，变为4 操作数栈弹出两个元素（3，3），进行乘法运算，结果为9，并压入操作数栈 操作数栈弹出两个元素（9，2），进行加法运算，结果为11，并压入操作数栈 操作数栈弹出一个元素（11），赋值给k 2 初始化顺序Father类 123456789101112131415161718192021222324252627282930313233public class Father &#123; public static int i = method(); public int j = test(); static &#123; System.out.print(\"(1)\"); &#125; Father() &#123; System.out.print(\"(2)\"); &#125; Father(int i) &#123; System.out.print(\"(2-1)\"); &#125; &#123; System.out.print(\"(3)\"); &#125; public int test() &#123; System.out.print(\"(4)\"); return 1; &#125; public static int method() &#123; System.out.print(\"(5)\"); return 1; &#125;&#125; Son类 12345678910111213141516171819202122232425262728293031323334353637public class Son extends Father &#123; public static int i = method(); public int j = test(); static &#123; System.out.print(\"(6)\"); &#125; Son() &#123; super(1); System.out.print(\"(7)\"); &#125; &#123; System.out.print(\"(8)\"); &#125; public int test() &#123; System.out.print(\"(9)\"); return 1; &#125; public static int method() &#123; System.out.print(\"(10)\"); return 1; &#125; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(); Son s2 = new Son(); System.out.println(); &#125;&#125; 运行结果 12(5)(1)(10)(6)(9)(3)(2-1)(9)(8)(7)(9)(3)(2-1)(9)(8)(7) Java初始化过程，包括类初始化和实例初始化两部分 类初始化过程1234567891.main()所在类2.子类在初始化前需要先初始化父类3.执行&lt;clinit&gt;方法- 静态成员变量赋值和执行静态代码块- 按照自上而下的顺序对静态成员变量赋值和执行静态代码块- 只执行一次 实例初始化123456781.执行&lt;init&gt;方法- 非静态变量赋值、执行非静态代码块和构造方法- 按照自上而下的顺序对非静态变量赋值、执行非静态代码块，最后执行构造方法- 子类在执行&lt;init&gt;之前会执行父类的&lt;init&gt;，父类构造方法由子类super()所决定，默认为无参构造- 每次创建都会执行2.注意字类的重写方法（多态性） 3 方法重写 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 不可重写的方法类型 final修饰的方法 静态方法 4 方法传值调用方法的时候，本质上都是将值COPY一份传递给被调方法。不过，对于基本类型来说，修改形参不会对原有的值造成影响。对于引用类型来说，传递的值为对象的真实地址，修改形参会对原有的值造成影响。 此外，需要注意String、Integer（-128~127）等不可变对象。 5 变量类型、作用域和初始化变量类型主要包括局部变量和成员变量。 局部变量保存在方法栈桢中，只能用final关键字进行修饰，作用域为当前{}内。局部变量没有初始值，需要进行初始化。 成员变量包括类变量和实例变量，能够被jvm初始化，可以用public、protected、private、static、final、transient、volatile关键字进行修饰。在初始化过程中注意就近原则。 类变量保存在方法区中，作用域为当前类。 实例变量保存在堆中，作用域为当前实例。 若局部变量和类变量重名，则可以使用类名.变量名进行访问。 若局部变量和成员变量重名，则可以使用this.变量名进行访问。 6 基本数据类型 数据类型 大小/位 包装类 默认值（零值） 可表示数据范围 byte(字节) 8-bit Byte (byte)0 -128~127 short(短整数) 16-bit Short (short)0 -32768~32767 int(整数) 32-bit Integer 0 -2147483648~2147483647 long(长整数) 64-bit Long 0L -9223372036854775808~9223372036854775807 float(单精度) 32-bit Float 0.0F 1.4E-45~3.4028235E38 double(双精度) 64-bit Double 0.0D 4.9E-324~1.7976931348623157E308 boolean Boolean flase true或false char(字符) 16-bit Character ‘\\u0000’（对应数字0，输出为空） 0~65535 第一类：整数类型 byte short int long 第二类：浮点型 float double 第三类：逻辑型 boolean(它只有两个值可取true false) 第四类：字符型 char byte、short在计算时默认转int 低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double 不同的数据类型不能自动装箱拆箱 7 枚举相关123456enum AccountType &#123; SAVING, FIXED, CURRENT; private AccountType() &#123; System.out.println(“It is a account type”); &#125;&#125; 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型。上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中： 1private AccountType() &#123; System.out.println(“It is a account type”); &#125; 会变成： 1234private AccountType(String s, int i) &#123; super(s,i); System.out.println(“It is a account type”); &#125; 而在这个类中，会添加若干字段来代表具体的枚举类型： 123public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT; 而且还会添加一段static代码段： 12345678static&#123; SAVING = new AccountType(\"SAVING\", 0); //... CURRENT = new AccountType(\"CURRENT\", 0); $VALUES = new AccountType[]&#123; SAVING, FIXED, CURRENT &#125; &#125; 以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型） 在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。 8 方法重写总结来说为： 方法名相同，参数类型相同 子类返回类型等于父类方法返回类型， 子类抛出异常小于等于父类方法抛出异常， 子类访问权限大于等于父类方法访问权限。 详细的说明为： 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。 即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。 方法的重写规则： 1）参数列表必须完全与被重写方法的相同； 2）返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java 1.5 版本之前返回类型必须一样,1.5(包含)j 版本之后ava放宽了限制,返回类型必须小于或者等于父类方法的返回类型 ）。才有了 子类返回类型小于等于父类方法返回类型。在java里面这个怎么样都是正确的,请小伙伴谨记。 3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 4）父类的成员方法只能被它的子类重写。 5）声明为final的方法不能被重写。 6）声明为static的方法不能被重写，但是能够被再次声明。 7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 10）构造方法不能被重写。 11）如果不能继承一个方法，则不能重写这个方法。 9 ThreadLocalThreadLocal类用于创建一个线程本地变量 在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。 ThreadLocal的使用场景： 数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。 10 文件名与类名一个文件中可以有多个类，如果没有public类，则可以与任意类名相同，如果有public类则文件名必须与此类名相同，因为一个文件中只能有一个public类。如果文件中只有一个类，则文件名必须与类名相同 11 字符串拼接123456789String a = \"a\";String b = \"b\";String str1 = \"a\" + \"b\";//常量池中的对象String str2 = a + b; //在堆上创建的新的对象 String str3 = \"ab\";//常量池中的对象System.out.println(str1 == str2);//falseSystem.out.println(str1 == str3);//true System.out.println(str2 == str3);//false 字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中。而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。 12 运算符&lt;&lt;表示左移位 &gt;&gt;表示带符号右移位 &gt;&gt;&gt;表示无符号右移，左边空出的位以0填充 13 运行异常和非运行异常运行异常，可以通过java虚拟机来自行处理。非运行异常，我们应该捕获或者抛出 14 原码、反码、补码在计算机系统中，数值一律用补码来表示（存储） 正数符号位是0，负数符号位是1 正数原码，反码，补码相同 负数反码除了符号位不变，其他位取反，补码=反码+1 以下 b 的值是： byte b = (byte)129; 129为int类型，转short，被截取为1000 0001。此时1000 0001为截取后所代表数字的补码，要将其转化为原码。 补码：1000 0001 反码：1000 0000 原码：1111 1111 即b=-127 执行如下程序代码 char chr = 127; int sum = 200; chr += 1; sum += chr; 后，sum的值是 ; （ ） 备注：同时考虑c/c++和Java的情况的话 java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328 但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出, 0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72 15 泛型PECS原则12345671. 只看尖括号里边的！！明确点和范围两个概念2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt;3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值6. List&lt;?&gt;和List 是相等的，都代表最大范围7. 补充：List既是点也是范围，当表示范围时，表示最大范围 代码： 12345678910111213141516171819202122class A &#123;&#125;class B extends A &#123;&#125;class C extends A &#123;&#125;class D extends B &#123;&#125;public static void main(String[] args) &#123; List&lt;A&gt; a; List list; list = a; //A对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内 List&lt;B&gt; b; a = b; //B错，点之间不能相互赋值 List&lt;?&gt; qm; List&lt;Object&gt; o; qm = o; //C对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内 List&lt;D&gt; d; List&lt;? extends B&gt; downB; downB = d; //D对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中 List&lt;?extends A&gt; downA; a = downA; //E错，范围不能赋值给点 a = o; //F错，List&lt;Object&gt;只是一个点 downA = downB; //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛&#125; 16 最终类最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。 17 标识符 数字，字母，符号（只有_和$两种），数字不能开头。 不能是关键字（有两个保留关键字，goto，const，关键字都是小写的****）或者显式常量（null，true，false）。 18 关键字 keywords12345678abstract class extends implements null strictfp trueassert const false import package super tryboolean continue final instanceof private switch voidbreak default finally int protected synchronized volatilebyte do float interface public this whilecase double for long return throwcatch else goto native short throwschar enum if new static transient 19 构造方法 普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。 构造函数不能被继承，构造方法只能被显式或隐式的调用。 20 正则表达式[://] 表示匹配 :// 中的任何一个字符，也就是匹配 : 或 / [htps] 表示匹配 htps 中的任何一个字符，[htps]+ 表示一次或多次匹配前面的字符或子表达式，所以 [htps]+ 可以匹配 https 21 a的b次幂math类中的一个静态方法 ： pow(double a, double b) ^表示异或 就是相同是0 不同是1 22 getClass123456789101112package test;import java.util.Date; public class SuperTest extends Date&#123; private static final long serialVersionUID = 1L; private void test()&#123; System.out.println(super.getClass().getName()); &#125; public static void main(String[]args)&#123; new SuperTest().test(); &#125; &#125; TestSuper和Date的getClass都没有重写，他们都是调用Object的getClass，而Object的getClass作用是返回的是运行时的类的名字。这个运行时的类就是当前类，所以 1super.getClass().getName() 返回的是test.SuperTest，与Date类无关 要返回Date类的名字需要写super.getClass().getSuperclass() 23 递归123456789101112public class Main &#123; public static void main(String[] args) &#123; split(12); &#125; public static int split(int number) &#123; if (number &gt; 1) &#123; if (number % 2 != 0) System.out.print(split((number + 1) / 2)); System.out.print(split(number / 2)); &#125; return number; &#125;&#125; 分析过程，伪代码： 1234567891011sout split(6) &#x3D; &#123; sout split(3) &#x3D; &#123; sout split(2) &#x3D; &#123; sout split(1) return 2 &#125; sout split(1) return 3; &#125; return 6&#125; 24 异常 异常分为运行时异常，非运行时异常和error，其中error是系统异常，只能重启系统解决。非运行时异常需要我们自己补获，而运行异常是程序运行时由虚拟机帮助我们补获。运行时异常包括数组的溢出，内存的溢出空指针，分母为0等！ 25 接口和抽象类 接口中属性为public static final，方法为public abstract，接口中不可以有构造方法。 抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已 Java不允许类多重继承 jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体 26 线程停止方法sleep让线程休眠，yield让运行中的线程回到就绪状态，synchronized只是同步阻塞，让线程进入对象的阻塞队列 27 一维数组 静态初始化 1int array[] = new int[]&#123;1,2,3,4,5&#125; 或者 1int array[] = &#123;1,2,3,4,5&#125; 需要注意的是，写成如下形式是错误的 1int array[] = new int[5]&#123;1,2,3,4,5&#125; 28 方法重载 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 29 类之间关系USES-A：依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。 关联关系：A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。 HAS-A：聚合关系，拥有关系，是关联关系的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。 IS-A：表示继承。父类与子类，这个就不解释了。 要注意：还有一种关系：组合关系也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。 30 二维数组12345float f[][] = new float[6][6];float []f[] = new float[6][6];float f[][] = new float[][6];//errorfloat [][]f = new float[6][6];float [][]f = new float[6][]; 数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。 31 字符编码和国际化 Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。 例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”); Java虚拟机中通常使用UTF-16的方式保存一个字符（char） ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。 32 虚函数和纯虚函数 虚函数的存在是为了多态。Java中其实没有虚函数的概念，它的普通函数就相当于C++的虚函数，动态绑定是Java的默认行为。如果Java中不希望某个函数具有虚函数特性，可以加上final关键字变成非虚函数。 抽象函数或者说是纯虚函数的存在是为了定义接口。Java中纯虚函数形式为：abstract void print(); 33 Integer123456789Integer i01=59;int i02=59;Integer i03=Integer.valueOf(59);Integer i04=new Integer(59);System.out.println(i01==i02);//trueSystem.out.println(i01==i03);//trueSystem.out.println(i03==i04);//falseSystem.out.println(i02==i04);//true 无论如何，Integer=xxx与new Integer不会相等，不会经历拆箱过程 两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。例如，java在编译Integer i2 = 128的时候，被翻译成-&gt; Integer i2 = Integer.valueOf(128); 而valueOf()函数会对-128到127之间的数进行缓存 两个都是new出来的,都为false int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比 34 Thread.join() 例题： 12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; Thread t=new Thread(new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.print(\"2\"); &#125; &#125;); t.start(); t.join(); System.out.print(\"1\");&#125; 因为子线程的休眠时间太长，因此主线程很有可能在子线程之前结束也就是输出结果是12，但是子线程用了join函数，因此主线程必须等待子线程执行完毕才结束因此输出结果只能是21 12t.join(); //使调用线程 t 在此之前执行完毕。t.join(1000); //等待 t 线程，等待时间是1000毫秒 35 常见的锁 自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁 阻塞锁 被阻塞的线程，不会争夺锁。 可重入锁 多次进入改锁的域 读写锁 互斥锁 锁本身就是互斥的 悲观锁 不相信，这里会是安全的，必须全部上锁 乐观锁 相信，这里是安全的。 公平锁 有优先级的锁 非公平锁 无优先级的锁 偏向锁 无竞争不锁，有竞争挂起，转为轻量锁 对象锁 锁住对象 线程锁 锁粗化 多锁变成一个，自己处理 轻量级锁 CAS 实现 锁消除 偏向锁就是锁消除的一种 锁膨胀 jvm实现，锁粗化 信号量 使用阻塞锁 实现的一种策略 排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。 36 包装类 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱 包装类的equals()方法不处理数据转型 37 操作符 &amp; 与操作 | 或操作 ! 非操作 ~ 取反操作 38 hashCode和equalshashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。 那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。 那么hashCode()既然效率这么高为什么还要equals()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。 所以我们可以得出： equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。 hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低。所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）。如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ 39 switch 语句 列题： 12345678910111213void main(void) &#123; char *s = \"1314520\"; int v1 = 0, v2 = 0, v3 = 0, v4 =0; for (int i = 0; s[i]; i++) &#123; switch(s[i]) &#123; default: v4++; case '1': v1++; case '2': v2++; cas3 '3': v3++; &#125; &#125; printf(\"%d, %d, %d, %d\", v4,v1,v2,v3)&#125; result： 13567 default顾名思义是缺省情况，只有任何条件都不匹配的情况下才会执行，故会匹配到s[i]为‘4’，‘5’，‘0’ 的情况。于是v4++三次，v4=3。并且这个default后没有使用break语句，于是case‘1’、‘2’、‘3’都会执行三次。注意到所有语句都没有加break，则语句执行过之后会继续下面的case语句。另外由于s[i]中有两个1，故v1,v2,v3此时为5.另外有一个2，v2,v3++后为6，还有一个case3 于是v3++.最终v3为7。 40 数组 数组是一个对象，不同类型的数组具有不同的类 数组是一个连续的存储结构 可以二维数组，且可以有多维数组，都是在Java中合法的 查看源码可以知道数组的equals方法是object的equals，比较的是内存地址 41 字符常量一个字符常量表示为一个字符或一个转义序列，被一对ASCII单引号关闭。 42 反射 Class类位于java.lang包下。Method, Filed等类位于java.lang.reflet包下 43 导致导致InterruptedException异常 java.lang.Object 类的 wait 方法 java.lang.Thread 类的 sleep 方法 java.lang.Thread 类的 join 方法 44 汉字长度java的String底层是char数组，它的length()返回数组大小。一个汉字等于一个字符（char），一个汉字也等于二个字节（byte）。 45 类加载器 Bootstrap ClassLoader，主要加载JVM自身工作需要的类。 Extension ClassLoader，主要加载%JAVA_HOME%\\lib\\ext目录下的库类。 Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath） JVM类加载机制为双亲委托模型。如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。 46 自动装箱 不同的数据类型不能自动装箱拆箱 47 jdk命令 jps：查看本机java进程信息。 jstack：打印线程的栈信息，制作线程dump文件。 jmap：打印内存映射，制作堆dump文件 jstat：性能监控工具 jhat：内存分析工具 jconsole：简易的可视化控制台 jvisualvm：功能强大的控制台 java、javac、jar等开发工具是用Java编写的。 jvm1 复制算法将内存按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了新生代。 如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是老年代的用处。当不够用时，这些对象将直接通过分配担保机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。 2 运行时常量池在JDK1.8之前运行时常量池被放在方法区,属于线程共享,JDK1.8之后,元空间取代了方法区,运行时常量池被也被放在元空间中,运行时常池 主要存放, class文件元信息描述,编译后的代码，引用类型数据，类文件常量池。所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） 3 CMS的GC过程 初始标记:暂停用户线程，对引用进行遍历并标记 并发标记：在并发情况下，遍历除1中标记过的线程并标记 并发预清理：并发情况下对以上的标记进行清理 重标记：由于3过程是并发的，可能会产生一些引用，所以需要暂停用户线程重新标记 并发清理：清理4过程产生的标记 并发重置：做一些收尾工作 4 参数配置Xms 起始内存 Xmx 最大内存 Xmn 新生代内存 Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。其中 Eden 和 Survivor 区的比例默认是 8:1:1。 -XX:MaxPermSize=n:设置持久代大小 收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 假如某个JAVA进程的JVM参数配置如下：-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,请问eden区最终分配的大小是多少？ 故该题为500*（3/5）=300M Java Web1 Cookie的获取方式request.getCookies 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。 request.getHeader 以字符串形式返回指定的请求头的值。Cookie也是头的一种； 2 request 属性参数request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。 3 HttpSessionAttributeListener可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知 Spring框架1 Spring中Bean作用域singleton、prototype、request、session 2 Spring事务传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。Spring中默认为PROPAGATION_REQUIRED。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 隔离级别 隔离级别类型 说明 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别。 ISOLATION_READ_UNCOMMITTED 允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。 ISOLATION_READ_COMMITTED 允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。 ISOLATION_REPEATABLE_READ 对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。 ISOLATION_SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。 脏读：一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。 不可重复读：一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。 幻读：当一个事务（1）读取几行记录后，另一个并发事务（2）插入了一些记录并提交，事务（1）再次查询，可以看到事务（2）添加的额外记录。 4 SpringMVC中文乱码post乱码配置CharacterEncodingFilter，将encoding属性设置为UTF-8。可以修改forceEncoding属性，修改响应的编码。 get乱码修改tomcat配置文件中server.xml，在Connector标签添加URIEncoding=&quot;UTF-8&quot; MyBatis框架1 实体对象与数据库字段名不一致 sql语句中使用别名 MyBatis开启驼峰命名规则 在映射文件中自定义ResultMap Linuxtar命令12345-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 12345-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 1-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。","categories":[{"name":"面试","slug":"面试","permalink":"https://qianxiaoxinrou.github.io/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://qianxiaoxinrou.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://qianxiaoxinrou.github.io/tags/Java/"}]},{"title":"CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试","slug":"CentOS7-安装-docker-和-docker-compose-shell-脚本初次尝试","date":"2020-04-19T00:46:37.000Z","updated":"2020-04-19T00:52:07.204Z","comments":true,"path":"2020/04/19/CentOS7-安装-docker-和-docker-compose-shell-脚本初次尝试/","link":"","permalink":"https://qianxiaoxinrou.github.io/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/","excerpt":"CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试","text":"CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试 参照官网教程，实现CentOS7安装docker，注意的是这里的docker是ce版本的 卸载旧版本12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装docker ce版本安装所使用的仓库安装相关依赖123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 设置stable仓库123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装docker ce版本1sudo yum install docker-ce docker-ce-cli containerd.io -y 开启docker1sudo systemctl enable docker 设置docker开机启动1sudo systemctl enable docker 查看安装1docker version 安装docker-compose下载安装脚本1sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 赋予脚本可执行权限1sudo chmod +x /usr/local/bin/docker-compose 查看安装1docker-compose version 安装脚本简单安装方法1bash &lt;(curl https://raw.githubusercontent.com/weiguangchao/Linux_script/master/docker_install.sh) 本地脚本安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# docker_install.sh#!/bin/bashneed_add=\"\"echo \"1. 卸载自带docker\"sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engineecho \"2. 安装相关依赖\"sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2echo \"3. 设置stable仓库\"sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repoecho \"4. 安装docker ce版本\"sudo yum install docker-ce docker-ce-cli containerd.io -yecho \"5. 启动docker\"sudo systemctl start dockerecho \"6. 设置docker开机启动\"sudo systemctl enable dockerread -p \"是否需要将当前用户添加到docker用户组: (y)es 是 : (n)0 否: \" need_addif [ \"$need_add\" == \"y\" ] || [ \"$need_add\" == \"yes\" ]then sudo gpasswd -a $&#123;USER&#125; docker echo \"将 $&#123;USER&#125; 添加到 docker 用户组\"fiecho \"7. 安装docker-compose\"sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composeecho \"8. 安装完成\"docker versiondocker-compose version 额外配置有时当前并不是root用户，所以要将当前用户添加到docker用户组中 1sudo gpasswd -a $&#123;USER&#125; docker 网络优化参照 千影 的Linux网络优化脚本","categories":[{"name":"Linux","slug":"Linux","permalink":"https://qianxiaoxinrou.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://qianxiaoxinrou.github.io/tags/CentOS7/"},{"name":"docker","slug":"docker","permalink":"https://qianxiaoxinrou.github.io/tags/docker/"}]},{"title":"CenOS7配置ssh免密登录","slug":"CenOS7配置ssh免密登录","date":"2020-04-19T00:45:04.000Z","updated":"2020-04-19T00:46:02.762Z","comments":true,"path":"2020/04/19/CenOS7配置ssh免密登录/","link":"","permalink":"https://qianxiaoxinrou.github.io/2020/04/19/CenOS7%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/","excerpt":"CenOS7配置ssh免密登录","text":"CenOS7配置ssh免密登录 生成ssh密钥我是Mac系统，其他系统类似 1cd ~ 若.ssh文件夹不存在则创建 1mkdir -p .ssh 生成ssh密钥 1ssh-keygen -m PEM -t rsa 将id_rsa.pub上传到服务器，我这里则是上传到的是服务器的/root 服务器配置这里以root用户为例 若/root/.ssh文件夹不存在，则创建 12cd ~mkdir -p .ssh 将证书内容写入到文件 1cat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys 修改ssh配置文件 123456vi /etc/ssh/sshd_config#配置远程登录RSAAuthentication yesPubkeyAuthentication yes#禁用密码登录(可选)PasswordAuthentication yes 改为 PasswordAuthentication no 重启ssh服务1systemctl restart sshd","categories":[{"name":"Linux","slug":"Linux","permalink":"https://qianxiaoxinrou.github.io/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://qianxiaoxinrou.github.io/tags/CentOS7/"}]},{"title":"彻底搞懂 nginx 的 location 字段","slug":"彻底搞懂-nginx-的-location-字段","date":"2020-04-19T00:42:57.000Z","updated":"2020-04-19T00:43:58.864Z","comments":true,"path":"2020/04/19/彻底搞懂-nginx-的-location-字段/","link":"","permalink":"https://qianxiaoxinrou.github.io/2020/04/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-nginx-%E7%9A%84-location-%E5%AD%97%E6%AE%B5/","excerpt":"彻底搞懂 nginx 的 location 字段","text":"彻底搞懂 nginx 的 location 字段 前缀符号 =：对URI和location进行精确匹配，如果找到精确匹配，那么匹配便会终止 ~：正则匹配，区分大小写 ~*：正则匹配，不区分大小写 ^~：当最长前缀匹配中包含该字符时，则不会匹配正则表达式 @：不是用来处理常规请求，而是被用来请求重定向 匹配顺序1、nginx会匹配那些定义了prefix string的location，能够完成*最长*匹配prefix string 的location会被nginx记录 2、按照 regular expressions*在配置文件出现的顺序进行匹配，找到了第一个匹配的 *regular expressions ，那么nginx便停止匹配。如果没有找到与之相匹配的 regular expressions，nginx将会使用之前被记录下来的最长匹配prefix string的location 3、如果最长匹配prefix string的location中有 ^~ ，那么nginx将不会进行regular expressions匹配 4、同理最长匹配prefix string的location中有 = ，nginx会对URI和location进行精确匹配，如果nginx找到了精确匹配，那么匹配将会终止 5、如果location的prefix string是以/结尾，那么请求可以进行特殊的处理（proxy_pass、fastcgi_pass，uwsgi_pass，scgi_pass、memcached_pass、grpc_pass）。 6、如果步骤5中location的prefix string同时存在/结尾和不带/结尾的，那么不带/结尾的将会永久的被以301状态码的方式重定向到/结尾的location中。如果对这种情况不是很满意的话，可以使用精确匹配的方式解决该问题： 1234567location /user/ &#123; proxy_pass http://user.example.com;&#125;location = /user &#123; proxy_pass http://login.example.com;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://qianxiaoxinrou.github.io/categories/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://qianxiaoxinrou.github.io/tags/nginx/"}]},{"title":"docker 学习笔记 | 持续更新~~~","slug":"docker-学习笔记-持续更新","date":"2020-04-18T12:27:05.000Z","updated":"2020-04-18T12:28:00.217Z","comments":true,"path":"2020/04/18/docker-学习笔记-持续更新/","link":"","permalink":"https://qianxiaoxinrou.github.io/2020/04/18/docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","excerpt":"列出了docker常见的命令，及一些个人总结的知识点","text":"列出了docker常见的命令，及一些个人总结的知识点 镜像命令 查看本地镜像 1docker images -a：显示所有镜像 -q：显示镜像id 查找 在dockerhub上寻找 1docker search tomcat -s：列出收藏数大于指定数量 下载镜像 1docker pull tomcat 默认是tomcat:latest 删除镜像 1docker rmi tomcat / 镜像ID 删除单个的情况，版本号不写默认是latest，删除多个可以用空格隔开 -f：强制删除 1docker rmi -f $(docker images -qa) 删除本机全部镜像 生成镜像 方式1： 1docker commit tomcat 当前正在运行的容器实例 命名空间/镜像名:版本编号 根据容器实例生成镜像 -m：描述信息 -a：作者 方式2： 1docker build -f Dockerfile路径 -t 命名空间/镜像名 . 根据Dockerfile生成镜像 -f：Dockerfile路径 -t：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 .：当前路径 查看镜像历史 1docker history 镜像id 容器命令 创建一个新的容器并运行一个命令 1docker run centos 本地有镜像的话则运行本地镜像，本地没有镜像的话则会去hub上pull -i：已交互的方式运行容器，通常都是配合-t参数使用 -t：为容器重新分配一个伪终端 --name：别名 -d：后台运行容器，并返回容器id，即启动守护式容器 -p：主机端口:docker容器端口 -P：随机分配端口 -v：绑定一个卷，主机路径:容器路径 --rm：运行结束时自动销毁 --restart：设置容器重启策略，no，默认策略，在容器退出时不重启容器；on-failure，在容器非正常退出时（退出状态非0），才会重启容器；on-failure:3，在容器非正常退出时重启容器，最多重启3次；always，在容器退出时总是重启容器；unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 值得说明的是，docker容器实例在后台运行，就必须要有一个前台进程，如果容器运行的不是那些一直挂起的命令，那么docker则会自动退出 启动一个或多个已经被停止的容器 1docker start centos 通常用来启动已经停止的容器 列出当前运行的所有容器 1docker ps -a：正在运行和历史上运行过得容器 -l：上次运行的容器实例 -n：最近n个创建的容器 -q：只显示容器id 退出容器 方式1： 1exit 关闭容器，无法再次进入 方式2： Ctrl + p + q 关闭容器之后还可以再次进入 重启容器 1docker restart centos 停止容器 方式1： 1docker stop centos 正常停止 方式2： 1docker kill centos 强制停止，类似于拔电源 删除容器 1docker rm centos 删除单个 -f：强制删除 删除多个 方式1： 1docker rm -f $(docker ps -aq) 方式： 1docker ps -aq | xargs docker rm -f 查看日志 1docker logs centos -t：时间 -f：跟随最新的日志 --tail：显示最后多少条 查看容器内运行的进程 1docker top centos 查看容器内部的细节 1docker inspect centos 重新进入docker进行交互 方式1： 1docker attach centos 直接进入容器启动的命令行终端，不会启动新的进程 方式2： 1docker exec centos 不进入容器却能够和容器交互 如果使用docker exec centos -it /bin/bash的话，则效果和docker attach centos相同 拷贝文件到宿主机 1docker cp centos:/tmp/yum.log /root 将docker中/tmp/yum.log文件拷贝到宿主机/root中 数据卷 添加数据卷 方式1： 使用直接命令的方式 1docker run -it -v /宿主机绝对路径:/容器内目录 镜像名 容器退出后，主机修改共享文件后，docker容器中文件也会被修改 查看数据卷和容器是否绑定成功 1docker inspect 容器id 在返回的json串中，查看volume属性 设置权限 1docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名 ro：read only（只读） 出现Permission denied错误 增加--privileged=true参数 方式2： 使用Dokcerfile添加，Dockerfile是对docker中镜像的描述。在Dockerfile中增加一下代码VOLUME [&quot;/data1&quot;, &quot;/data2&quot;]，值得注意的是， 通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的 拷贝文件到容器 方式1: 1docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下 方式2: 1docker cp /www/runoob 96f7f14e99ab:/www 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www 方式3: 1docker cp 96f7f14e99ab:/www /tmp/ 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中 数据卷容器使用一个容器作为父容器，专门用来存放数据 1docker run -it --volumes-from 父容器id 子容器id 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止 Dockerfile保留字指令 FROM：当前镜像是基于那个镜像的 MAINTAINER：镜像作者及作者邮箱 RUN：容器构建时所需要执行的命令 EXPOSE：当前容器对外暴露出的端口 WORKDIR：创建容器后，终端默认进来的工作目录 ARG：构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 ENV：设置环境变量，在这之后的RUN指令都可以使用该变量 ADD：拷贝（COPY） + 解压缩 COPY：直接拷贝 1COPY src dest VOLUME：容器数据卷，主机路径:容器路径 CMD：容器启动时要运行的命令。CMD指令可以有多个，但只有最后一个会生效，CMD会被docker run之后的参数替换（命令参数会被覆盖） ENTRYPOINT：容器启动时要运行的命令。（命令参数会被追加组合） ONBUILD：父镜像在子镜像build时被触发 实战篇自定义tomcat创建Dockerfile文件内容： 1234567891011121314151617181920212223# 父镜像FROM centos:7# 作者信息MAINTAINER weiguangchao&lt;3409885610@qq.com&gt;# 复制并解压ADD jdk-8u231-linux-x64.tar.gz /usr/localADD apache-tomcat-9.0.27.tar.gz /usr/local# 设置工作目录WORKDIR /usr/local/apache-tomcat-9.0.27# 设置环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.27ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin# 设置对外暴露端口EXPOSE 8080# 安装结束后运行的命令CMD startup.sh &amp;&amp; tail -f /usr/local/apache-tomcat-9.0.27/logs/catalina.out 生成镜像1docker build -f Dockerfile2 -t weiguangchao/mytomcat:1.0 . 启动tomcat123456docker run \\-d \\-p 9999:8080 \\-v /root/webapps:/usr/local/apache-tomcat-9.0.27/webapps \\-v /root/logs/:/usr/local/apache-tomcat-9.0.27/logs \\容器ID 创建index.html在~/webapps创建ROOT/index.html文件 内容： 1&lt;h3&gt;ocg, I can do it!&lt;/h3&gt; 测试浏览器地址栏输入 http://192.168.153.130:9999/index.html 提交到hub这里以阿里云为例，其实阿里云镜像服务里面已经提供了相关操作的代码了 步骤1： 1docker login --username=阿里云用户名 registry.cn-shenzhen.aliyuncs.com 步骤2： 1docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号] 步骤3： 1sudo docker push registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号] 根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 拉取镜像1docker pull registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]","categories":[{"name":"Linux","slug":"Linux","permalink":"https://qianxiaoxinrou.github.io/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://qianxiaoxinrou.github.io/tags/docker/"}]},{"title":"Spring Cloud OAuth2.0认证与授权","slug":"Spring-Cloud-OAuth2-0认证与授权","date":"2020-01-29T03:09:19.000Z","updated":"2020-04-19T00:44:46.889Z","comments":true,"path":"2020/01/29/Spring-Cloud-OAuth2-0认证与授权/","link":"","permalink":"https://qianxiaoxinrou.github.io/2020/01/29/Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/","excerpt":"Spring Cloud OAuth2.0认证和授权","text":"Spring Cloud OAuth2.0认证和授权 OAuth2授权模式authorization_code：授权码模式第一步：客户端获取授权码客户端向认证服务器发送请求，试图获取授权码 response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项 redirect_uri：表示重定向URI，可选项 scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 1http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all&amp;state&#x3D;1 第二步：用户同意授权 第三步：客户端通过授权码获取令牌第三步本是一次请求，这里为了针对性才将此拆开 1）设置客户端身份 client_id：表示客户端ID，必选项。 client_secret：表示客户端密钥，必选项 2）获取令牌 grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 code：表示上一步获得的授权码，必选项。 redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 令牌参数说明： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 由于授权码参数类似，就只在这里说明一次 password：密码模式第一步：用户向客户端提供用户名和密码客户端通过用户提供的用户名和密码向认证服务器申请令牌 第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌1）设置客户端身份 client_id：表示客户端ID，必选项。 client_secret：表示客户端密钥，必选项 2）获取令牌 grant_type：表示授权类型，此处的值固定为”password”，必选项。 username：表示用户名，必选项。 password：表示用户的密码，必选项。 scope：表示权限范围，可选项。 client_credentials：客户端模式第一步：设置客户端身份 client_id：表示客户端ID，必选项。 client_secret：表示客户端密钥，必选项 第二步：获取令牌 grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。 scope：表示权限范围，可选项。 implicit：简化模式简化模式为授权码模式的简化版。即，授权码模式的第一步直接通过浏览器回显令牌 1http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all Spring Cloud OAuth2认证和授权项目在父工程引入Spring Boot和Spring Cloud的相关依赖 123456789101112131415161718192021222324252627&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 认证服务 distributed-security-uaa依赖详情 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!-- eureka 客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud OAuth2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 application.yml123456789101112131415161718192021222324252627282930server: port: 5000 servlet: context-path: /uaaspring: application: name: distributed-security-uaa security: user: name: user password: 123eureka: client: serviceUrl: defaultZone: http://localhost:3000/eureka/security: oauth2: client: client-id: c1 client-secret: 123 # 回调URL registered-redirect-uri: https://www.ririiy.com # 令牌有效时间 access-token-validity-seconds: 7200 # 两小时 # 令牌刷新时间 refresh-token-validity-seconds: 259200 # 三天 resource-ids: r1 authorization: # 放行check_token请求，便于检查access_token即令牌是否合法 check-token-access: permitAll() 开启Spring Security如果不开启Spring Security的话，则会有相关提示 创建Spring Security配置类 1234567import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 主启动类1234567891011121314151617package com.ririiy.security.distributed.uaa;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;@SpringBootApplication@EnableDiscoveryClient@EnableAuthorizationServerpublic class UaaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UaaServiceApplication.class, args); &#125; &#125; 资源服务 distributed-security-resource依赖详情 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!-- eureka 客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud OAuth2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 application.yml123456789101112131415161718192021server: port: 7000 servlet: context-path: /resspring: application: name: distributed-security-reseureka: client: serviceUrl: defaultZone: http://localhost:3000/eureka/security: oauth2: resource: id: r1 # 检查token token-info-uri: http://localhost:5000/uaa/oauth/check_token # 客户端信息 client: client-id: c1 client-secret: 123 定义资源这里随便定义一个controller模拟资源 123456789101112import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ResourceController &#123; @GetMapping(value = \"r1\", produces = \"text/html;charset=utf-8\") public String r1() &#123; return \"r1 资源\"; &#125; &#125; 主启动类1234567891011121314151617package com.ririiy.security.distributed;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;@SpringBootApplication@EnableDiscoveryClient@EnableResourceServerpublic class ResourceServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ResourceServiceApplication.class, args); &#125; &#125; 注册中心 distributed-security-registry依赖详情 pom.xml1234567&lt;dependencies&gt; &lt;!-- eureka 服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 application.yml12345678910111213server: port: 3000spring: application: name: distributed-security-registryeureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 主启动类12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class RegistryServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RegistryServiceApplication.class, args); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://qianxiaoxinrou.github.io/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://qianxiaoxinrou.github.io/tags/Spring/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://qianxiaoxinrou.github.io/tags/Spring-Cloud/"},{"name":"OAuth2","slug":"OAuth2","permalink":"https://qianxiaoxinrou.github.io/tags/OAuth2/"}]},{"title":"SpringMVC初始化和请求映射分析","slug":"SpringMVC初始化和请求映射分析","date":"2019-11-22T12:21:14.000Z","updated":"2020-04-20T03:11:49.892Z","comments":true,"path":"2019/11/22/SpringMVC初始化和请求映射分析/","link":"","permalink":"https://qianxiaoxinrou.github.io/2019/11/22/SpringMVC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/","excerpt":"SpringMVC初始化流程和请求适配流程分析","text":"SpringMVC初始化流程和请求适配流程分析 初始化流程SpringMVC的核心是DispatcherServlet，所以SpringMVC的初始化说白了也就是DispatcherServlet的初始化。 SpringMVC首先执行DispatcherServlet中static代码块中的逻辑，将DispatcherServlet.properties文件中的配置属性加载到名为defaultStrategies的Properties中 123456789101112static &#123; // Load default strategy implementations from properties file. // This is currently strictly internal and not meant to be customized // by application developers. try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage()); &#125;&#125; 由Servlet的规范可知，在Web容器（Tomcat等）启动的过程中会判断Servlet是否需要提前实例化，而是否提前实例化由程序员外部配置的loadOnStartup参数决定，并且DispatcherServlet的loadOnStartup参数通常都是设为1，即，在Web容器启动的过程中会实例化DispatcherServlet。在实例化DispatcherServlet的过程中，Web容器首先会调用Servlet的init()方法，完成对Servlet的初始化。 1234567891011121314151617181920212223@Overridepublic final void init() throws ServletException &#123; // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); &#125; throw ex; &#125; &#125; // Let subclasses do whatever initialization they like. initServletBean();&#125; 通过观察发现该方法最终调用了initServletBean()，在initServletBean()中SpringMVC会调用initWebApplicationContext()方法完成WebApplicationContext的初始化 123456789101112131415161718192021222324252627282930@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log(\"Initializing Spring \" + getClass().getSimpleName() + \" '\" + getServletName() + \"'\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Initializing Servlet '\" + getServletName() + \"'\"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 初始化web环境 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; catch (ServletException | RuntimeException ex) &#123; logger.error(\"Context initialization failed\", ex); throw ex; &#125; if (logger.isDebugEnabled()) &#123; String value = this.enableLoggingRequestDetails ? \"shown which may lead to unsafe logging of potentially sensitive data\" : \"masked to prevent unsafe logging of potentially sensitive data\"; logger.debug(\"enableLoggingRequestDetails='\" + this.enableLoggingRequestDetails + \"': request parameters and headers will be \" + value); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Completed initialization in \" + (System.currentTimeMillis() - startTime) + \" ms\"); &#125;&#125; 该方法最终会调用configureAndRefreshWebApplicationContext(cwac)，完成相关参数的设置之后，便调用了refresh()，完成对Spring容器的初始化 123456789101112131415161718192021222324252627282930313233protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123; if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123; // The application context id is still set to its original default value // -&gt; assign a more useful id based on available information if (this.contextId != null) &#123; wac.setId(this.contextId); &#125; else &#123; // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName()); &#125; &#125; wac.setServletContext(getServletContext()); wac.setServletConfig(getServletConfig()); wac.setNamespace(getNamespace()); wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener())); // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig()); &#125; postProcessWebApplicationContext(wac); applyInitializers(wac); // SpringMVC会自动调用refresh方法 wac.refresh();&#125; 这里解释了为什么SpringMVC为什么不用显式的调用refresh() 值得注意的是ContextRefreshListener，该监听器为FrameworkServlet内部的监听器，主要是用来监听Spring容器ContextRefreshedEvent事件 1234567private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; FrameworkServlet.this.onApplicationEvent(event); &#125;&#125; 在refresh()的最后一步Spring会发布ContextRefreshedEvent事件，而该事件会被FrameworkServlet内部的ContextRefreshListener监听到，并且会回调到DispatcherServlet中的onRefresh方法，继而调用了DispatcherServlet中的initStrategies()方法 12345678910111213141516171819protected void initStrategies(ApplicationContext context) &#123; // MultipartResolver // 解释了为什么一定要把bean的名字配置为multipartResolver // SpringMVC内部通过getBean方法调用的名字为multipartResolver,已经写死 initMultipartResolver(context); // 国际化 initLocaleResolver(context); // 前端主题样式 initThemeResolver(context); // 初始化HandlerMapping initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图转换器 initViewResolvers(context); // 重定向数据管理器 initFlashMapManager(context);&#125; 其中，initMultipartResolver(context)方法也就解释了为什么文件上传解析器的名字一定要为multipartResolver了 123456789101112131415161718private void initMultipartResolver(ApplicationContext context) &#123; try &#123; this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class); if (logger.isTraceEnabled()) &#123; logger.trace(\"Detected \" + this.multipartResolver); &#125; else if (logger.isDebugEnabled()) &#123; logger.debug(\"Detected \" + this.multipartResolver.getClass().getSimpleName()); &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Default is no multipart resolver. this.multipartResolver = null; if (logger.isTraceEnabled()) &#123; logger.trace(\"No MultipartResolver '\" + MULTIPART_RESOLVER_BEAN_NAME + \"' declared\"); &#125; &#125;&#125; 因为SpringMVC已经将其写死了 SpringMVC会从defaultStrategies中获取默认的HandlerMapping和HandlerAdapter 123456org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 至此Web环境初始化完成 请求映射流程从浏览器发出请求，经过HTTPServlet和FrameworkServlet最终来到了DispatcherServlet的doDispatch方法进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 异步 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否有Multpart processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 推断当前请求的handler mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // ------------------------------注意------------------------------ // 手动观察 // 如果handler是一个bean，则getHandler返回的是一个对象 // 如果handler是一个方法，则getHandler放回的是一个方法 // Spring将handler交给对应的处理器去处理 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // Spring确定了如何调用handler的方法 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 拦截器的前置处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 调用handler进行处理 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器后置处理方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; SpringMVC会遍历所有的handlerMappings找到能够处理该请求的handler，而handlerMappings的默认值为DispatcherServlet初始化时static代码块中从配置问价加载的RequestMappingHandlerMapping和BeanNameUrlHandlerMapping 注意，如果是通过@Controller注解配置的Handler，则getHandler()方法返回的是一个方法；如果是通过实现接口（Controller，HttpRequestHandler）的方法配置的Handler，那么getHandler()返回的是一个对象 SpringMVC会在handler调用的前后分别执行拦截器的applyPreHandle()和applyPostHandle()方法，完成对请求的拦截 至此请求过程调用结束… 补充Spring中的事件Spring中的事件是通过applicationEventMulticaster即广播器向所有的监听器发送的。 123456789101112131415161718192021222324252627282930313233protected void publishEvent(Object event, @Nullable ResolvableType eventType) &#123; Assert.notNull(event, \"Event must not be null\"); // Decorate event as an ApplicationEvent if necessary ApplicationEvent applicationEvent; if (event instanceof ApplicationEvent) &#123; applicationEvent = (ApplicationEvent) event; &#125; else &#123; applicationEvent = new PayloadApplicationEvent&lt;&gt;(this, event); if (eventType == null) &#123; eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType(); &#125; &#125; // Multicast right now if possible - or lazily once the multicaster is initialized if (this.earlyApplicationEvents != null) &#123; this.earlyApplicationEvents.add(applicationEvent); &#125; else &#123; getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType); &#125; // Publish event via parent context as well... if (this.parent != null) &#123; if (this.parent instanceof AbstractApplicationContext) &#123; ((AbstractApplicationContext) this.parent).publishEvent(event, eventType); &#125; else &#123; this.parent.publishEvent(event); &#125; &#125;&#125; 底层就是通过广播器拿到所有的监听器，循环调用监听的方法 12345678910111213@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); Executor executor = getTaskExecutor(); for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; SpringMVC成为Handler的三种方式 @Controller 老生常谈了，通过@RequestMapping完成映射 12345678910111213141516171819202122@RestControllerpublic class IndexController &#123; public IndexController() &#123; System.out.println(\"com.hrious.weblearn.controller.IndexController.IndexController\"); &#125; @GetMapping(\"/index.do\") @ResponseBody public String index() throws IOException &#123; System.out.println(\"com.hrious.weblearn.controller.IndexController.index\"); return \"@controller\"; &#125; @GetMapping(\"/map.do\") public Map&lt;String, String&gt; map() &#123; System.out.println(\"com.hrious.weblearn.controller.IndexController.map\"); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"123\", \"xxx\"); return map; &#125;&#125; org.springframework.web.servlet.mvc.Controller 实现Controller接口，重写handleRequest方法。其中bean名称为请求映射地址 12345678@Component(\"/index2.do\")public class IndexController2 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.getWriter().write(\"controller..\"); return null; &#125;&#125; org.springframework.web.HttpRequestHandler 实现HttpRequestHandler接口，重写handleRequest方法，同样bean名称为请求映射地址 1234567@Component(\"/index3.do\")public class IndexController3 implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(\"HttpRequestHandler..\"); &#125;&#125; HandlerMapping映射请求到对应的Handler org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping 在实现（Controller，HttpRequestHandler）接口的Handler集合中寻找合适的Handler完成请求的处理 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 在添加了@Controller注解的Handler集合中寻找合适的Handler完成请求的处理 HandlerAdapter调用Handler的相关方法，完成对请求的处理 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 调用带有@RequestMapping注解的handler，完成请求的处理 org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter 调用实现了Controller的handler，完成请求的处理 org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter 调用实现了HttpRequestHandler的handler，完成请求的处理","categories":[{"name":"Java","slug":"Java","permalink":"https://qianxiaoxinrou.github.io/categories/Java/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://qianxiaoxinrou.github.io/tags/SpringMVC/"}]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://qianxiaoxinrou.github.io/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Linux","slug":"Linux","permalink":"https://qianxiaoxinrou.github.io/categories/Linux/"},{"name":"Java","slug":"Java","permalink":"https://qianxiaoxinrou.github.io/categories/Java/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://qianxiaoxinrou.github.io/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://qianxiaoxinrou.github.io/tags/Java/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://qianxiaoxinrou.github.io/tags/CentOS7/"},{"name":"docker","slug":"docker","permalink":"https://qianxiaoxinrou.github.io/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://qianxiaoxinrou.github.io/tags/nginx/"},{"name":"Spring","slug":"Spring","permalink":"https://qianxiaoxinrou.github.io/tags/Spring/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://qianxiaoxinrou.github.io/tags/Spring-Cloud/"},{"name":"OAuth2","slug":"OAuth2","permalink":"https://qianxiaoxinrou.github.io/tags/OAuth2/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://qianxiaoxinrou.github.io/tags/SpringMVC/"}]}