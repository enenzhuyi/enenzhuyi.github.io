{"meta":{"title":"TABUXIANGMA","subtitle":"","description":"","author":"QianXiao","url":"https://blog.94wo.cc","root":"/"},"pages":[{"title":"404 Not Found","date":"2020-04-18T07:50:49.137Z","updated":"2020-04-18T07:50:49.132Z","comments":true,"path":"404.html","permalink":"https://blog.94wo.cc/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-04-18T07:47:25.346Z","updated":"2020-04-18T07:47:25.336Z","comments":true,"path":"about/index.html","permalink":"https://blog.94wo.cc/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2020-04-18T07:48:15.496Z","updated":"2020-04-18T07:48:15.490Z","comments":true,"path":"categories/index.html","permalink":"https://blog.94wo.cc/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-04-18T07:50:06.549Z","updated":"2020-04-18T07:50:06.545Z","comments":true,"path":"friends/index.html","permalink":"https://blog.94wo.cc/friends/index.html","excerpt":"这里写友链上方的内容。","text":"这里写友链上方的内容。 这里可以写友链页面下方的文字备注，例如自己的友链规范、示例等。"},{"title":"","date":"2020-04-18T07:49:33.954Z","updated":"2020-04-18T07:49:33.948Z","comments":true,"path":"mylist/index.html","permalink":"https://blog.94wo.cc/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-18T07:48:52.683Z","updated":"2020-04-18T07:48:52.679Z","comments":true,"path":"tags/index.html","permalink":"https://blog.94wo.cc/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Linux面试题总结","slug":"Linux面试题总结","date":"2020-04-30T01:43:40.000Z","updated":"2020-04-30T01:45:36.879Z","comments":true,"path":"2020/04/30/Linux面试题总结/","link":"","permalink":"https://blog.94wo.cc/2020/04/30/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"总结了自己刷题过程中和网上常见的面试题","text":"总结了自己刷题过程中和网上常见的面试题 tar命令12345-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件 这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。 12345-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出 下面的参数-f是必须的 1-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.94wo.cc/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"https://blog.94wo.cc/tags/Java%E9%9D%A2%E8%AF%95/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/tags/Linux/"}]},{"title":"Spring Aop概念知识点总结","slug":"Spring-Aop概念知识点总结","date":"2020-04-30T00:55:59.000Z","updated":"2020-04-30T01:24:30.388Z","comments":true,"path":"2020/04/30/Spring-Aop概念知识点总结/","link":"","permalink":"https://blog.94wo.cc/2020/04/30/Spring-Aop%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/","excerpt":"总结了网上关于Spring AOP概念与知识点，外加自己的理解","text":"总结了网上关于Spring AOP概念与知识点，外加自己的理解 AOP术语 通知 定义：切面需要完成的工作。 定义了切面是什么，何时使用。 Spring中的五种通知类型： Before——在方法调用之前调用通知 After——在方法完成之后调用通知，无论方法执行成功与否 After-returning——在方法执行成功之后调用通知 After-throwing——在方法抛出异常后进行通知 Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为 连接点 定义：应用程序执行过程中能够插入一个切面的点 连接点可以是在调用方法时、抛出异常时、甚至是修改字段时 切面代码通过连接点插入到正常业务代码中 在程序运行过程中能够应用到通知 切点 定义：负责匹配通知所要织入的一个或多个连接点 通常通过使用明确的类或者是方法来指定 作用：定义通知应用的位置 切面 定义：是通知和切点的集合，通知和切点共同定义了切面的全部功能——它是什么，在何处完成什么功能。 引入 定义：向现有的类中增加方法或属性 织入 定义：将切面应用到目标对象来创建代理对象的过程 切面通过指定的连接点织入到目标对象，在目标对象生命周期中可以有多个连接点的织入 编译期——切面在目标类编译时期被织入，这种方式需要特殊编译器。AspectJ的织入编译器就是以这种方式织入切面。 类加载期——切面在类加载到 JVM ，这种方式需要特殊的类加载器，他可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5 的 LTW 就支持这种织入方式 运行期——切面在应用运行期间的某个时刻被织入。一般情况下，在织入切面时候，AOP 容器会为目标对象动态的创建代理对象。Spring AOP 就是以这种方式织入切面。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/tags/Java/"},{"name":"Spring AOP","slug":"Spring-AOP","permalink":"https://blog.94wo.cc/tags/Spring-AOP/"}]},{"title":"Spring面试题总结","slug":"Spring面试题总结","date":"2020-04-29T01:30:07.000Z","updated":"2020-04-30T01:47:12.026Z","comments":true,"path":"2020/04/29/Spring面试题总结/","link":"","permalink":"https://blog.94wo.cc/2020/04/29/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"总结了自己刷题过程中和网上常见的面试题","text":"总结了自己刷题过程中和网上常见的面试题 Spring中Bean作用域？ singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。 global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话 Spring事务传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。Spring中默认为PROPAGATION_REQUIRED。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 Spring事务隔离级别 隔离级别类型 说明 ISOLATION_DEFAULT 使用后端数据库默认的隔离级别。Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别 ISOLATION_READ_UNCOMMITTED 允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。 ISOLATION_READ_COMMITTED 允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。 ISOLATION_REPEATABLE_READ 对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。 ISOLATION_SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。 脏读：一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。 不可重复读：一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。 幻读：当一个事务（1）读取几行记录后，另一个并发事务（2）插入了一些记录并提交，事务（1）再次查询，可以看到事务（2）添加的额外记录。 什么是 Spring 框架?​ 我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。 列举一些重要的Spring模块？ Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IOC 依赖注入功能。 *Spring Aspects * ：该模块为与AspectJ的集成提供支持。 Spring AOP ：提供了面向方面的编程实现。 Spring JDBC : Java数据库连接。 Spring JMS ：Java消息服务。 Spring ORM : 用于支持Hibernate等ORM工具。 Spring Web : 为创建Web应用程序提供支持。 Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。 谈谈自己对于 Spring IoC 和 AOP 的理解IoC ​ IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring容器来管理。 IoC 在其他语言中也有应用，并非 Spirng 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。 ​ 将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。 AOP ​ AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 ​ Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理。 ​ 此外，SpringAOP支持AspectJ表达式。 Spring AOP 和 AspectJ AOP 有什么区别？​ Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。 ​ Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。 ​ 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。 Spring 中的单例 bean 的线程安全问题了解吗？​ 大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。 ​ 常见的有两种解决办法： 在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。 Spring 中的 bean 生命周期？ Bean 容器找到配置文件中 Spring Bean 的定义。 Bean 容器利用 Java Reflection API 创建一个Bean的实例。 如果涉及到一些属性值 利用 set()方法设置一些属性值。 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。 如果Bean实现了 BeanFactoryAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoade r对象的实例。 与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。 图示： 说说自己对于 Spring MVC 了解?​ MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。 原理图： 客户端（浏览器）发送请求，直接请求到 DispatcherServlet。 DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。 解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。 HandlerAdapter 会根据 Handler来调用真正的处理器开处理请求，并处理相应的业务逻辑。 处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。 ViewResolver 会根据逻辑 View 查找实际的 View。 DispaterServlet 把返回的 Model 传给 View（视图渲染）。 把 View 返回给请求者（浏览器） Spring 框架中用到了哪些设计模式？ 工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。 代理设计模式 : Spring AOP 功能的实现。 单例设计模式 : Spring 中的 Bean 默认都是单例的。 模板方法模式 : Spring 中 jdbcTemplate、hibernateTemplate 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。 包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。 观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。 适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。 …… @Component 和 @Bean 的区别是什么？ 作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。 @Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。 @Bean注解使用示例： 12345678@Configurationpublic class AppConfig &#123; @Bean public TransferService transferService() &#123; return new TransferServiceImpl(); &#125;&#125; 上面的代码相当于下面的 xml 配置 123&lt;beans&gt; &lt;bean id=\"transferService\" class=\"com.acme.TransferServiceImpl\"/&gt;&lt;/beans&gt; 下面这个例子是通过 @Component 无法实现的。 1234567891011@Beanpublic OneService getService(status) &#123; case (status) &#123; when 1: return new serviceImpl1(); when 2: return new serviceImpl2(); when 3: return new serviceImpl3(); &#125;&#125; 将一个类声明为Spring的 bean 的注解有哪些?我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现： @Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于拿个层，可以使用@Component 注解标注。 @Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。 @Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。 @Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。 Spring 管理事务的方式有几种？ 编程式事务，在代码中硬编码。(不推荐使用) 声明式事务，在配置文件中配置（推荐使用） 声明式事务又分为两种： 基于XML的声明式事务 基于注解的声明式事务","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.94wo.cc/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"https://blog.94wo.cc/tags/Java%E9%9D%A2%E8%AF%95/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.94wo.cc/tags/Spring/"}]},{"title":"MyBatis面试题总结","slug":"MyBatis面试题总结","date":"2020-04-28T23:34:51.000Z","updated":"2020-04-30T01:47:41.312Z","comments":true,"path":"2020/04/29/MyBatis面试题总结/","link":"","permalink":"https://blog.94wo.cc/2020/04/29/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"总结了自己刷题过程中和网上常见的面试题","text":"总结了自己刷题过程中和网上常见的面试题 实体对象与数据库字段名不一致，怎么办？ sql语句中使用别名 MyBatis开启驼峰命名规则 在映射文件中自定义ResultMap来映射字段名和实体类属性名的一一对应的关系。 #{}和${}的区别是什么？#{} 是预编译处理，${}是字符串替换。 Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。 Mybatis在处理${}时，就是把${}替换成变量的值。 使用#{}可以有效的防止SQL注入，提高系统安全性。 如何获取自动生成的(主)键值?方法一： 1. xml映射器： 在定义xml映射器时设置属性useGeneratedKeys值为true，并分别指定属性keyProperty和keyColumn为对应的数据库记录主键字段与Java对象的主键属性。 1234567&lt;mapper namespace=\"cn.mybatis.mydemo.mapper\"&gt; &lt;!-- 插入数据：返回记录主键id值 --&gt; &lt;insert id=\"insertPerson\" parameterType=\"cn.mybatis.mydemo.domain.Person\" useGeneratedKeys=\"true\" keyProperty=\"id\" keyColumn=\"id\" &gt; insert into t_person(name,sex,age,create_time,update_time) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,now(),now()) &lt;/insert&gt;&lt;/mapper&gt; 2. 接口映射器： 在接口映射器中通过注解@Options分别设置参数useGeneratedKeys，keyProperty，keyColumn值 1234// 返回主键字段id值@Options(useGeneratedKeys = true, keyProperty = \"id\", keyColumn = \"id\")@Insert(\"insert into t_person(name,sex,age,create_time,update_time) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,now(),now())\")Integer insertPerson(Person person); 需要注意的是，在MyBatis中添加操作返回的是记录数并非记录主键id。因此，如果需要获取新添加记录的主键值，需要在执行添加操作之后，直接读取Java对象的主键属性。 123Integer rows = sqlSession.getMapper(PersonMapper.class).insertPerson(person);System.out.println(\"rows = \" + rows); // 添加操作返回记录数System.out.println(\"id = \" + person.getId()); // 执行添加操作之后通过Java对象获取主键属性值 方法二： 1. mysql 在插入数据之后，mybatis再次查询mysql数据库，获得了主键id，然后填充到person对象的id属性的。 1234567&lt;insert id=\"insertPerson\" parameterType=\"cn.mybatis.mydemo.domain.Person\"&gt; &lt;selectKey resultType=\"INTEGER\" order=\"AFTER\" keyProperty=\"id\"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into t_person(name,sex,age,create_time,update_time) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,now(),now())&lt;/insert&gt; 参数说明： SELECT LAST_INSERT_ID()： 获取刚刚插入的主键； keyProperty：表示将返回的值设置到某一列，此处为id； order：表明此代码相对于insert语句的执行顺序，BEFORE(适用于Oralce等取序列的数据库)/ARTER(适用于MySQL等支持自增长的数据库)； resultType：返回的类型； 2. oracle 先查询序列得到主键，将主键设置到person对象的id属性，最后将person对象插入数据库。 在执行insert之前执行select 序列.nextval() from dual取出序列最大值，将值设置到person对象的id属性 1234567&lt;insert id=\"insertUser\" parameterType=\"cn.itcast.mybatis.po.User\"&gt; &lt;selectKey keyProperty=\"id\" order=\"BEFORE\" resultType=\"int\"&gt; select 序列.nextval() from dual &lt;/selectKey&gt; INSERT INTO USER(id,username,birthday,sex,address) VALUES( 序列.nextval(),#&#123;username&#125;,# &#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)&lt;/insert&gt; 在mapper中如何传递多个参数?第一种：使用占位符 与Spring整合的情况 方式一： 对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。 123&lt;select id=\"selectUser\"resultMap=\"BaseResultMap\"&gt; select * fromuser_user_t whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125; &lt;/select&gt; 方式二： 123public interface usermapper &#123; user selectuser(@param(“username”) string username, @param(“hashedpassword”) string hashedpassword); &#125; 123456&lt;select id=”selectuser” resulttype=”user”&gt; select id, username, hashedpassword from some_table where username = #&#123;username&#125; and hashedpassword = #&#123;hashedpassword&#125; &lt;/select&gt; 第二种：使用Map集合 单独使用MyBatis的情况 12345678910111213141516171819try &#123; //映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL /** * 由于我们的参数超过了两个，而方法中只有一个Object参数收集 * 因此我们使用Map集合来装载我们的参数 */ Map&lt;String, Object&gt; map = new HashMap(); map.put(\"start\", start); map.put(\"end\", end); return sqlSession.selectList(\"StudentID.pagination\", map);&#125; catch (Exception e) &#123; e.printStackTrace(); sqlSession.rollback(); throw e;&#125; finally &#123; MybatisUtil.closeSqlSession();&#125; 1234567&lt;!--分页查询--&gt;&lt;select id=\"pagination\" parameterType=\"map\" resultMap=\"studentMap\"&gt; /*根据key自动找到对应Map集合的value*/ select * from students limit #&#123;start&#125;,#&#123;end&#125;;&lt;/select&gt; Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？ Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能。 Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。 其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。 Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？如果配置了namespace那么当然是可以重复的，因为我们的Statement实际上就是namespace+id 如果没有配置namespace的话，那么相同的id就会导致覆盖了。 为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？ Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。 而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。 通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。 Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。 举例： 123com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。 Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。 Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 接口绑定有几种实现方式,分别是怎么实现的? 通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定。 另外一种就是通过xml里面写SQL来绑定，在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。 Mybatis是如何进行分页的？分页插件的原理是什么？​ Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。 ​ 分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。 举例： 1select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10 简述Mybatis的插件运行原理，以及如何编写一个插件​ Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。 ​ 实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。 Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？​ Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。 ​ 它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。 ​ 当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。 Mybatis都有哪些Executor执行器？它们之间的区别是什么？Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。 SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。 ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。 BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。 作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。 MyBatis与Hibernate有哪些不同？ Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。 Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。 Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。 Mybatis一级缓存、二级缓存Mybatis查询缓存包括，一级缓存、二级缓存。 一级缓存： ​ SqlSession级别的缓存。在第一次查询时，将查询结果缓存到SqlSession对象中。在第二次查询时，若是同一个SqlSession对象，则从缓存中获取数据。 ​ 只要执行SqlSession的commit方法，那么就会直接将SqlSession缓存对象全部清空掉。 二级缓存： ​ namespace级别的缓存，范围是同一个namespace下的所有xxxMapper对象。 ​ MyBatis默认开启二级缓存，MyBatis提供Cache接口","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.94wo.cc/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"https://blog.94wo.cc/tags/Java%E9%9D%A2%E8%AF%95/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.94wo.cc/tags/MyBatis/"}]},{"title":"Java基础面试题总结","slug":"Java基础面试题总结","date":"2020-04-19T06:33:29.000Z","updated":"2020-04-30T02:11:57.399Z","comments":true,"path":"2020/04/19/Java基础面试题总结/","link":"","permalink":"https://blog.94wo.cc/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/","excerpt":"总结了自己刷题过程中和网上常见的面试题","text":"总结了自己刷题过程中和网上常见的面试题 i++和++i123456789public static void main(String[] args) &#123; int i = 1; i = i++; int j = i++; int k = i+ ++i * i++; System.out.println(i); System.out.println(j); System.out.println(k);&#125; 结果： 1234111 明确局部变量表和操作数栈两个概念 1int i = 1 在局部变量表里将i的值赋为1 1i = i++; 将i的值（1）压入操作数栈，i自增1，变为2。 弹出栈顶元素，将1赋值给i，i变为1。 1int j = i++; 将i的值（1）压入操作数栈，i自增1，变为2。 弹出栈顶元素，将1赋值给j，j变为1. 1int k = i+ ++i * i++; 根据运算优先级判断执行顺序 将i的值（2）压入操作数栈 i值自增1，变为3，将i的值（3）压入操作数栈 将i的值（3）压入操作数栈，i自增1，变为4 操作数栈弹出两个元素（3，3），进行乘法运算，结果为9，并压入操作数栈 操作数栈弹出两个元素（9，2），进行加法运算，结果为11，并压入操作数栈 操作数栈弹出一个元素（11），赋值给k 类初始化Father类 123456789101112131415161718192021222324252627282930313233public class Father &#123; public static int i = method(); public int j = test(); static &#123; System.out.print(\"(1)\"); &#125; Father() &#123; System.out.print(\"(2)\"); &#125; Father(int i) &#123; System.out.print(\"(2-1)\"); &#125; &#123; System.out.print(\"(3)\"); &#125; public int test() &#123; System.out.print(\"(4)\"); return 1; &#125; public static int method() &#123; System.out.print(\"(5)\"); return 1; &#125;&#125; Son类 12345678910111213141516171819202122232425262728293031323334353637public class Son extends Father &#123; public static int i = method(); public int j = test(); static &#123; System.out.print(\"(6)\"); &#125; Son() &#123; super(1); System.out.print(\"(7)\"); &#125; &#123; System.out.print(\"(8)\"); &#125; public int test() &#123; System.out.print(\"(9)\"); return 1; &#125; public static int method() &#123; System.out.print(\"(10)\"); return 1; &#125; public static void main(String[] args) &#123; Son s1 = new Son(); System.out.println(); Son s2 = new Son(); System.out.println(); &#125;&#125; 运行结果 12(5)(1)(10)(6)(9)(3)(2-1)(9)(8)(7)(9)(3)(2-1)(9)(8)(7) Java初始化过程，包括类初始化和实例初始化两部分 类初始化过程 123456781.main()所在类2.子类在初始化前需要先初始化父类3.执行&lt;clinit&gt;方法 静态成员变量赋值和执行静态代码块 按照自上而下的顺序对静态成员变量赋值和执行静态代码块 只执行一次 实例初始化 12345671.执行&lt;init&gt;方法 非静态变量赋值、执行非静态代码块和构造方法 按照自上而下的顺序对非静态变量赋值、执行非静态代码块，最后执行构造方法 子类在执行&lt;init&gt;之前会执行父类的&lt;init&gt;，父类构造方法由子类super()所决定，默认为无参构造 每次创建都会执行2.注意字类的重写方法（多态性） 方法重写 参数列表必须完全与被重写方法的相同； 返回类型必须完全与被重写方法的返回类型相同； 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。 不可重写的方法类型 final修饰的方法 静态方法 方法传值调用方法的时候，本质上都是将值COPY一份传递给被调方法。不过，对于基本类型来说，修改形参不会对原有的值造成影响。对于引用类型来说，传递的值为对象的真实地址，修改形参会对原有的值造成影响。 此外，需要注意String、Integer（-128~127）等不可变对象。 变量类型、作用域和初始化变量类型主要包括局部变量和成员变量。 局部变量保存在方法栈桢中，只能用final关键字进行修饰，作用域为当前{}内。局部变量没有初始值，需要进行初始化。 成员变量包括类变量和实例变量，能够被jvm初始化，可以用public、protected、private、static、final、transient、volatile关键字进行修饰。在初始化过程中注意就近原则。 类变量保存在方法区中，作用域为当前类。 实例变量保存在堆中，作用域为当前实例。 若局部变量和类变量重名，则可以使用类名.变量名进行访问。 若局部变量和成员变量重名，则可以使用this.变量名进行访问。 基本数据类型 数据类型 大小/位 包装类 默认值（零值） 可表示数据范围 byte(字节) 8-bit Byte (byte)0 -128~127 short(短整数) 16-bit Short (short)0 -32768~32767 int(整数) 32-bit Integer 0 -2147483648~2147483647 long(长整数) 64-bit Long 0L -9223372036854775808~9223372036854775807 float(单精度) 32-bit Float 0.0F 1.4E-45~3.4028235E38 double(双精度) 64-bit Double 0.0D 4.9E-324~1.7976931348623157E308 boolean Boolean flase true或false char(字符) 16-bit Character ‘\\u0000’（对应数字0，输出为空） 0~65535 第一类：整数类型 byte short int long 第二类：浮点型 float double 第三类：逻辑型 boolean(它只有两个值可取true false) 第四类：字符型 char byte、short在计算时默认转int 低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double 不同的数据类型不能自动装箱拆箱 枚举相关123456enum AccountType &#123; SAVING, FIXED, CURRENT; private AccountType() &#123; System.out.println(“It is a account type”); &#125;&#125; 枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型。上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中： 1private AccountType() &#123; System.out.println(“It is a account type”); &#125; 会变成： 1234private AccountType(String s, int i) &#123; super(s,i); System.out.println(“It is a account type”); &#125; 而在这个类中，会添加若干字段来代表具体的枚举类型： 123public static final AccountType SAVING;public static final AccountType FIXED;public static final AccountType CURRENT; 而且还会添加一段static代码段： 12345678static&#123; SAVING = new AccountType(\"SAVING\", 0); //... CURRENT = new AccountType(\"CURRENT\", 0); $VALUES = new AccountType[]&#123; SAVING, FIXED, CURRENT &#125; &#125; 以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型） 在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。 方法重写总结来说为： 方法名相同，参数类型相同 子类返回类型等于父类方法返回类型， 子类抛出异常小于等于父类方法抛出异常， 子类访问权限大于等于父类方法访问权限。 详细的说明为： 重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。 即外壳不变，核心重写！ 重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。 重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。 方法的重写规则： 1）参数列表必须完全与被重写方法的相同； 2）返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java 1.5 版本之前返回类型必须一样,1.5(包含)j 版本之后ava放宽了限制,返回类型必须小于或者等于父类方法的返回类型 ）。才有了 子类返回类型小于等于父类方法返回类型。在java里面这个怎么样都是正确的,请小伙伴谨记。 3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 4）父类的成员方法只能被它的子类重写。 5）声明为final的方法不能被重写。 6）声明为static的方法不能被重写，但是能够被再次声明。 7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。 9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 10）构造方法不能被重写。 11）如果不能继承一个方法，则不能重写这个方法。 ThreadLocalThreadLocal类用于创建一个线程本地变量 在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。 ThreadLocal的使用场景： 数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。 文件名与类名一个文件中可以有多个类，如果没有public类，则可以与任意类名相同，如果有public类则文件名必须与此类名相同，因为一个文件中只能有一个public类。如果文件中只有一个类，则文件名必须与类名相同 字符串拼接123456789String a = \"a\";String b = \"b\";String str1 = \"a\" + \"b\";//常量池中的对象String str2 = a + b; //在堆上创建的新的对象 String str3 = \"ab\";//常量池中的对象System.out.println(str1 == str2);//falseSystem.out.println(str1 == str3);//true System.out.println(str2 == str3);//false 字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中。而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。 运算符&lt;&lt;表示左移位 &gt;&gt;表示带符号右移位 &gt;&gt;&gt;表示无符号右移，左边空出的位以0填充 运行异常和非运行异常运行异常，可以通过java虚拟机来自行处理。非运行异常，我们应该捕获或者抛出 原码、反码、补码在计算机系统中，数值一律用补码来表示（存储） 正数符号位是0，负数符号位是1 正数原码，反码，补码相同 负数反码除了符号位不变，其他位取反，补码=反码+1 以下 b 的值是： byte b = (byte)129; 129为int类型，转short，被截取为1000 0001。此时1000 0001为截取后所代表数字的补码，要将其转化为原码。 补码：1000 0001 反码：1000 0000 原码：1111 1111 即b=-127 执行如下程序代码 char chr = 127; int sum = 200; chr += 1; sum += chr; 后，sum的值是 ; （ ） 备注：同时考虑c/c++和Java的情况的话 java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328 但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出, 0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72 泛型PECS原则12345671. 只看尖括号里边的！！明确点和范围两个概念2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt;3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值6. List&lt;?&gt;和List 是相等的，都代表最大范围7. 补充：List既是点也是范围，当表示范围时，表示最大范围 代码： 12345678910111213141516171819202122class A &#123;&#125;class B extends A &#123;&#125;class C extends A &#123;&#125;class D extends B &#123;&#125;public static void main(String[] args) &#123; List&lt;A&gt; a; List list; list = a; //A对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内 List&lt;B&gt; b; a = b; //B错，点之间不能相互赋值 List&lt;?&gt; qm; List&lt;Object&gt; o; qm = o; //C对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内 List&lt;D&gt; d; List&lt;? extends B&gt; downB; downB = d; //D对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中 List&lt;?extends A&gt; downA; a = downA; //E错，范围不能赋值给点 a = o; //F错，List&lt;Object&gt;只是一个点 downA = downB; //G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛&#125; 最终类最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。 标识符 数字，字母，符号（只有_和$两种），数字不能开头。 不能是关键字（有两个保留关键字，goto，const，关键字都是小写的****）或者显式常量（null，true，false）。 关键字 keywords12345678abstract class extends implements null strictfp trueassert const false import package super tryboolean continue final instanceof private switch voidbreak default finally int protected synchronized volatilebyte do float interface public this whilecase double for long return throwcatch else goto native short throwschar enum if new static transient 构造方法 普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。 构造函数不能被继承，构造方法只能被显式或隐式的调用。 正则表达式[://] 表示匹配 :// 中的任何一个字符，也就是匹配 : 或 / [htps] 表示匹配 htps 中的任何一个字符，[htps]+ 表示一次或多次匹配前面的字符或子表达式，所以 [htps]+ 可以匹配 https a的b次幂math类中的一个静态方法 ： pow(double a, double b) ^表示异或 就是相同是0 不同是1 getClass123456789101112package test;import java.util.Date; public class SuperTest extends Date&#123; private static final long serialVersionUID = 1L; private void test()&#123; System.out.println(super.getClass().getName()); &#125; public static void main(String[]args)&#123; new SuperTest().test(); &#125; &#125; TestSuper和Date的getClass都没有重写，他们都是调用Object的getClass，而Object的getClass作用是返回的是运行时的类的名字。这个运行时的类就是当前类，所以 1super.getClass().getName() 返回的是test.SuperTest，与Date类无关 要返回Date类的名字需要写super.getClass().getSuperclass() 递归123456789101112public class Main &#123; public static void main(String[] args) &#123; split(12); &#125; public static int split(int number) &#123; if (number &gt; 1) &#123; if (number % 2 != 0) System.out.print(split((number + 1) / 2)); System.out.print(split(number / 2)); &#125; return number; &#125;&#125; 分析过程，伪代码： 1234567891011sout split(6) &#x3D; &#123; sout split(3) &#x3D; &#123; sout split(2) &#x3D; &#123; sout split(1) return 2 &#125; sout split(1) return 3; &#125; return 6&#125; 异常 异常分为运行时异常，非运行时异常和error，其中error是系统异常，只能重启系统解决。非运行时异常需要我们自己补获，而运行异常是程序运行时由虚拟机帮助我们补获。运行时异常包括数组的溢出，内存的溢出空指针，分母为0等！ 接口和抽象类 接口中属性为public static final，方法为public abstract，接口中不可以有构造方法。 抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已 Java不允许类多重继承 jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体 线程停止方法sleep让线程休眠，yield让运行中的线程回到就绪状态，synchronized只是同步阻塞，让线程进入对象的阻塞队列 一维数组 静态初始化 1int array[] = new int[]&#123;1,2,3,4,5&#125; 或者 1int array[] = &#123;1,2,3,4,5&#125; 需要注意的是，写成如下形式是错误的 1int array[] = new int[5]&#123;1,2,3,4,5&#125; 方法重载 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 类之间关系USES-A：依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。 关联关系：A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。 HAS-A：聚合关系，拥有关系，是关联关系的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。 IS-A：表示继承。父类与子类，这个就不解释了。 要注意：还有一种关系：组合关系也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。 二维数组12345float f[][] = new float[6][6];float []f[] = new float[6][6];float f[][] = new float[][6];//errorfloat [][]f = new float[6][6];float [][]f = new float[6][]; 数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。 字符编码和国际化 Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。 不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。 例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”); Java虚拟机中通常使用UTF-16的方式保存一个字符（char） ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。 虚函数和纯虚函数 虚函数的存在是为了多态。Java中其实没有虚函数的概念，它的普通函数就相当于C++的虚函数，动态绑定是Java的默认行为。如果Java中不希望某个函数具有虚函数特性，可以加上final关键字变成非虚函数。 抽象函数或者说是纯虚函数的存在是为了定义接口。Java中纯虚函数形式为：abstract void print(); Integer123456789Integer i01=59;int i02=59;Integer i03=Integer.valueOf(59);Integer i04=new Integer(59);System.out.println(i01==i02);//trueSystem.out.println(i01==i03);//trueSystem.out.println(i03==i04);//falseSystem.out.println(i02==i04);//true 无论如何，Integer=xxx与new Integer不会相等，不会经历拆箱过程 两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。例如，java在编译Integer i2 = 128的时候，被翻译成-&gt; Integer i2 = Integer.valueOf(128); 而valueOf()函数会对-128到127之间的数进行缓存 两个都是new出来的,都为false int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比 Thread.join() 例题： 12345678910111213141516public static void main(String[] args) throws InterruptedException &#123; Thread t=new Thread(new Runnable() &#123; public void run() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; System.out.print(\"2\"); &#125; &#125;); t.start(); t.join(); System.out.print(\"1\");&#125; 因为子线程的休眠时间太长，因此主线程很有可能在子线程之前结束也就是输出结果是12，但是子线程用了join函数，因此主线程必须等待子线程执行完毕才结束因此输出结果只能是21 12t.join(); //使调用线程 t 在此之前执行完毕。t.join(1000); //等待 t 线程，等待时间是1000毫秒 常见的锁 自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁 阻塞锁 被阻塞的线程，不会争夺锁。 可重入锁 多次进入改锁的域 读写锁 互斥锁 锁本身就是互斥的 悲观锁 不相信，这里会是安全的，必须全部上锁 乐观锁 相信，这里是安全的。 公平锁 有优先级的锁 非公平锁 无优先级的锁 偏向锁 无竞争不锁，有竞争挂起，转为轻量锁 对象锁 锁住对象 线程锁 锁粗化 多锁变成一个，自己处理 轻量级锁 CAS 实现 锁消除 偏向锁就是锁消除的一种 锁膨胀 jvm实现，锁粗化 信号量 使用阻塞锁 实现的一种策略 排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。 包装类 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱 包装类的equals()方法不处理数据转型 操作符 &amp; 与操作 | 或操作 ! 非操作 ~ 取反操作 hashCode和equalshashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。 那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。 那么hashCode()既然效率这么高为什么还要equals()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。 所以我们可以得出： equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。 hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。 所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低。所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）。如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ switch 语句 列题： 12345678910111213void main(void) &#123; char *s = \"1314520\"; int v1 = 0, v2 = 0, v3 = 0, v4 =0; for (int i = 0; s[i]; i++) &#123; switch(s[i]) &#123; default: v4++; case '1': v1++; case '2': v2++; cas3 '3': v3++; &#125; &#125; printf(\"%d, %d, %d, %d\", v4,v1,v2,v3)&#125; result： 13567 default顾名思义是缺省情况，只有任何条件都不匹配的情况下才会执行，故会匹配到s[i]为‘4’，‘5’，‘0’ 的情况。于是v4++三次，v4=3。并且这个default后没有使用break语句，于是case‘1’、‘2’、‘3’都会执行三次。注意到所有语句都没有加break，则语句执行过之后会继续下面的case语句。另外由于s[i]中有两个1，故v1,v2,v3此时为5.另外有一个2，v2,v3++后为6，还有一个case3 于是v3++.最终v3为7。 数组 数组是一个对象，不同类型的数组具有不同的类 数组是一个连续的存储结构 可以二维数组，且可以有多维数组，都是在Java中合法的 查看源码可以知道数组的equals方法是object的equals，比较的是内存地址 字符常量一个字符常量表示为一个字符或一个转义序列，被一对ASCII单引号关闭。 反射 Class类位于java.lang包下。Method, Filed等类位于java.lang.reflet包下 导致InterruptedException异常 java.lang.Object 类的 wait 方法 java.lang.Thread 类的 sleep 方法 java.lang.Thread 类的 join 方法 汉字长度java的String底层是char数组，它的length()返回数组大小。一个汉字等于一个字符（char），一个汉字也等于二个字节（byte）。 类加载器 Bootstrap ClassLoader，主要加载JVM自身工作需要的类。 Extension ClassLoader，主要加载%JAVA_HOME%\\lib\\ext目录下的库类。 Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是ClassLoader.getSystemClassLoader() 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath） JVM类加载机制为双亲委托模型。如此，因此所有的类加载请求最终都应该传送到顶层的Bootstrap ClassLoader中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。 自动装箱 不同的数据类型不能自动装箱拆箱 jdk命令 jps：查看本机java进程信息。 jstack：打印线程的栈信息，制作线程dump文件。 jmap：打印内存映射，制作堆dump文件 jstat：性能监控工具 jhat：内存分析工具 jconsole：简易的可视化控制台 jvisualvm：功能强大的控制台 java、javac、jar等开发工具是用Java编写的。 static属性和方法 例题： 123456789101112class Test &#123; public static void hello() &#123; System.out.println(\"hello\"); &#125;&#125;public class MyApplication &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Test test=null; test.hello(); &#125;&#125; result： 1能编译通过，并正确运行 静态方法属于静态绑定，编译器根据引用类型所属的静态类型为它绑定其对应的方法。此语句会翻译成invokestatic，该指令的调用中不会涉及this,所以不会依赖对象！ 还有引用类型=null，其实就是指该引用在堆中没有对应的对象，但是编译的时候还是能根据声明找到其所属的静态类型。 存根类存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。 dubbo远程调用可以有这么一个本地存根，场景是：用户要远程调用资源进行登录页面才能访问资源，但是无论登录成功还是不成功都得远程调用，这样就浪费了资源，所以我们就把验证这部分工作放在本地执行（本地存根），当用户验证（验证码等）工作放在本地，stub存根决定是否远程调用，也就是动态链接（动态连接使得大部分的连接过程延迟,直到程序开始运行）。 static与重载 例题： 12345678910111213141516171819202122232425262728293031public class Demo &#123; public static void main(String[] args) &#123; Collection&lt;?&gt;[] collections = &#123;new HashSet&lt;String&gt;(), new ArrayList&lt;String&gt;(), new HashMap&lt;String, String&gt;().values(); Super subToSuper = new Sub(); for (Collection&lt;?&gt; collection: collections) &#123; System.out.println(subToSuper.getType(collection)); &#125;&#125;abstract static class Super &#123; public static String getType(Collection&lt;?&gt; collection) &#123; return “Super:collection”; &#125; public static String getType(List&lt;?&gt; list) &#123; return “Super:list”; &#125; public String getType(ArrayList&lt;?&gt; list) &#123; return “Super:arrayList”; &#125; public static String getType(Set&lt;?&gt; set) &#123; return “Super:set”; &#125; public String getType(HashSet&lt;?&gt; set) &#123; return “Super:hashSet”; &#125;&#125;static class Sub extends Super &#123; public static String getType(Collection&lt;?&gt; collection) &#123; return \"Sub\"; &#125;&#125; 结果： 重载静态多分派——根据传入重载方法的参数类型，选择更加合适的一个重载方法 static方法不能被子类覆写，在子类中定义了和父类完全相同的static方法，则父类的static方法被隐藏，Son.staticmethod()或new Son().staticmethod()都是调用的子类的static方法，如果是Father.staticmethod()或者Father f = new Son(); f.staticmethod()调用的都是父类的static方法。 此题如果都不是static方法，则最终的结果是A. 调用子类的getType，输出collection 运算符优先级 优先级 运算符 结合性 1 ( ) [ ] . 从左到右 2 ! ~ ++ – 从右到左 3 * / % 从左到右 4 + - 从左到右 5 &lt;&lt; &gt;&gt; &gt;&gt;&gt; 从左到右 6 &lt; &lt;= &gt; &gt;= instanceof 从左到右 7 == != 从左到右 8 &amp; 从左到右 9 ^ 从左到右 10 | 从左到右 11 &amp;&amp; 从左到右 12 || 从左到右 13 ? : 从左到右 14 = += -= *= /= %= &amp;= |= ^= ~= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 从右到左 15 , 从右到左 当多个运算符出现在一个表达式中，谁的优先级别高，就先执行谁。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果完全不一样。 例题 123456public void complicatedexpression_r()&#123; int x=20, y=30; Boolean b; b = x &gt; 50 &amp;&amp; y &gt; 60 || x &gt; 50 &amp;&amp; y &lt; -60 || x &lt; -50 &amp;&amp; y &gt; 60 || x &lt; -50 &amp;&amp; y &lt; -60; System.out.println(b);&#125; 题中符号的优先级排序是：’&gt;’，’&lt;’，’&amp;&amp;’，’||’。 即： 1b=(x&gt;50&amp;&amp;y&gt;60)||(x&gt;50&amp;&amp;y&lt;-60)||(x&lt;-50&amp;&amp;y&gt;60)||(x&lt;-50&amp;&amp;y&lt;-60); 结果： 1false Java体系结构 Java程序设计语言 Java.class文件格式 Java应用编程接口（API） Java虚拟机 Java不可被继承的类123456789101112131415161718192021222324252627282930313233343536373839public final class Bytepublic final class Characterpublic static final class Character.UnicodeBlockpublic final class Class&lt;T&gt;public final class Compilepublic final class Doublepublic final class Floatpublic final class Integerpublic final class Longpublic final class Mathpublic final class ProcessBuilderpublic final class RuntimePermissionpublic final class Shortpublic final class StackTraceElementpublic final class StrictMathpublic final class Stringpublic final class StringBufferpublic final class StringBuilderpublic final class Systempublic final class Void String.intern()在jdk1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而用StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。而jdk1.7中的intern()实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个。 值得注意的是： 12345String s1 = new StringBuilder(\"go\").append(\"od\").toString();System.out.println(s1.intern() == s1);// trueString s2 = new StringBuilder(\"ja\").append(\"va\").toString();System.out.println(s2.intern() == s2);// false 因为，jvm会在启动时加载一部分字符串 123System.setProperty(\"java.version\", \"1.8.0_231\");System.setProperty(\"java.runtime.version\", \"1.8.0_231-b11\");System.setProperty(\"java.runtime.name\", \"Java(TM) SE Runtime Environment\"); 四舍五入Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。 switch作用选择在Java 5以前，switch(expr)中，expr只能是byte、short、char、int；从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型；从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 位运算提高计算性能2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。 补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。 描述一下JVM加载class文件的原理机制？​ JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。​ 由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。 ​ 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明： Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？12345678910111213141516class Outer &#123; class Inner &#123;&#125; public static void foo() &#123; new Inner(); &#125; public void bar() &#123; new Inner(); &#125; public static void main(String[] args) &#123; new Inner(); &#125;&#125; 注意：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：new Outer().new Inner(); 线程状态 jvm复制算法将内存按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了新生代。 如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是老年代的用处。当不够用时，这些对象将直接通过分配担保机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。 运行时常量池在JDK1.8之前运行时常量池被放在方法区,属于线程共享,JDK1.8之后,元空间取代了方法区,运行时常量池被也被放在元空间中,运行时常池 主要存放, class文件元信息描述,编译后的代码，引用类型数据，类文件常量池。所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。 运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用） CMS的GC过程 初始标记:暂停用户线程，对引用进行遍历并标记 并发标记：在并发情况下，遍历除1中标记过的线程并标记 并发预清理：并发情况下对以上的标记进行清理 重标记：由于3过程是并发的，可能会产生一些引用，所以需要暂停用户线程重新标记 并发清理：清理4过程产生的标记 并发重置：做一些收尾工作 参数配置Xms 起始内存 Xmx 最大内存 Xmn 新生代内存 Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小 -XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。其中 Eden 和 Survivor 区的比例默认是 8:1:1。 -XX:MaxPermSize=n:设置持久代大小 收集器设置-XX:+UseSerialGC:设置串行收集器-XX:+UseParallelGC:设置并行收集器-XX:+UseParalledlOldGC:设置并行年老代收集器-XX:+UseConcMarkSweepGC:设置并发收集器垃圾回收统计信息-XX:+PrintGC-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-Xloggc:filename并行收集器设置-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)并发收集器设置-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。 假如某个JAVA进程的JVM参数配置如下：-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,请问eden区最终分配的大小是多少？ 故该题为500*（3/5）=300M Java WebCookie的获取方式request.getCookies 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。 request.getHeader 以字符串形式返回指定的请求头的值。Cookie也是头的一种； request 属性参数request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。 HttpSessionAttributeListener可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知 forward和redirect区别 从地址栏显示来说 forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。 redirect是服务端根据逻辑，发送一个状态码,告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL。 从数据共享来说 forward：转发页面和转发到的页面可以共享request里面的数据。 redirect：不能共享数据。 从运用地方来说 forward：一般用于用户登陆的时候,根据角色转发到相应的模块。 redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。 从效率来说 forward：高。 redirect：低。","categories":[{"name":"面试","slug":"面试","permalink":"https://blog.94wo.cc/categories/%E9%9D%A2%E8%AF%95/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"https://blog.94wo.cc/tags/Java%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/tags/Java/"}]},{"title":"CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试","slug":"CentOS7-安装-docker-和-docker-compose-shell-脚本初次尝试","date":"2020-04-19T00:46:37.000Z","updated":"2020-04-25T10:07:55.561Z","comments":true,"path":"2020/04/19/CentOS7-安装-docker-和-docker-compose-shell-脚本初次尝试/","link":"","permalink":"https://blog.94wo.cc/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/","excerpt":"CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试","text":"CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试 参照官网教程，实现CentOS7安装docker，注意的是这里的docker是ce版本的 卸载旧版本12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装docker ce版本安装所使用的仓库安装相关依赖123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 设置stable仓库123sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安装docker ce版本1sudo yum install docker-ce docker-ce-cli containerd.io -y 开启docker1sudo systemctl start docker 设置docker开机启动1sudo systemctl enable docker 查看安装1docker version 安装docker-compose下载安装脚本1sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose 赋予脚本可执行权限1sudo chmod +x /usr/local/bin/docker-compose 查看安装1docker-compose version 安装脚本官网脚本docker官方出品 1wget -qO- get.docker.com | bash 一件脚本按照官方教程总结 1bash &lt;(curl https://raw.githubusercontent.com/qianxiaoxinrou/Linux_script/master/docker_install.sh) 本地脚本安装123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# docker_install.sh#!/bin/bashneed_add=\"\"echo \"1. 卸载自带docker\"sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engineecho \"2. 安装相关依赖\"sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2echo \"3. 设置stable仓库\"sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repoecho \"4. 安装docker ce版本\"sudo yum install docker-ce docker-ce-cli containerd.io -yecho \"5. 启动docker\"sudo systemctl start dockerecho \"6. 设置docker开机启动\"sudo systemctl enable dockerread -p \"是否需要将当前用户添加到docker用户组: (y)es 是 : (n)0 否: \" need_addif [ \"$need_add\" == \"y\" ] || [ \"$need_add\" == \"yes\" ]then sudo gpasswd -a $&#123;USER&#125; docker echo \"将 $&#123;USER&#125; 添加到 docker 用户组\"fiecho \"7. 安装docker-compose\"sudo curl -L \"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-composesudo chmod +x /usr/local/bin/docker-composeecho \"8. 安装完成\"docker versiondocker-compose version 额外配置有时当前并不是root用户，所以要将当前用户添加到docker用户组中 1sudo gpasswd -a $&#123;USER&#125; docker 网络优化参照 千影 的Linux网络优化脚本","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.94wo.cc/tags/CentOS7/"},{"name":"docker","slug":"docker","permalink":"https://blog.94wo.cc/tags/docker/"}]},{"title":"CenOS7配置ssh免密登录","slug":"CenOS7配置ssh免密登录","date":"2020-04-19T00:45:04.000Z","updated":"2020-04-19T00:46:02.762Z","comments":true,"path":"2020/04/19/CenOS7配置ssh免密登录/","link":"","permalink":"https://blog.94wo.cc/2020/04/19/CenOS7%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/","excerpt":"CenOS7配置ssh免密登录","text":"CenOS7配置ssh免密登录 生成ssh密钥我是Mac系统，其他系统类似 1cd ~ 若.ssh文件夹不存在则创建 1mkdir -p .ssh 生成ssh密钥 1ssh-keygen -m PEM -t rsa 将id_rsa.pub上传到服务器，我这里则是上传到的是服务器的/root 服务器配置这里以root用户为例 若/root/.ssh文件夹不存在，则创建 12cd ~mkdir -p .ssh 将证书内容写入到文件 1cat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys 修改ssh配置文件 123456vi /etc/ssh/sshd_config#配置远程登录RSAAuthentication yesPubkeyAuthentication yes#禁用密码登录(可选)PasswordAuthentication yes 改为 PasswordAuthentication no 重启ssh服务1systemctl restart sshd","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.94wo.cc/tags/CentOS7/"}]},{"title":"彻底搞懂 nginx 的 location 字段","slug":"彻底搞懂-nginx-的-location-字段","date":"2020-04-19T00:42:57.000Z","updated":"2020-04-19T00:43:58.864Z","comments":true,"path":"2020/04/19/彻底搞懂-nginx-的-location-字段/","link":"","permalink":"https://blog.94wo.cc/2020/04/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-nginx-%E7%9A%84-location-%E5%AD%97%E6%AE%B5/","excerpt":"彻底搞懂 nginx 的 location 字段","text":"彻底搞懂 nginx 的 location 字段 前缀符号 =：对URI和location进行精确匹配，如果找到精确匹配，那么匹配便会终止 ~：正则匹配，区分大小写 ~*：正则匹配，不区分大小写 ^~：当最长前缀匹配中包含该字符时，则不会匹配正则表达式 @：不是用来处理常规请求，而是被用来请求重定向 匹配顺序1、nginx会匹配那些定义了prefix string的location，能够完成*最长*匹配prefix string 的location会被nginx记录 2、按照 regular expressions*在配置文件出现的顺序进行匹配，找到了第一个匹配的 *regular expressions ，那么nginx便停止匹配。如果没有找到与之相匹配的 regular expressions，nginx将会使用之前被记录下来的最长匹配prefix string的location 3、如果最长匹配prefix string的location中有 ^~ ，那么nginx将不会进行regular expressions匹配 4、同理最长匹配prefix string的location中有 = ，nginx会对URI和location进行精确匹配，如果nginx找到了精确匹配，那么匹配将会终止 5、如果location的prefix string是以/结尾，那么请求可以进行特殊的处理（proxy_pass、fastcgi_pass，uwsgi_pass，scgi_pass、memcached_pass、grpc_pass）。 6、如果步骤5中location的prefix string同时存在/结尾和不带/结尾的，那么不带/结尾的将会永久的被以301状态码的方式重定向到/结尾的location中。如果对这种情况不是很满意的话，可以使用精确匹配的方式解决该问题： 1234567location /user/ &#123; proxy_pass http://user.example.com;&#125;location = /user &#123; proxy_pass http://login.example.com;&#125;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/categories/Linux/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://blog.94wo.cc/tags/nginx/"}]},{"title":"docker 学习笔记 | 持续更新~~~","slug":"docker-学习笔记-持续更新","date":"2020-04-18T12:27:05.000Z","updated":"2020-04-29T22:58:44.662Z","comments":true,"path":"2020/04/18/docker-学习笔记-持续更新/","link":"","permalink":"https://blog.94wo.cc/2020/04/18/docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","excerpt":"列出了docker常见的命令，及一些个人总结的知识点","text":"列出了docker常见的命令，及一些个人总结的知识点 镜像命令 查看本地镜像 1docker images -a：显示所有镜像 -q：显示镜像id 查找 在dockerhub上寻找 1docker search tomcat -s：列出收藏数大于指定数量 下载镜像 1docker pull tomcat 默认是tomcat:latest 删除镜像 1docker rmi tomcat / 镜像ID 删除单个的情况，版本号不写默认是latest，删除多个可以用空格隔开 -f：强制删除 1docker rmi -f $(docker images -qa) 删除本机全部镜像 生成镜像 方式1： 1docker commit tomcat 当前正在运行的容器实例 命名空间/镜像名:版本编号 根据容器实例生成镜像 -m：描述信息 -a：作者 方式2： 1docker build -f Dockerfile路径 -t 命名空间/镜像名 . 根据Dockerfile生成镜像 -f：Dockerfile路径 -t：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。 .：当前路径 查看镜像历史 1docker history 镜像id 容器命令 创建一个新的容器并运行一个命令 1docker run centos 本地有镜像的话则运行本地镜像，本地没有镜像的话则会去hub上pull -i：已交互的方式运行容器，通常都是配合-t参数使用 -t：为容器重新分配一个伪终端 --name：别名 -d：后台运行容器，并返回容器id，即启动守护式容器 -p：主机端口:docker容器端口 -P：随机分配端口 -v：绑定一个卷，主机路径:容器路径 --rm：运行结束时自动销毁 --restart：设置容器重启策略，no，默认策略，在容器退出时不重启容器；on-failure，在容器非正常退出时（退出状态非0），才会重启容器；on-failure:3，在容器非正常退出时重启容器，最多重启3次；always，在容器退出时总是重启容器；unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 值得说明的是，docker容器实例在后台运行，就必须要有一个前台进程，如果容器运行的不是那些一直挂起的命令，那么docker则会自动退出 启动一个或多个已经被停止的容器 1docker start centos 通常用来启动已经停止的容器 列出当前运行的所有容器 1docker ps -a：正在运行和历史上运行过得容器 -l：上次运行的容器实例 -n：最近n个创建的容器 -q：只显示容器id 退出容器 方式1： 1exit 关闭容器，无法再次进入 方式2： Ctrl + p + q 关闭容器之后还可以再次进入 重启容器 1docker restart centos 停止容器 方式1： 1docker stop centos 正常停止 方式2： 1docker kill centos 强制停止，类似于拔电源 删除容器 1docker rm centos 删除单个 -f：强制删除 删除多个 方式1： 1docker rm -f $(docker ps -aq) 方式： 1docker ps -aq | xargs docker rm -f 查看日志 1docker logs centos -t：时间 -f：跟随最新的日志 --tail：显示最后多少条 查看容器内运行的进程 1docker top centos 查看容器内部的细节 1docker inspect centos 重新进入docker进行交互 方式1： 1docker attach centos 直接进入容器启动的命令行终端，不会启动新的进程 方式2： 1docker exec centos 不进入容器却能够和容器交互 如果使用docker exec centos -it /bin/bash的话，则效果和docker attach centos相同 拷贝文件到宿主机 1docker cp centos:/tmp/yum.log /root 将docker中/tmp/yum.log文件拷贝到宿主机/root中 数据卷 添加数据卷 方式1： 使用直接命令的方式 1docker run -it -v /宿主机绝对路径:/容器内目录 镜像名 容器退出后，主机修改共享文件后，docker容器中文件也会被修改 查看数据卷和容器是否绑定成功 1docker inspect 容器id 在返回的json串中，查看volume属性 设置权限 1docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名 ro：read only（只读） 出现Permission denied错误 增加--privileged=true参数 方式2： 使用Dokcerfile添加，Dockerfile是对docker中镜像的描述。在Dockerfile中增加一下代码VOLUME [&quot;/data1&quot;, &quot;/data2&quot;]，值得注意的是， 通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的 拷贝文件到容器 方式1: 1docker cp /www/runoob 96f7f14e99ab:/www/ 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下 方式2: 1docker cp /www/runoob 96f7f14e99ab:/www 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www 方式3: 1docker cp 96f7f14e99ab:/www /tmp/ 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中 数据卷容器使用一个容器作为父容器，专门用来存放数据 1docker run -it --volumes-from 父容器id 子容器id 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止 Dockerfile保留字指令 FROM：当前镜像是基于那个镜像的 MAINTAINER：镜像作者及作者邮箱 RUN：容器构建时所需要执行的命令 EXPOSE：当前容器对外暴露出的端口 WORKDIR：创建容器后，终端默认进来的工作目录 ARG：构建参数和 ENV 的效果一样，都是设置环境变量。所不同的是，ARG 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 ARG 保存密码之类的信息，因为 docker history 还是可以看到所有值的。 ENV：设置环境变量，在这之后的RUN指令都可以使用该变量 ADD：拷贝（COPY） + 解压缩 COPY：直接拷贝 1COPY src dest VOLUME：容器数据卷，主机路径:容器路径 CMD：容器启动时要运行的命令。CMD指令可以有多个，但只有最后一个会生效，CMD会被docker run之后的参数替换（命令参数会被覆盖） ENTRYPOINT：容器启动时要运行的命令。（命令参数会被追加组合） ONBUILD：父镜像在子镜像build时被触发 实战篇自定义tomcat创建Dockerfile文件内容： 1234567891011121314151617181920212223# 父镜像FROM centos:7# 作者信息MAINTAINER weiguangchao&lt;3409885610@qq.com&gt;# 复制并解压ADD jdk-8u231-linux-x64.tar.gz /usr/localADD apache-tomcat-9.0.27.tar.gz /usr/local# 设置工作目录WORKDIR /usr/local/apache-tomcat-9.0.27# 设置环境变量ENV JAVA_HOME /usr/local/jdk1.8.0_231ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.27ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/bin# 设置对外暴露端口EXPOSE 8080# 安装结束后运行的命令CMD startup.sh &amp;&amp; tail -f /usr/local/apache-tomcat-9.0.27/logs/catalina.out 生成镜像1docker build -f Dockerfile2 -t weiguangchao/mytomcat:1.0 . 启动tomcat123456docker run \\-d \\-p 9999:8080 \\-v /root/webapps:/usr/local/apache-tomcat-9.0.27/webapps \\-v /root/logs/:/usr/local/apache-tomcat-9.0.27/logs \\容器ID 创建index.html在~/webapps创建ROOT/index.html文件 内容： 1&lt;h3&gt;ocg, I can do it!&lt;/h3&gt; 测试浏览器地址栏输入 http://192.168.153.130:9999/index.html 提交到hub这里以阿里云为例，其实阿里云镜像服务里面已经提供了相关操作的代码了 步骤1： 1docker login --username=阿里云用户名 registry.cn-shenzhen.aliyuncs.com 步骤2： 1docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号] 步骤3： 1sudo docker push registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号] 根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 拉取镜像1docker pull registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]","categories":[{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/categories/Linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.94wo.cc/tags/docker/"}]},{"title":"Spring Cloud OAuth2.0认证与授权","slug":"Spring-Cloud-OAuth2-0认证与授权","date":"2020-01-29T03:09:19.000Z","updated":"2020-04-29T23:13:22.140Z","comments":true,"path":"2020/01/29/Spring-Cloud-OAuth2-0认证与授权/","link":"","permalink":"https://blog.94wo.cc/2020/01/29/Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/","excerpt":"Spring Cloud OAuth2.0认证和授权","text":"Spring Cloud OAuth2.0认证和授权 OAuth2授权模式authorization_code：授权码模式第一步：客户端获取授权码客户端向认证服务器发送请求，试图获取授权码 response_type：表示授权类型，必选项，此处的值固定为”code” client_id：表示客户端的ID，必选项 redirect_uri：表示重定向URI，可选项 scope：表示申请的权限范围，可选项 state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。 1http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all&amp;state&#x3D;1 第二步：用户同意授权 第三步：客户端通过授权码获取令牌第三步本是一次请求，这里为了针对性才将此拆开 1）设置客户端身份 client_id：表示客户端ID，必选项。 client_secret：表示客户端密钥，必选项 2）获取令牌 grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。 code：表示上一步获得的授权码，必选项。 redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。 令牌参数说明： access_token：表示访问令牌，必选项。 token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。 expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。 refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。 scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。 由于授权码参数类似，就只在这里说明一次 password：密码模式第一步：用户向客户端提供用户名和密码客户端通过用户提供的用户名和密码向认证服务器申请令牌 第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌1）设置客户端身份 client_id：表示客户端ID，必选项。 client_secret：表示客户端密钥，必选项 2）获取令牌 grant_type：表示授权类型，此处的值固定为”password”，必选项。 username：表示用户名，必选项。 password：表示用户的密码，必选项。 scope：表示权限范围，可选项。 client_credentials：客户端模式第一步：设置客户端身份 client_id：表示客户端ID，必选项。 client_secret：表示客户端密钥，必选项 第二步：获取令牌 grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。 scope：表示权限范围，可选项。 implicit：简化模式简化模式为授权码模式的简化版。即，授权码模式的第一步直接通过浏览器回显令牌 1http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all Spring Cloud OAuth2认证和授权项目在父工程引入Spring Boot和Spring Cloud的相关依赖 123456789101112131415161718192021222324252627&lt;!-- Inherit defaults from Spring Boot --&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.4.RELEASE&lt;/version&gt;&lt;/parent&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Hoxton.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 认证服务 distributed-security-uaa依赖详情 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!-- eureka 客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud OAuth2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 application.yml123456789101112131415161718192021222324252627282930server: port: 5000 servlet: context-path: /uaaspring: application: name: distributed-security-uaa security: user: name: user password: 123eureka: client: serviceUrl: defaultZone: http://localhost:3000/eureka/security: oauth2: client: client-id: c1 client-secret: 123 # 回调URL registered-redirect-uri: https://www.ririiy.com # 令牌有效时间 access-token-validity-seconds: 7200 # 两小时 # 令牌刷新时间 refresh-token-validity-seconds: 259200 # 三天 resource-ids: r1 authorization: # 放行check_token请求，便于检查access_token即令牌是否合法 check-token-access: permitAll() 开启Spring Security如果不开启Spring Security的话，则会有相关提示 创建Spring Security配置类 1234567import org.springframework.context.annotation.Configuration;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;@Configurationpublic class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;&#125; 主启动类1234567891011121314151617package com.ririiy.security.distributed.uaa;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;@SpringBootApplication@EnableDiscoveryClient@EnableAuthorizationServerpublic class UaaServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(UaaServiceApplication.class, args); &#125; &#125; 资源服务 distributed-security-resource依赖详情 pom.xml123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;!-- eureka 客户端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- WEB --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Spring Cloud OAuth2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 application.yml123456789101112131415161718192021server: port: 7000 servlet: context-path: /resspring: application: name: distributed-security-reseureka: client: serviceUrl: defaultZone: http://localhost:3000/eureka/security: oauth2: resource: id: r1 # 检查token token-info-uri: http://localhost:5000/uaa/oauth/check_token # 客户端信息 client: client-id: c1 client-secret: 123 定义资源这里随便定义一个controller模拟资源 123456789101112import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class ResourceController &#123; @GetMapping(value = \"r1\", produces = \"text/html;charset=utf-8\") public String r1() &#123; return \"r1 资源\"; &#125; &#125; 主启动类1234567891011121314151617package com.ririiy.security.distributed;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;@SpringBootApplication@EnableDiscoveryClient@EnableResourceServerpublic class ResourceServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ResourceServiceApplication.class, args); &#125; &#125; 注册中心 distributed-security-registry依赖详情 pom.xml1234567&lt;dependencies&gt; &lt;!-- eureka 服务端 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 application.yml12345678910111213server: port: 3000spring: application: name: distributed-security-registryeureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ 主启动类12345678910111213import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class RegistryServiceApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(RegistryServiceApplication.class, args); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/categories/Java/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://blog.94wo.cc/tags/Spring/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.94wo.cc/tags/Spring-Cloud/"},{"name":"OAuth2","slug":"OAuth2","permalink":"https://blog.94wo.cc/tags/OAuth2/"}]},{"title":"SpringMVC初始化和请求映射分析","slug":"SpringMVC初始化和请求映射分析","date":"2019-11-22T12:21:14.000Z","updated":"2020-04-29T23:23:15.929Z","comments":true,"path":"2019/11/22/SpringMVC初始化和请求映射分析/","link":"","permalink":"https://blog.94wo.cc/2019/11/22/SpringMVC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/","excerpt":"SpringMVC初始化流程和请求适配流程分析","text":"SpringMVC初始化流程和请求适配流程分析 初始化流程SpringMVC的核心是DispatcherServlet，所以SpringMVC的初始化说白了也就是DispatcherServlet的初始化。 SpringMVC首先执行DispatcherServlet中static代码块中的逻辑，将DispatcherServlet.properties文件中的配置属性加载到名为defaultStrategies的Properties中 123456789101112static &#123; // Load default strategy implementations from properties file. // This is currently strictly internal and not meant to be customized // by application developers. try &#123; ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class); defaultStrategies = PropertiesLoaderUtils.loadProperties(resource); &#125; catch (IOException ex) &#123; throw new IllegalStateException(\"Could not load '\" + DEFAULT_STRATEGIES_PATH + \"': \" + ex.getMessage()); &#125;&#125; 由Servlet的规范可知，在Web容器（Tomcat等）启动的过程中会判断Servlet是否需要提前实例化，而是否提前实例化由程序员外部配置的loadOnStartup参数决定，并且DispatcherServlet的loadOnStartup参数通常都是设为1，即，在Web容器启动的过程中会实例化DispatcherServlet。在实例化DispatcherServlet的过程中，Web容器首先会调用Servlet的init()方法，完成对Servlet的初始化。 1234567891011121314151617181920212223@Overridepublic final void init() throws ServletException &#123; // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); if (!pvs.isEmpty()) &#123; try &#123; BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); initBeanWrapper(bw); bw.setPropertyValues(pvs, true); &#125; catch (BeansException ex) &#123; if (logger.isErrorEnabled()) &#123; logger.error(\"Failed to set bean properties on servlet '\" + getServletName() + \"'\", ex); &#125; throw ex; &#125; &#125; // Let subclasses do whatever initialization they like. initServletBean();&#125; 通过观察发现该方法最终调用了initServletBean()，在initServletBean()中SpringMVC会调用initWebApplicationContext()方法完成WebApplicationContext的初始化 123456789101112131415161718192021222324252627282930@Overrideprotected final void initServletBean() throws ServletException &#123; getServletContext().log(\"Initializing Spring \" + getClass().getSimpleName() + \" '\" + getServletName() + \"'\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Initializing Servlet '\" + getServletName() + \"'\"); &#125; long startTime = System.currentTimeMillis(); try &#123; // 初始化web环境 this.webApplicationContext = initWebApplicationContext(); initFrameworkServlet(); &#125; catch (ServletException | RuntimeException ex) &#123; logger.error(\"Context initialization failed\", ex); throw ex; &#125; if (logger.isDebugEnabled()) &#123; String value = this.enableLoggingRequestDetails ? \"shown which may lead to unsafe logging of potentially sensitive data\" : \"masked to prevent unsafe logging of potentially sensitive data\"; logger.debug(\"enableLoggingRequestDetails='\" + this.enableLoggingRequestDetails + \"': request parameters and headers will be \" + value); &#125; if (logger.isInfoEnabled()) &#123; logger.info(\"Completed initialization in \" + (System.currentTimeMillis() - startTime) + \" ms\"); &#125;&#125; 该方法最终会调用configureAndRefreshWebApplicationContext(cwac)，完成相关参数的设置之后，便调用了refresh()，完成对Spring容器的初始化 123456789101112131415161718192021222324252627282930313233protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123; if (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123; // The application context id is still set to its original default value // -&gt; assign a more useful id based on available information if (this.contextId != null) &#123; wac.setId(this.contextId); &#125; else &#123; // Generate default id... wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX + ObjectUtils.getDisplayString(getServletContext().getContextPath()) + '/' + getServletName()); &#125; &#125; wac.setServletContext(getServletContext()); wac.setServletConfig(getServletConfig()); wac.setNamespace(getNamespace()); wac.addApplicationListener(new SourceFilteringListener(wac, new ContextRefreshListener())); // The wac environment's #initPropertySources will be called in any case when the context // is refreshed; do it eagerly here to ensure servlet property sources are in place for // use in any post-processing or initialization that occurs below prior to #refresh ConfigurableEnvironment env = wac.getEnvironment(); if (env instanceof ConfigurableWebEnvironment) &#123; ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig()); &#125; postProcessWebApplicationContext(wac); applyInitializers(wac); // SpringMVC会自动调用refresh方法 wac.refresh();&#125; 这里解释了为什么SpringMVC为什么不用显式的调用refresh() 值得注意的是ContextRefreshListener，该监听器为FrameworkServlet内部的监听器，主要是用来监听Spring容器ContextRefreshedEvent事件 1234567private class ContextRefreshListener implements ApplicationListener&lt;ContextRefreshedEvent&gt; &#123; @Override public void onApplicationEvent(ContextRefreshedEvent event) &#123; FrameworkServlet.this.onApplicationEvent(event); &#125;&#125; 在refresh()的最后一步Spring会发布ContextRefreshedEvent事件，而该事件会被FrameworkServlet内部的ContextRefreshListener监听到，并且会回调到DispatcherServlet中的onRefresh方法，继而调用了DispatcherServlet中的initStrategies()方法 12345678910111213141516171819protected void initStrategies(ApplicationContext context) &#123; // MultipartResolver // 解释了为什么一定要把bean的名字配置为multipartResolver // SpringMVC内部通过getBean方法调用的名字为multipartResolver,已经写死 initMultipartResolver(context); // 国际化 initLocaleResolver(context); // 前端主题样式 initThemeResolver(context); // 初始化HandlerMapping initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); // 视图转换器 initViewResolvers(context); // 重定向数据管理器 initFlashMapManager(context);&#125; 其中，initMultipartResolver(context)方法也就解释了为什么文件上传解析器的名字一定要为multipartResolver了 123456789101112131415161718private void initMultipartResolver(ApplicationContext context) &#123; try &#123; this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class); if (logger.isTraceEnabled()) &#123; logger.trace(\"Detected \" + this.multipartResolver); &#125; else if (logger.isDebugEnabled()) &#123; logger.debug(\"Detected \" + this.multipartResolver.getClass().getSimpleName()); &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Default is no multipart resolver. this.multipartResolver = null; if (logger.isTraceEnabled()) &#123; logger.trace(\"No MultipartResolver '\" + MULTIPART_RESOLVER_BEAN_NAME + \"' declared\"); &#125; &#125;&#125; 因为SpringMVC已经将其写死了 SpringMVC会从defaultStrategies中获取默认的HandlerMapping和HandlerAdapter 123456org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMappingorg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\ org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\ org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 至此Web环境初始化完成 请求映射流程从浏览器发出请求，经过HTTPServlet和FrameworkServlet最终来到了DispatcherServlet的doDispatch方法进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; // 异步 WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; // 检查是否有Multpart processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. // 推断当前请求的handler mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // ------------------------------注意------------------------------ // 手动观察 // 如果handler是一个bean，则getHandler返回的是一个对象 // 如果handler是一个方法，则getHandler放回的是一个方法 // Spring将handler交给对应的处理器去处理 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. // Spring确定了如何调用handler的方法 String method = request.getMethod(); boolean isGet = \"GET\".equals(method); if (isGet || \"HEAD\".equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 拦截器的前置处理 if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 调用handler进行处理 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器后置处理方法 mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we're processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(\"Handler dispatch failed\", err); &#125; processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(\"Handler processing failed\", err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125;&#125; SpringMVC会遍历所有的handlerMappings找到能够处理该请求的handler，而handlerMappings的默认值为DispatcherServlet初始化时static代码块中从配置问价加载的RequestMappingHandlerMapping和BeanNameUrlHandlerMapping 注意，如果是通过@Controller注解配置的Handler，则getHandler()方法返回的是一个方法；如果是通过实现接口（Controller，HttpRequestHandler）的方法配置的Handler，那么getHandler()返回的是一个对象 SpringMVC会在handler调用的前后分别执行拦截器的applyPreHandle()和applyPostHandle()方法，完成对请求的拦截 至此请求过程调用结束… 补充Spring中的事件Spring中的事件是通过applicationEventMulticaster即广播器向所有的监听器发送的。 123456789101112131415161718192021222324252627282930313233protected void publishEvent(Object event, @Nullable ResolvableType eventType) &#123; Assert.notNull(event, \"Event must not be null\"); // Decorate event as an ApplicationEvent if necessary ApplicationEvent applicationEvent; if (event instanceof ApplicationEvent) &#123; applicationEvent = (ApplicationEvent) event; &#125; else &#123; applicationEvent = new PayloadApplicationEvent&lt;&gt;(this, event); if (eventType == null) &#123; eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType(); &#125; &#125; // Multicast right now if possible - or lazily once the multicaster is initialized if (this.earlyApplicationEvents != null) &#123; this.earlyApplicationEvents.add(applicationEvent); &#125; else &#123; getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType); &#125; // Publish event via parent context as well... if (this.parent != null) &#123; if (this.parent instanceof AbstractApplicationContext) &#123; ((AbstractApplicationContext) this.parent).publishEvent(event, eventType); &#125; else &#123; this.parent.publishEvent(event); &#125; &#125;&#125; 底层就是通过广播器拿到所有的监听器，循环调用监听的方法 12345678910111213@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); Executor executor = getTaskExecutor(); for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; SpringMVC成为Handler的三种方式 @Controller 老生常谈了，通过@RequestMapping完成映射 12345678910111213141516171819202122@RestControllerpublic class IndexController &#123; public IndexController() &#123; System.out.println(\"com.hrious.weblearn.controller.IndexController.IndexController\"); &#125; @GetMapping(\"/index.do\") @ResponseBody public String index() throws IOException &#123; System.out.println(\"com.hrious.weblearn.controller.IndexController.index\"); return \"@controller\"; &#125; @GetMapping(\"/map.do\") public Map&lt;String, String&gt; map() &#123; System.out.println(\"com.hrious.weblearn.controller.IndexController.map\"); Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(\"123\", \"xxx\"); return map; &#125;&#125; org.springframework.web.servlet.mvc.Controller 实现Controller接口，重写handleRequest方法。其中bean名称为请求映射地址 12345678@Component(\"/index2.do\")public class IndexController2 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; response.getWriter().write(\"controller..\"); return null; &#125;&#125; org.springframework.web.HttpRequestHandler 实现HttpRequestHandler接口，重写handleRequest方法，同样bean名称为请求映射地址 1234567@Component(\"/index3.do\")public class IndexController3 implements HttpRequestHandler &#123; @Override public void handleRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; response.getWriter().write(\"HttpRequestHandler..\"); &#125;&#125; HandlerMapping映射请求到对应的Handler org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping 在实现（Controller，HttpRequestHandler）接口的Handler集合中寻找合适的Handler完成请求的处理 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping 在添加了@Controller注解的Handler集合中寻找合适的Handler完成请求的处理 HandlerAdapter调用Handler的相关方法，完成对请求的处理 org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 调用带有@RequestMapping注解的handler，完成请求的处理 org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter 调用实现了Controller的handler，完成请求的处理 org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter 调用实现了HttpRequestHandler的handler，完成请求的处理","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/categories/Java/"}],"tags":[{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.94wo.cc/tags/SpringMVC/"}]}],"categories":[{"name":"面试","slug":"面试","permalink":"https://blog.94wo.cc/categories/%E9%9D%A2%E8%AF%95/"},{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/categories/Java/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/categories/Linux/"}],"tags":[{"name":"Java面试","slug":"Java面试","permalink":"https://blog.94wo.cc/tags/Java%E9%9D%A2%E8%AF%95/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.94wo.cc/tags/Linux/"},{"name":"Java","slug":"Java","permalink":"https://blog.94wo.cc/tags/Java/"},{"name":"Spring AOP","slug":"Spring-AOP","permalink":"https://blog.94wo.cc/tags/Spring-AOP/"},{"name":"Spring","slug":"Spring","permalink":"https://blog.94wo.cc/tags/Spring/"},{"name":"MyBatis","slug":"MyBatis","permalink":"https://blog.94wo.cc/tags/MyBatis/"},{"name":"CentOS7","slug":"CentOS7","permalink":"https://blog.94wo.cc/tags/CentOS7/"},{"name":"docker","slug":"docker","permalink":"https://blog.94wo.cc/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.94wo.cc/tags/nginx/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://blog.94wo.cc/tags/Spring-Cloud/"},{"name":"OAuth2","slug":"OAuth2","permalink":"https://blog.94wo.cc/tags/OAuth2/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://blog.94wo.cc/tags/SpringMVC/"}]}