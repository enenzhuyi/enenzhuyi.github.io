<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java基础面试题总结 | 持续更新~~~</title>
      <link href="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%20%7C%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%20%7C%20%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>牛客网Java刷题总结</p><a id="more"></a><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="1-i-和-i区别"><a href="#1-i-和-i区别" class="headerlink" title="1 i++和++i区别"></a>1 i++和++i区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i+ ++i * i++;</span><br><span class="line">    System.out.println(i);   </span><br><span class="line">    System.out.println(j);</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>明确局部变量表和操作数栈两个概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在局部变量表里将<code>i</code>的值赋为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i++;</span><br></pre></td></tr></table></figure><p>将<code>i</code>的值（1）压入操作数栈，<code>i</code>自增1，变为2。</p><p>弹出栈顶元素，将1赋值给<code>i</code>，<code>i</code>变为1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = i++;</span><br></pre></td></tr></table></figure><p>将<code>i</code>的值（1）压入操作数栈，<code>i</code>自增1，变为2。</p><p>弹出栈顶元素，将1赋值给<code>j</code>，<code>j</code>变为1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = i+ ++i * i++;</span><br></pre></td></tr></table></figure><p>根据运算优先级判断执行顺序</p><p>将<code>i</code>的值（2）压入操作数栈</p><p><code>i</code>值自增1，变为3，将<code>i</code>的值（3）压入操作数栈</p><p>将<code>i</code>的值（3）压入操作数栈，<code>i</code>自增1，变为4</p><p>操作数栈弹出两个元素（3，3），进行乘法运算，结果为9，并压入操作数栈</p><p>操作数栈弹出两个元素（9，2），进行加法运算，结果为11，并压入操作数栈</p><p>操作数栈弹出一个元素（11），赋值给<code>k</code></p><h3 id="2-初始化顺序"><a href="#2-初始化顺序" class="headerlink" title="2 初始化顺序"></a>2 初始化顺序</h3><p>Father类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        System.out.print(<span class="string">"(1)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.print(<span class="string">"(2)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.print(<span class="string">"(2-1)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"(3)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(4)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(5)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        System.out.print(<span class="string">"(6)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">"(7)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"(8)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(9)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(10)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5)(1)(10)(6)(9)(3)(2-1)(9)(8)(7)</span><br><span class="line">(9)(3)(2-1)(9)(8)(7)</span><br></pre></td></tr></table></figure><p>Java初始化过程，包括类初始化和实例初始化两部分</p><h4 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.main()所在类</span><br><span class="line"></span><br><span class="line">2.子类在初始化前需要先初始化父类</span><br><span class="line"></span><br><span class="line">3.执行&lt;clinit&gt;方法</span><br><span class="line"></span><br><span class="line">- 静态成员变量赋值和执行静态代码块</span><br><span class="line">- 按照自上而下的顺序对静态成员变量赋值和执行静态代码块</span><br><span class="line">- 只执行一次</span><br></pre></td></tr></table></figure><h4 id="实例初始化"><a href="#实例初始化" class="headerlink" title="实例初始化"></a>实例初始化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.执行&lt;init&gt;方法</span><br><span class="line"></span><br><span class="line">- 非静态变量赋值、执行非静态代码块和构造方法</span><br><span class="line">- 按照自上而下的顺序对非静态变量赋值、执行非静态代码块，最后执行构造方法</span><br><span class="line">- 子类在执行&lt;init&gt;之前会执行父类的&lt;init&gt;，父类构造方法由子类super()所决定，默认为无参构造</span><br><span class="line">- 每次创建都会执行</span><br><span class="line"></span><br><span class="line">2.注意字类的重写方法（多态性）</span><br></pre></td></tr></table></figure><h3 id="3-方法重写"><a href="#3-方法重写" class="headerlink" title="3 方法重写"></a>3 方法重写</h3><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p><strong>不可重写的方法类型</strong></p><ul><li>final修饰的方法</li><li>静态方法</li></ul><h3 id="4-方法传值"><a href="#4-方法传值" class="headerlink" title="4 方法传值"></a>4 方法传值</h3><p>调用方法的时候，本质上都是将值COPY一份传递给被调方法。不过，对于基本类型来说，修改形参不会对原有的值造成影响。对于引用类型来说，传递的值为对象的真实地址，修改形参会对原有的值造成影响。</p><p>此外，需要注意String、Integer（-128~127）等不可变对象。</p><h3 id="5-变量类型、作用域和初始化"><a href="#5-变量类型、作用域和初始化" class="headerlink" title="5 变量类型、作用域和初始化"></a>5 变量类型、作用域和初始化</h3><p>变量类型主要包括局部变量和成员变量。</p><p>局部变量保存在方法栈桢中，只能用<code>final</code>关键字进行修饰，作用域为当前<code>{}</code>内。局部变量没有<strong>初始值</strong>，需要进行初始化。</p><p>成员变量包括类变量和实例变量，能够被jvm初始化，可以用<code>public</code>、<code>protected</code>、<code>private</code>、<code>static</code>、<code>final</code>、<code>transient</code>、<code>volatile</code>关键字进行修饰。在初始化过程中注意就近原则。</p><p>类变量保存在方法区中，作用域为<code>当前类</code>。</p><p>实例变量保存在堆中，作用域为<code>当前实例</code>。</p><p>若局部变量和类变量重名，则可以使用<code>类名.变量名</code>进行访问。</p><p>若局部变量和成员变量重名，则可以使用<code>this.变量名</code>进行访问。</p><h3 id="6-基本数据类型"><a href="#6-基本数据类型" class="headerlink" title="6 基本数据类型"></a>6 基本数据类型</h3><table><thead><tr><th>数据类型</th><th>大小/位</th><th>包装类</th><th>默认值（零值）</th><th>可表示数据范围</th></tr></thead><tbody><tr><td>byte(字节)</td><td>8-bit</td><td>Byte</td><td>(byte)0</td><td>-128~127</td></tr><tr><td>short(短整数)</td><td>16-bit</td><td>Short</td><td>(short)0</td><td>-32768~32767</td></tr><tr><td>int(整数)</td><td>32-bit</td><td>Integer</td><td>0</td><td>-2147483648~2147483647</td></tr><tr><td>long(长整数)</td><td>64-bit</td><td>Long</td><td>0L</td><td>-9223372036854775808~9223372036854775807</td></tr><tr><td>float(单精度)</td><td>32-bit</td><td>Float</td><td>0.0F</td><td>1.4E-45~3.4028235E38</td></tr><tr><td>double(双精度)</td><td>64-bit</td><td>Double</td><td>0.0D</td><td>4.9E-324~1.7976931348623157E308</td></tr><tr><td>boolean</td><td></td><td>Boolean</td><td>flase</td><td>true或false</td></tr><tr><td>char(字符)</td><td>16-bit</td><td>Character</td><td>‘\u0000’（对应数字0，输出为空）</td><td>0~65535</td></tr></tbody></table><p>第一类：整数类型  byte short int long</p><p>第二类：浮点型  float double</p><p>第三类：逻辑型   boolean(它只有两个值可取true false)</p><p>第四类：字符型  char</p><p>byte、short在计算时默认转int</p><p>低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double</p><p>不同的数据类型不能自动装箱拆箱</p><h3 id="7-枚举相关"><a href="#7-枚举相关" class="headerlink" title="7 枚举相关"></a>7 枚举相关</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AccountType &#123;</span><br><span class="line">    SAVING, FIXED, CURRENT;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“It is a account type”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型。上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span> </span>&#123; System.out.println(“It is a account type”); &#125;</span><br></pre></td></tr></table></figure><p>会变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(s,i); </span><br><span class="line">System.out.println(“It is a account type”); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个类中，会添加若干字段来代表具体的枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType SAVING;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType FIXED;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType CURRENT;</span><br></pre></td></tr></table></figure><p>而且还会添加一段static代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  SAVING = <span class="keyword">new</span> AccountType(<span class="string">"SAVING"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">  CURRENT = <span class="keyword">new</span> AccountType(<span class="string">"CURRENT"</span>, <span class="number">0</span>);</span><br><span class="line">  $VALUES = <span class="keyword">new</span> AccountType[]&#123;</span><br><span class="line">    SAVING, FIXED, CURRENT</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）</p><p>在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。</p><h3 id="8-方法重写"><a href="#8-方法重写" class="headerlink" title="8 方法重写"></a>8 方法重写</h3><p>总结来说为：</p><p>方法名相同，参数类型相同</p><p>子类返回类型等于父类方法返回类型，</p><p>子类抛出异常小于等于父类方法抛出异常，</p><p>子类访问权限大于等于父类方法访问权限。</p><p>详细的说明为：</p><p><strong>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。</strong> <strong>即外壳不变，核心重写！</strong></p><p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p><p>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出Exception异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。</p><p>方法的重写规则：</p><ul><li>1）参数列表必须完全与被重写方法的相同；</li><li>2）<strong>返回类型必须完全与被重写方法的返回类型相同；（备注:这条信息是标准的重写方法的规则,但是在java 1.5 版本之前返回类型必须一样,1.5(包含)j</strong> <strong>版本之后ava放宽了限制,返回类型必须小于或者等于父类方法的返回类型</strong> <strong>）。才有了</strong></li><li><strong>子类返回类型小于等于父类方法返回类型。在java里面这个怎么样都是正确的,请小伙伴谨记。</strong></li><li>3）访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>4）父类的成员方法只能被它的子类重写。</li><li>5）声明为final的方法不能被重写。</li><li>6）声明为static的方法不能被重写，但是能够被再次声明。</li><li>7）子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>8）子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>9）重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>10）构造方法不能被重写。</li><li>11）如果不能继承一个方法，则不能重写这个方法。</li></ul><h3 id="9-ThreadLocal"><a href="#9-ThreadLocal" class="headerlink" title="9 ThreadLocal"></a>9 ThreadLocal</h3><p>ThreadLocal类用于创建一个线程本地变量</p><p>在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。</p><p>ThreadLocal的使用场景：</p><p>数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。</p><h3 id="10-文件名与类名"><a href="#10-文件名与类名" class="headerlink" title="10 文件名与类名"></a>10 文件名与类名</h3><p>一个文件中可以有多个类，如果没有public类，则可以与任意类名相同，如果有public类则文件名必须与此类名相同，因为一个文件中只能有一个public类。如果文件中只有一个类，则文件名必须与类名相同</p><h3 id="11-字符串拼接"><a href="#11-字符串拼接" class="headerlink" title="11 字符串拼接"></a>11 字符串拼接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象   </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中。而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。</p><h3 id="12-运算符"><a href="#12-运算符" class="headerlink" title="12 运算符"></a>12 运算符</h3><p>&lt;&lt;表示左移位</p><p>&gt;&gt;表示带符号右移位</p><p>&gt;&gt;&gt;表示无符号右移，左边空出的位以0填充</p><h3 id="13-运行异常和非运行异常"><a href="#13-运行异常和非运行异常" class="headerlink" title="13 运行异常和非运行异常"></a>13 运行异常和非运行异常</h3><p>运行异常，可以通过java虚拟机来自行处理。非运行异常，我们应该捕获或者抛出</p><h3 id="14-原码、反码、补码"><a href="#14-原码、反码、补码" class="headerlink" title="14 原码、反码、补码"></a>14 原码、反码、补码</h3><p>在计算机系统中，数值一律用<strong>补码</strong>来表示（存储）</p><p>正数符号位是0，负数符号位是1</p><p>正数原码，反码，补码相同</p><p>负数反码除了符号位不变，其他位取反，补码=反码+1</p><blockquote><p><strong>以下</strong> <strong>b</strong> <strong>的值是：</strong> <strong>byte b = (byte)129;</strong></p></blockquote><p>129为<code>int</code>类型，转<code>short</code>，被截取为1000 0001。此时1000 0001为截取后所代表数字的补码，要将其转化为原码。</p><p><strong>补码：</strong>1000 0001</p><p><strong>反码：</strong>1000 0000</p><p><strong>原码：</strong>1111 1111</p><p>即b=-127</p><blockquote><p>执行如下程序代码</p><p>char chr = 127;</p><p>int sum = 200;</p><p>chr += 1;</p><p>sum += chr;</p><p>后，sum的值是  ; （   ）</p><p>备注：同时考虑c/c++和Java的情况的话</p></blockquote><p>java中只有byte, boolean是一个字节, char是两个字节, 所以对于java来说127不会发生溢出, 输出328</p><p>但是对于c/c++语言来说, char是一个字节, 会发生溢出, 对127加一发生溢出, 0111 1111 –&gt; 1000 0000, 1000 0000为补码-128, 所以结果为200-128=72</p><h3 id="15-泛型PECS原则"><a href="#15-泛型PECS原则" class="headerlink" title="15 泛型PECS原则"></a>15 泛型PECS原则</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 只看尖括号里边的！！明确点和范围两个概念</span><br><span class="line">2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;,List&lt;B&gt;,List&lt;Object&gt;</span><br><span class="line">3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围</span><br><span class="line">4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</span><br><span class="line">5. 尖括号小范围赋值给大范围，对，大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值，否则，不能赋值</span><br><span class="line">6. List&lt;?&gt;和List 是相等的，都代表最大范围</span><br><span class="line">7. 补充：List既是点也是范围，当表示范围时，表示最大范围</span><br></pre></td></tr></table></figure><p><strong>代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;A&gt; a;</span><br><span class="line">    List list;</span><br><span class="line">    list = a;   <span class="comment">//A对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内</span></span><br><span class="line">    List&lt;B&gt; b;</span><br><span class="line">    a = b;      <span class="comment">//B错，点之间不能相互赋值</span></span><br><span class="line">    List&lt;?&gt; qm;</span><br><span class="line">    List&lt;Object&gt; o;</span><br><span class="line">    qm = o;     <span class="comment">//C对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内</span></span><br><span class="line">    List&lt;D&gt; d;</span><br><span class="line">    List&lt;? extends B&gt; downB;</span><br><span class="line">    downB = d;  <span class="comment">//D对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中</span></span><br><span class="line">    List&lt;?extends A&gt; downA;</span><br><span class="line">    a = downA;  <span class="comment">//E错，范围不能赋值给点</span></span><br><span class="line">    a = o;      <span class="comment">//F错，List&lt;Object&gt;只是一个点</span></span><br><span class="line">    downA = downB;  <span class="comment">//G对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="16-最终类"><a href="#16-最终类" class="headerlink" title="16 最终类"></a>16 最终类</h3><p>最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。</p><h3 id="17-标识符"><a href="#17-标识符" class="headerlink" title="17 标识符"></a>17 标识符</h3><ol><li>数字，字母，符号（只有_和$两种），数字不能开头。</li><li>不能是关键字（有两个保留关键字，goto，const，关键字都是小写的****）或者显式常量（null，true，false）。</li></ol><h3 id="18-关键字-keywords"><a href="#18-关键字-keywords" class="headerlink" title="18 关键字 keywords"></a>18 关键字 keywords</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class    extends implements null      strictfp     true</span><br><span class="line">assert   const    false   import     package   super        try</span><br><span class="line">boolean  continue final   instanceof private   switch       void</span><br><span class="line">break    default  finally int        protected synchronized volatile</span><br><span class="line">byte     do       float   interface  public    this         while</span><br><span class="line">case     double   for     long       return    throw</span><br><span class="line">catch    else     goto    native     short     throws</span><br><span class="line">char     enum     if      new        static    transient</span><br></pre></td></tr></table></figure><h3 id="19-构造方法"><a href="#19-构造方法" class="headerlink" title="19 构造方法"></a>19 构造方法</h3><ol><li>普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。</li><li>构造函数不能被继承，构造方法只能被显式或隐式的调用。</li></ol><h3 id="20-正则表达式"><a href="#20-正则表达式" class="headerlink" title="20 正则表达式"></a>20 正则表达式</h3><p>[://] 表示匹配 :// 中的任何一个字符，也就是匹配 : 或 /</p><p>[htps] 表示匹配 htps 中的任何一个字符，[htps]+ 表示一次或多次匹配前面的字符或子表达式，所以 [htps]+ 可以匹配 https</p><h3 id="21-a的b次幂"><a href="#21-a的b次幂" class="headerlink" title="21 a的b次幂"></a>21 a的b次幂</h3><p>math类中的一个静态方法 ： pow(double a, double b)</p><p>^表示异或 就是相同是0 不同是1</p><h3 id="22-getClass"><a href="#22-getClass" class="headerlink" title="22 getClass"></a>22 getClass</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"><span class="keyword">import</span> java.util.Date; </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line">       System.out.println(<span class="keyword">super</span>.getClass().getName()); </span><br><span class="line">    &#125; </span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123; </span><br><span class="line">       <span class="keyword">new</span> SuperTest().test(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestSuper和Date的getClass都没有重写，他们都是调用Object的getClass，而Object的getClass作用是返回的是运行时的类的名字。这个运行时的类就是当前类，所以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">super</span>.getClass().getName()</span><br></pre></td></tr></table></figure><p>返回的是test.SuperTest，与Date类无关</p><p>要返回Date类的名字需要写super.getClass().getSuperclass()</p><h3 id="23-递归"><a href="#23-递归" class="headerlink" title="23 递归"></a>23 递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    split(<span class="number">12</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">      System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析过程，伪代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sout split(6) &#x3D; &#123;</span><br><span class="line">    sout split(3) &#x3D; &#123;</span><br><span class="line">        sout split(2) &#x3D; &#123;</span><br><span class="line">            sout split(1)</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">        sout split(1)</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="24-异常"><a href="#24-异常" class="headerlink" title="24 异常"></a>24 异常</h3><p><img src="3807435_1530271039524_20577AE82E2EC5D6D44DD2CA01C99BBA.png" alt=""></p><p>异常分为运行时异常，非运行时异常和error，其中error是系统异常，只能重启系统解决。非运行时异常需要我们自己补获，而运行异常是程序运行时由虚拟机帮助我们补获。运行时异常包括数组的溢出，内存的溢出空指针，分母为0等！</p><h3 id="25-接口和抽象类"><a href="#25-接口和抽象类" class="headerlink" title="25 接口和抽象类"></a>25 接口和抽象类</h3><ol><li><p>接口中属性为public static final，方法为public abstract，接口中不可以有构造方法。</p></li><li><p>抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已</p></li><li><p>Java不允许类多重继承</p></li><li><p>jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体</p></li></ol><h3 id="26-线程停止方法"><a href="#26-线程停止方法" class="headerlink" title="26 线程停止方法"></a>26 线程停止方法</h3><p>sleep让线程休眠，yield让运行中的线程回到就绪状态，synchronized只是同步阻塞，让线程进入对象的阻塞队列</p><h3 id="27-一维数组"><a href="#27-一维数组" class="headerlink" title="27 一维数组"></a>27 一维数组</h3><ol><li>静态初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>需要<strong>注意</strong>的是，写成如下形式是<strong>错误</strong>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="28-方法重载"><a href="#28-方法重载" class="headerlink" title="28 方法重载"></a>28 方法重载</h3><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h3 id="29-类之间关系"><a href="#29-类之间关系" class="headerlink" title="29 类之间关系"></a>29 类之间关系</h3><p><strong>USES-A：</strong>依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。</p><p><strong>关联关系：</strong>A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。</p><p><strong>HAS-A：</strong>聚合关系，拥有关系，是<strong>关联关系</strong>的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。</p><p><strong>IS-A：</strong>表示继承。父类与子类，这个就不解释了。</p><p>要注意：还有一种关系：<strong>组合关系</strong>也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。</p><h3 id="30-二维数组"><a href="#30-二维数组" class="headerlink" title="30 二维数组"></a>30 二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f[][] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> []f[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> f[][] = <span class="keyword">new</span> <span class="keyword">float</span>[][<span class="number">6</span>];<span class="comment">//error</span></span><br><span class="line"><span class="keyword">float</span> [][]f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> [][]f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][];</span><br></pre></td></tr></table></figure><p>数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。</p><h3 id="31-字符编码和国际化"><a href="#31-字符编码和国际化" class="headerlink" title="31 字符编码和国际化"></a>31 字符编码和国际化</h3><ol><li>Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。</li><li>不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。</li></ol><p>例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”);</p><ol start="3"><li>Java虚拟机中通常使用UTF-16的方式保存一个字符（char）</li><li>ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。</li></ol><h3 id="32-虚函数和纯虚函数"><a href="#32-虚函数和纯虚函数" class="headerlink" title="32 虚函数和纯虚函数"></a>32 虚函数和纯虚函数</h3><ol><li><p>虚函数的存在是为了多态。Java中其实没有虚函数的概念，它的<strong>普通函数</strong>就相当于<strong>C++的虚函数</strong>，动态绑定是Java的默认行为。如果Java中不希望某个函数具有虚函数特性，可以加上<strong>final关键字</strong>变成<strong>非虚函数</strong>。</p></li><li><p>抽象函数或者说是纯虚函数的存在是为了定义接口。Java中纯虚函数形式为：abstract void print();</p></li></ol><h3 id="33-Integer"><a href="#33-Integer" class="headerlink" title="33 Integer"></a>33 Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i01==i02);<span class="comment">//true</span></span><br><span class="line">System.out.println(i01==i03);<span class="comment">//true</span></span><br><span class="line">System.out.println(i03==i04);<span class="comment">//false</span></span><br><span class="line">System.out.println(i02==i04);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol><li>无论如何，Integer=xxx与new Integer不会相等，不会经历拆箱过程</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。例如，java在编译Integer i2 = 128的时候，被翻译成-&gt; Integer i2 = Integer.valueOf(128); 而valueOf()函数会对-128到127之间的数进行缓存</li><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ol><h3 id="34-Thread-join"><a href="#34-Thread-join" class="headerlink" title="34 Thread.join()"></a>34 Thread.join()</h3><blockquote><p>例题：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">     </span><br><span class="line">    t.join();</span><br><span class="line">    System.out.print(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为子线程的休眠时间太长，因此主线程很有可能在子线程之前结束也就是输出结果是12，但是子线程用了join函数，因此主线程必须等待子线程执行完毕才结束因此输出结果只能是21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.join();      <span class="comment">//使调用线程 t 在此之前执行完毕。</span></span><br><span class="line">t.join(<span class="number">1000</span>);  <span class="comment">//等待 t 线程，等待时间是1000毫秒</span></span><br></pre></td></tr></table></figure><h3 id="35-常见的锁"><a href="#35-常见的锁" class="headerlink" title="35 常见的锁"></a>35 常见的锁</h3><ol><li><p>自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p></li><li><p>阻塞锁 被阻塞的线程，不会争夺锁。</p></li><li><p>可重入锁 多次进入改锁的域</p></li><li><p>读写锁</p></li><li><p>互斥锁 锁本身就是互斥的</p></li><li><p>悲观锁 不相信，这里会是安全的，必须全部上锁</p></li><li><p>乐观锁 相信，这里是安全的。</p></li><li><p>公平锁 有优先级的锁</p></li><li><p>非公平锁 无优先级的锁</p></li><li><p>偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p></li><li><p>对象锁 锁住对象</p></li><li><p>线程锁</p></li><li><p>锁粗化 多锁变成一个，自己处理</p></li><li><p>轻量级锁 CAS 实现</p></li><li><p>锁消除 偏向锁就是锁消除的一种</p></li><li><p>锁膨胀 jvm实现，锁粗化</p></li><li><p>信号量 使用阻塞锁 实现的一种策略</p></li><li><p>排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p></li></ol><h3 id="36-包装类"><a href="#36-包装类" class="headerlink" title="36 包装类"></a>36 包装类</h3><ol><li><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</p></li><li><p>包装类的equals()方法不处理数据转型</p></li></ol><h3 id="37-操作符"><a href="#37-操作符" class="headerlink" title="37 操作符"></a>37 操作符</h3><ol><li><p>&amp; 与操作</p></li><li><p>| 或操作</p></li><li><p>! 非操作</p></li><li><p>~ 取反操作</p></li></ol><h3 id="38-hashCode和equals"><a href="#38-hashCode和equals" class="headerlink" title="38 hashCode和equals"></a>38 hashCode和equals</h3><p>hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。</p><p><strong><em>那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？</em></strong>因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</p><p><strong><em>那么hashCode()既然效率这么高为什么还要equals()呢？</em></strong> 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。</p><p><strong><em>所以我们可以得出：</em></strong></p><ol><li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</p></li><li><p>hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p></li></ol><p>所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低。所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）。如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p><h3 id="39-switch-语句"><a href="#39-switch-语句" class="headerlink" title="39 switch 语句"></a>39 switch 语句</h3><blockquote><p>列题：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"1314520"</span>;</span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>, v4 =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i]) &#123;</span><br><span class="line">            <span class="keyword">default</span>: v4++;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: v1++;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>: v2++;</span><br><span class="line">            cas3 <span class="string">'3'</span>: v3++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d, %d, %d"</span>, v4,v1,v2,v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>result：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3567</span><br></pre></td></tr></table></figure><p>default顾名思义是缺省情况，只有任何条件都不匹配的情况下才会执行，故会匹配到s[i]为‘4’，‘5’，‘0’ 的情况。于是v4++三次，v4=3。并且这个default后没有使用break语句，于是case‘1’、‘2’、‘3’都会执行三次。注意到所有语句都没有加break，则语句执行过之后会继续下面的case语句。另外由于s[i]中有两个1，故v1,v2,v3此时为5.另外有一个2，v2,v3++后为6，还有一个case3 于是v3++.最终v3为7。</p><h3 id="40-数组"><a href="#40-数组" class="headerlink" title="40 数组"></a>40 数组</h3><ol><li>数组是一个对象，不同类型的数组具有不同的类</li><li>数组是一个连续的存储结构</li><li>可以二维数组，且可以有多维数组，都是在Java中合法的</li><li>查看源码可以知道数组的equals方法是object的equals，比较的是内存地址</li></ol><h3 id="41-字符常量"><a href="#41-字符常量" class="headerlink" title="41 字符常量"></a>41 字符常量</h3><p>一个字符常量表示为一个字符或一个转义序列，被一对ASCII<strong>单引号</strong>关闭。</p><h3 id="42-反射"><a href="#42-反射" class="headerlink" title="42 反射"></a>42 反射</h3><ol><li>Class类位于java.lang包下。Method, Filed等类位于java.lang.reflet包下</li></ol><h3 id="43-导致导致InterruptedException异常"><a href="#43-导致导致InterruptedException异常" class="headerlink" title="43 导致导致InterruptedException异常"></a>43 导致导致InterruptedException异常</h3><ol><li>java.lang.Object 类的 wait 方法</li><li>java.lang.Thread 类的 sleep 方法</li><li>java.lang.Thread 类的 join 方法</li></ol><h3 id="44-汉字长度"><a href="#44-汉字长度" class="headerlink" title="44 汉字长度"></a>44 汉字长度</h3><p>java的String底层是char数组，它的length()返回数组大小。一个汉字等于一个字符（char），一个汉字也等于二个字节（byte）。</p><h3 id="45-类加载器"><a href="#45-类加载器" class="headerlink" title="45 类加载器"></a>45 类加载器</h3><ol><li>Bootstrap ClassLoader，主要加载JVM自身工作需要的类。</li><li>Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。</li><li>Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</li><li>JVM类加载机制为<strong>双亲委托模型</strong>。如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。<strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</li></ol><h3 id="46-自动装箱"><a href="#46-自动装箱" class="headerlink" title="46 自动装箱"></a>46 自动装箱</h3><ol><li>不同的数据类型不能自动装箱拆箱</li></ol><h3 id="47-jdk命令"><a href="#47-jdk命令" class="headerlink" title="47 jdk命令"></a>47 jdk命令</h3><ol><li><p>jps：查看本机java进程信息。</p></li><li><p>jstack：打印线程的<strong>栈</strong>信息，制作线程dump文件。</p></li><li><p>jmap：打印内存映射，制作<strong>堆</strong>dump文件</p></li><li><p>jstat：性能监控工具</p></li><li><p>jhat：内存分析工具</p></li><li><p>jconsole：简易的可视化控制台</p></li><li><p>jvisualvm：功能强大的控制台</p></li></ol><p>java、javac、jar等开发工具是用Java编写的。</p><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="1-复制算法"><a href="#1-复制算法" class="headerlink" title="1 复制算法"></a>1 复制算法</h3><p>将内存按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了<strong>新生代</strong>。</p><p>如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是<strong>老年代</strong>的用处。当不够用时，这些对象将直接通过<strong>分配担保</strong>机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。</p><h3 id="2-运行时常量池"><a href="#2-运行时常量池" class="headerlink" title="2 运行时常量池"></a>2 运行时常量池</h3><p>在JDK1.8之前<strong>运行时常量池</strong>被放在方法区,属于线程共享,JDK1.8之后,元空间取代了方法区,<strong>运行时常量池</strong>被也被放在元空间中,<strong>运行时常池</strong> 主要存放, class文件元信息描述,编译后的代码，引用类型数据，类文件常量池。所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。<strong>运行时常量池</strong>是在类加载完成之后，将每个class常量池中的符号引用值转存到<strong>运行时常量池</strong>中，也就是说，每个class都有一个<strong>运行时常量池</strong>，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p><p><strong>运行时常量池</strong>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><h3 id="3-CMS的GC过程"><a href="#3-CMS的GC过程" class="headerlink" title="3 CMS的GC过程"></a>3 CMS的GC过程</h3><ol><li>初始标记:暂停用户线程，对引用进行遍历并标记</li><li>并发标记：在并发情况下，遍历除1中标记过的线程并标记</li><li>并发预清理：并发情况下对以上的标记进行清理</li><li>重标记：由于3过程是并发的，可能会产生一些引用，所以需要暂停用户线程重新标记</li><li>并发清理：清理4过程产生的标记</li><li>并发重置：做一些收尾工作</li></ol><h3 id="4-参数配置"><a href="#4-参数配置" class="headerlink" title="4 参数配置"></a>4 参数配置</h3><p>Xms 起始内存</p><p>Xmx 最大内存</p><p>Xmn 新生代内存</p><p>Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小</p><p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p><p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。其中 Eden 和 Survivor 区的比例默认是 8:1:1。</p><p>-XX:MaxPermSize=n:设置持久代大小</p><p>收集器设置<br>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器<br>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename<br>并行收集器设置<br>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><blockquote><p>假如某个JAVA进程的JVM参数配置如下：<br>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,<br>请问eden区最终分配的大小是多少？</p></blockquote><p>故该题为500*（3/5）=300M</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h3 id="1-Cookie的获取方式"><a href="#1-Cookie的获取方式" class="headerlink" title="1 Cookie的获取方式"></a>1 Cookie的获取方式</h3><p>request.getCookies</p><p>返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</p><p>request.getHeader</p><p>以字符串形式返回指定的请求头的值。Cookie也是头的一种；</p><h3 id="2-request-属性参数"><a href="#2-request-属性参数" class="headerlink" title="2 request 属性参数"></a>2 request 属性参数</h3><p>request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。</p><h3 id="3-HttpSessionAttributeListener"><a href="#3-HttpSessionAttributeListener" class="headerlink" title="3 HttpSessionAttributeListener"></a>3 HttpSessionAttributeListener</h3><p>可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知</p><h2 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h2><h3 id="1-Spring中Bean作用域"><a href="#1-Spring中Bean作用域" class="headerlink" title="1 Spring中Bean作用域"></a>1 Spring中Bean作用域</h3><p>singleton、prototype、request、session</p><h3 id="2-Spring事务"><a href="#2-Spring事务" class="headerlink" title="2 Spring事务"></a>2 Spring事务</h3><h4 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h4><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。Spring中默认为PROPAGATION_REQUIRED。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><table><thead><tr><th>隔离级别类型</th><th>说明</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别。</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td></tr></tbody></table><p><strong>脏读：</strong>一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</p><p><strong>不可重复读：</strong>一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</p><p><strong>幻读：</strong>当一个事务（1）读取几行记录后，另一个并发事务（2）插入了一些记录并提交，事务（1）再次查询，可以看到事务（2）添加的额外记录。</p><h3 id="4-SpringMVC中文乱码"><a href="#4-SpringMVC中文乱码" class="headerlink" title="4 SpringMVC中文乱码"></a>4 SpringMVC中文乱码</h3><h4 id="post乱码"><a href="#post乱码" class="headerlink" title="post乱码"></a>post乱码</h4><p>配置<code>CharacterEncodingFilter</code>，将<code>encoding</code>属性设置为UTF-8。可以修改<code>forceEncoding</code>属性，修改响应的编码。</p><h4 id="get乱码"><a href="#get乱码" class="headerlink" title="get乱码"></a>get乱码</h4><p>修改<code>tomcat</code>配置文件中<code>server.xml</code>，在<code>Connector</code>标签添加<code>URIEncoding=&quot;UTF-8&quot;</code></p><h2 id="MyBatis框架"><a href="#MyBatis框架" class="headerlink" title="MyBatis框架"></a>MyBatis框架</h2><h3 id="1-实体对象与数据库字段名不一致"><a href="#1-实体对象与数据库字段名不一致" class="headerlink" title="1 实体对象与数据库字段名不一致"></a>1 实体对象与数据库字段名不一致</h3><ol><li>sql语句中使用别名</li><li>MyBatis开启驼峰命名规则</li><li>在映射文件中自定义ResultMap</li></ol><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure><p>下面的参数-f是必须的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试</title>
      <link href="/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
      <url>/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试</p><a id="more"></a><p>参照<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">官网</a>教程，实现<code>CentOS7</code>安装<code>docker</code>，注意的是这里的<code>docker</code>是<code>ce</code>版本的</p><h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h2 id="安装docker-ce版本"><a href="#安装docker-ce版本" class="headerlink" title="安装docker ce版本"></a>安装docker ce版本</h2><h3 id="安装所使用的仓库"><a href="#安装所使用的仓库" class="headerlink" title="安装所使用的仓库"></a>安装所使用的仓库</h3><h4 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><h4 id="设置stable仓库"><a href="#设置stable仓库" class="headerlink" title="设置stable仓库"></a>设置stable仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="安装docker-ce版本-1"><a href="#安装docker-ce版本-1" class="headerlink" title="安装docker ce版本"></a>安装docker ce版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><h3 id="开启docker"><a href="#开启docker" class="headerlink" title="开启docker"></a>开启docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="设置docker开机启动"><a href="#设置docker开机启动" class="headerlink" title="设置docker开机启动"></a>设置docker开机启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="查看安装"><a href="#查看安装" class="headerlink" title="查看安装"></a>查看安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><h3 id="下载安装脚本"><a href="#下载安装脚本" class="headerlink" title="下载安装脚本"></a>下载安装脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="赋予脚本可执行权限"><a href="#赋予脚本可执行权限" class="headerlink" title="赋予脚本可执行权限"></a>赋予脚本可执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="查看安装-1"><a href="#查看安装-1" class="headerlink" title="查看安装"></a>查看安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><h2 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h2><h3 id="简单安装方法"><a href="#简单安装方法" class="headerlink" title="简单安装方法"></a>简单安装方法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl https://raw.githubusercontent.com/weiguangchao/Linux_script/master/docker_install.sh)</span><br></pre></td></tr></table></figure><h3 id="本地脚本安装"><a href="#本地脚本安装" class="headerlink" title="本地脚本安装"></a>本地脚本安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker_install.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">need_add=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1. 卸载自带docker"</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2. 安装相关依赖"</span></span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3. 设置stable仓库"</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"4. 安装docker ce版本"</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"5. 启动docker"</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"6. 设置docker开机启动"</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"是否需要将当前用户添加到docker用户组: (y)es 是 : (n)0 否: "</span> need_add</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$need_add</span>"</span> == <span class="string">"y"</span> ] || [ <span class="string">"<span class="variable">$need_add</span>"</span> == <span class="string">"yes"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"将 <span class="variable">$&#123;USER&#125;</span> 添加到 docker 用户组"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"7. 安装docker-compose"</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"8. 安装完成"</span></span><br><span class="line">docker version</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h2><p>有时当前并不是root用户，所以要将当前用户添加到docker用户组中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>参照 <a href="https://www.94ish.me/1635.html" target="_blank" rel="noopener">千影</a> 的Linux网络优化脚本</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CenOS7配置ssh免密登录</title>
      <link href="/2020/04/19/CenOS7%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2020/04/19/CenOS7%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>CenOS7配置ssh免密登录</p><a id="more"></a><h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><p>我是Mac系统，其他系统类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><p>若<code>.ssh</code>文件夹不存在则创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p .ssh</span><br></pre></td></tr></table></figure><p>生成ssh密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -m PEM -t rsa</span><br></pre></td></tr></table></figure><p>将<code>id_rsa.pub</code>上传到服务器，我这里则是上传到的是服务器的<code>/root</code></p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>这里以<code>root</code>用户为例</p><p>若<code>/root/.ssh</code>文件夹不存在，则创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir -p .ssh</span><br></pre></td></tr></table></figure><p>将证书内容写入到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>修改ssh配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#配置远程登录</span></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"><span class="comment">#禁用密码登录(可选)</span></span><br><span class="line">PasswordAuthentication yes 改为 PasswordAuthentication no</span><br></pre></td></tr></table></figure><h2 id="重启ssh服务"><a href="#重启ssh服务" class="headerlink" title="重启ssh服务"></a>重启ssh服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞懂 nginx 的 location 字段</title>
      <link href="/2020/04/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-nginx-%E7%9A%84-location-%E5%AD%97%E6%AE%B5/"/>
      <url>/2020/04/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-nginx-%E7%9A%84-location-%E5%AD%97%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>彻底搞懂 nginx 的 location 字段</p><a id="more"></a><h2 id="前缀符号"><a href="#前缀符号" class="headerlink" title="前缀符号"></a>前缀符号</h2><ul><li><code>=</code>：对<code>URI</code>和<code>location</code>进行精确匹配，如果找到精确匹配，那么匹配便会终止</li><li><code>~</code>：正则匹配，区分大小写</li><li><code>~*</code>：正则匹配，不区分大小写</li><li><code>^~</code>：当最长前缀匹配中包含该字符时，则不会匹配正则表达式</li><li><code>@</code>：不是用来处理常规请求，而是被用来请求重定向</li></ul><h2 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h2><p>1、<code>nginx</code>会匹配那些定义了<em>prefix string<em>的<code>location</code>，能够完成*</em>最长*<em>匹配</em>prefix string</em></p><p>的<code>location</code>会被nginx记录</p><p>2、按照 <em>regular expressions*在配置文件出现的顺序进行匹配，找到了第一个匹配的 *regular expressions</em> ，那么<code>nginx</code>便停止匹配。如果没有找到与之相匹配的 <em>regular expressions</em>，<code>nginx</code>将会使用之前被记录下来的最长匹配<em>prefix string</em>的<code>location</code></p><p>3、如果最长匹配<em>prefix string</em>的<code>location</code>中有 <code>^~</code> ，那么<code>nginx</code>将不会进行<em>regular expressions</em>匹配</p><p>4、同理最长匹配<em>prefix string</em>的<code>location</code>中有 <code>=</code> ，<code>nginx</code>会对<code>URI</code>和<code>location</code>进行精确匹配，如果<code>nginx</code>找到了精确匹配，那么匹配将会终止</p><p>5、如果<code>location</code>的<em>prefix string</em>是以<code>/</code>结尾，那么请求可以进行特殊的处理（<code>proxy_pass</code>、<code>fastcgi_pass</code>，<code>uwsgi_pass</code>，<code>scgi_pass</code>、<code>memcached_pass</code>、<code>grpc_pass</code>）。</p><p>6、如果<code>步骤5</code>中<code>location</code>的<code>prefix string</code>同时存在<code>/</code>结尾和不带<code>/</code>结尾的，那么不带<code>/</code>结尾的将会永久的被以<code>301</code>状态码的方式重定向到<code>/</code>结尾的<code>location</code>中。如果对这种情况不是很满意的话，可以使用精确匹配的方式解决该问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /user/ &#123;</span><br><span class="line">    proxy_pass http://user.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /user &#123;</span><br><span class="line">    proxy_pass http://login.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记 | 持续更新~~~</title>
      <link href="/2020/04/18/docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/04/18/docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>列出了docker常见的命令，及一些个人总结的知识点</p><a id="more"></a><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>查看本地镜像</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li><p><code>-a</code>：显示所有镜像</p></li><li><p><code>-q</code>：显示镜像id</p></li></ul><blockquote><p>查找</p></blockquote><p>在dockerhub上寻找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><ul><li><code>-s</code>：列出收藏数大于指定数量</li></ul><blockquote><p>下载镜像</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p>默认是tomcat:latest</p><blockquote><p>删除镜像</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi tomcat / 镜像ID</span><br></pre></td></tr></table></figure><p>删除单个的情况，版本号不写默认是latest，删除多个可以用<code>空格</code>隔开</p><ul><li><code>-f</code>：强制删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><p>删除本机全部镜像</p><blockquote><p>生成镜像</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit tomcat 当前正在运行的容器实例 命名空间/镜像名:版本编号</span><br></pre></td></tr></table></figure><p>根据容器实例生成镜像</p><ul><li><code>-m</code>：描述信息</li><li><code>-a</code>：作者</li></ul><p>方式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile路径 -t 命名空间/镜像名 .</span><br></pre></td></tr></table></figure><p>根据Dockerfile生成镜像</p><ul><li><p><code>-f</code>：Dockerfile路径</p></li><li><p><code>-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</p></li><li><p><code>.</code>：当前路径</p></li></ul><blockquote><p>查看镜像历史</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> 镜像id</span><br></pre></td></tr></table></figure><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><blockquote><p>创建一个新的容器并运行一个命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run centos</span><br></pre></td></tr></table></figure><p>本地有镜像的话则运行本地镜像，本地没有镜像的话则会去hub上pull</p><ul><li><code>-i</code>：已交互的方式运行容器，通常都是配合<strong>-t</strong>参数使用</li><li><code>-t</code>：为容器重新分配一个伪终端</li><li><code>--name</code>：别名</li><li><code>-d</code>：后台运行容器，并返回容器id，即启动守护式容器</li><li><code>-p</code>：主机端口:docker容器端口</li><li><code>-P</code>：随机分配端口</li><li><code>-v</code>：绑定一个卷，主机路径:容器路径</li><li><code>--rm</code>：运行结束时自动销毁</li><li><code>--restart</code>：设置容器重启策略，no，默认策略，在容器退出时不重启容器；on-failure，在容器非正常退出时（退出状态非0），才会重启容器；on-failure:3，在容器非正常退出时重启容器，最多重启3次；always，在容器退出时总是重启容器；unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><p>值得说明的是，docker容器实例在后台运行，就必须要有一个前台进程，如果容器运行的不是那些一直挂起的命令，那么docker则会自动退出</p><blockquote><p>启动一个或多个已经被停止的容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start centos</span><br></pre></td></tr></table></figure><p>通常用来启动已经停止的容器</p><blockquote><p>列出当前运行的所有容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul><li><code>-a</code>：正在运行和历史上运行过得容器</li><li><code>-l</code>：上次运行的容器实例</li><li><code>-n</code>：最近n个创建的容器</li><li><code>-q</code>：只显示容器id</li></ul><blockquote><p>退出容器</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>关闭容器，无法再次进入</p><p>方式2：</p><p>Ctrl + p + q</p><p>关闭容器之后还可以再次进入</p><blockquote><p>重启容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart centos</span><br></pre></td></tr></table></figure><blockquote><p>停止容器</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop centos</span><br></pre></td></tr></table></figure><p>正常停止</p><p>方式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> centos</span><br></pre></td></tr></table></figure><p>强制停止，类似于拔电源</p><blockquote><p>删除容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm centos</span><br></pre></td></tr></table></figure><p>删除单个</p><ul><li><code>-f</code>：强制删除</li></ul><p>删除多个</p><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -aq | xargs docker rm -f</span><br></pre></td></tr></table></figure><blockquote><p>查看日志</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs centos</span><br></pre></td></tr></table></figure><ul><li><code>-t</code>：时间</li><li><code>-f</code>：跟随最新的日志</li><li><code>--tail</code>：显示最后多少条</li></ul><blockquote><p>查看容器内运行的进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top centos</span><br></pre></td></tr></table></figure><blockquote><p>查看容器内部的细节</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect centos</span><br></pre></td></tr></table></figure><blockquote><p>重新进入docker进行交互</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach centos</span><br></pre></td></tr></table></figure><p>直接进入容器启动的命令行终端，不会启动新的进程</p><p>方式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> centos</span><br></pre></td></tr></table></figure><p>不进入容器却能够和容器交互</p><p>如果使用<strong>docker exec centos -it /bin/bash</strong>的话，则效果和<strong>docker attach centos</strong>相同</p><blockquote><p>拷贝文件到宿主机</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp centos:/tmp/yum.log /root</span><br></pre></td></tr></table></figure><p>将docker中<code>/tmp/yum.log</code>文件拷贝到宿主机<code>/root</code>中</p><hr><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><blockquote><p>添加数据卷</p></blockquote><p>方式1：</p><p>使用直接命令的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径:/容器内目录 镜像名</span><br></pre></td></tr></table></figure><p>容器退出后，主机修改共享文件后，docker容器中文件也会被修改</p><blockquote><p>查看数据卷和容器是否绑定成功</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><p>在返回的json串中，查看volume属性</p><blockquote><p>设置权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><ul><li><code>ro</code>：read only（只读）</li></ul><blockquote><p>出现Permission denied错误</p></blockquote><p>增加<code>--privileged=true</code>参数</p><p>方式2：</p><p>使用Dokcerfile添加，Dockerfile是对docker中镜像的描述。在Dockerfile中增加一下代码<code>VOLUME [&quot;/data1&quot;, &quot;/data2&quot;]</code>，值得注意的是， 通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的</p><blockquote><p>拷贝文件到容器</p></blockquote><p>方式1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</p><p>方式2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br></pre></td></tr></table></figure><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www</p><p>方式3:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</p><hr><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>使用一个容器作为父容器，专门用来存放数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from 父容器id 子容器id</span><br></pre></td></tr></table></figure><p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="保留字指令"><a href="#保留字指令" class="headerlink" title="保留字指令"></a>保留字指令</h3><ul><li><code>FROM</code>：当前镜像是基于那个镜像的</li><li><code>MAINTAINER</code>：镜像作者及作者邮箱</li><li><code>RUN</code>：容器构建时所需要执行的命令</li><li><code>EXPOSE</code>：当前容器对外暴露出的端口</li><li><code>WORKDIR</code>：创建容器后，终端默认进来的工作目录</li><li><code>ARG</code>：构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</li><li><code>ENV</code>：设置环境变量，在这之后的<code>RUN</code>指令都可以使用该变量</li><li><code>ADD</code>：拷贝（<code>COPY</code>） + 解压缩</li><li><code>COPY</code>：直接拷贝</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY src dest</span><br></pre></td></tr></table></figure><ul><li><code>VOLUME</code>：容器数据卷，主机路径:容器路径</li><li><code>CMD</code>：容器启动时要运行的命令。<code>CMD</code>指令可以有多个，但只有最后一个会生效，<code>CMD</code>会被<strong>docker run</strong>之后的参数替换（命令参数会被覆盖）</li><li><code>ENTRYPOINT</code>：容器启动时要运行的命令。（命令参数会被追加组合）</li><li><code>ONBUILD</code>：父镜像在子镜像<code>build</code>时被触发</li></ul><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="自定义tomcat"><a href="#自定义tomcat" class="headerlink" title="自定义tomcat"></a>自定义tomcat</h3><h4 id="创建Dockerfile文件"><a href="#创建Dockerfile文件" class="headerlink" title="创建Dockerfile文件"></a>创建Dockerfile文件</h4><p>内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父镜像</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者信息</span></span><br><span class="line">MAINTAINER weiguangchao&lt;3409885610@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制并解压</span></span><br><span class="line">ADD jdk-8u231-linux-x64.tar.gz /usr/<span class="built_in">local</span></span><br><span class="line">ADD apache-tomcat-9.0.27.tar.gz /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span>/apache-tomcat-9.0.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_231</span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-9.0.27</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置对外暴露端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装结束后运行的命令</span></span><br><span class="line">CMD startup.sh &amp;&amp; tail -f /usr/<span class="built_in">local</span>/apache-tomcat-9.0.27/logs/catalina.out</span><br></pre></td></tr></table></figure><h4 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile2 -t weiguangchao/mytomcat:1.0 .</span><br></pre></td></tr></table></figure><h4 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-p 9999:8080 \</span><br><span class="line">-v /root/webapps:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.27/webapps \</span><br><span class="line">-v /root/logs/:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.27/logs \</span><br><span class="line">容器ID</span><br></pre></td></tr></table></figure><h4 id="创建index-html"><a href="#创建index-html" class="headerlink" title="创建index.html"></a>创建index.html</h4><p>在<code>~/webapps</code>创建<code>ROOT/index.html</code>文件</p><p>内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>ocg, I can do it!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>浏览器地址栏输入 <a href="http://192.168.153.130:9999/index.html" target="_blank" rel="noopener">http://192.168.153.130:9999/index.html</a> </p><p><img src="https://94wo.cc/usr/uploads/2020/04/791982538.png" alt=""></p><h4 id="提交到hub"><a href="#提交到hub" class="headerlink" title="提交到hub"></a>提交到hub</h4><p>这里以阿里云为例，其实阿里云镜像服务里面已经提供了相关操作的代码了</p><blockquote><p>步骤1：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=阿里云用户名 registry.cn-shenzhen.aliyuncs.com</span><br></pre></td></tr></table></figure><blockquote><p>步骤2：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]</span><br></pre></td></tr></table></figure><blockquote><p>步骤3：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]</span><br></pre></td></tr></table></figure><p> 根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 </p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud OAuth2.0认证与授权</title>
      <link href="/2020/01/29/Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
      <url>/2020/01/29/Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud OAuth2.0认证和授权</p><a id="more"></a><h2 id="OAuth2授权模式"><a href="#OAuth2授权模式" class="headerlink" title="OAuth2授权模式"></a>OAuth2授权模式</h2><h3 id="authorization-code：授权码模式"><a href="#authorization-code：授权码模式" class="headerlink" title="authorization_code：授权码模式"></a>authorization_code：授权码模式</h3><h4 id="第一步：客户端获取授权码"><a href="#第一步：客户端获取授权码" class="headerlink" title="第一步：客户端获取授权码"></a>第一步：客户端获取授权码</h4><p>客户端向认证服务器发送请求，试图获取授权码</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all&amp;state&#x3D;1</span><br></pre></td></tr></table></figure><h4 id="第二步：用户同意授权"><a href="#第二步：用户同意授权" class="headerlink" title="第二步：用户同意授权"></a>第二步：用户同意授权</h4><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%881.48.25.png" alt=""></p><h4 id="第三步：客户端通过授权码获取令牌"><a href="#第三步：客户端通过授权码获取令牌" class="headerlink" title="第三步：客户端通过授权码获取令牌"></a>第三步：客户端通过授权码获取令牌</h4><p>第三步本是一次请求，这里为了针对性才将此拆开</p><h5 id="1）设置客户端身份"><a href="#1）设置客户端身份" class="headerlink" title="1）设置客户端身份"></a>1）设置客户端身份</h5><ul><li>client_id：表示客户端ID，必选项。</li><li>client_secret：表示客户端密钥，必选项</li></ul><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8A%E5%8D%8811.59.39.png" alt=""></p><h5 id="2）获取令牌"><a href="#2）获取令牌" class="headerlink" title="2）获取令牌"></a>2）获取令牌</h5><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li></ul><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%881.57.21.png" alt=""></p><p>令牌参数说明：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>由于授权码参数类似，就只在这里说明一次</p><h3 id="password：密码模式"><a href="#password：密码模式" class="headerlink" title="password：密码模式"></a>password：密码模式</h3><h4 id="第一步：用户向客户端提供用户名和密码"><a href="#第一步：用户向客户端提供用户名和密码" class="headerlink" title="第一步：用户向客户端提供用户名和密码"></a>第一步：用户向客户端提供用户名和密码</h4><p>客户端通过用户提供的用户名和密码向认证服务器申请令牌</p><h4 id="第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌"><a href="#第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌" class="headerlink" title="第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌"></a>第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌</h4><h5 id="1）设置客户端身份-1"><a href="#1）设置客户端身份-1" class="headerlink" title="1）设置客户端身份"></a>1）设置客户端身份</h5><ul><li>client_id：表示客户端ID，必选项。</li><li>client_secret：表示客户端密钥，必选项</li></ul><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8A%E5%8D%8811.59.39.png" alt=""></p><h5 id="2）获取令牌-1"><a href="#2）获取令牌-1" class="headerlink" title="2）获取令牌"></a>2）获取令牌</h5><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%882.12.27.png" alt=""></p><h3 id="client-credentials：客户端模式"><a href="#client-credentials：客户端模式" class="headerlink" title="client_credentials：客户端模式"></a>client_credentials：客户端模式</h3><h4 id="第一步：设置客户端身份"><a href="#第一步：设置客户端身份" class="headerlink" title="第一步：设置客户端身份"></a>第一步：设置客户端身份</h4><ul><li>client_id：表示客户端ID，必选项。</li><li>client_secret：表示客户端密钥，必选项</li></ul><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8A%E5%8D%8811.59.39.png" alt=""></p><h4 id="第二步：获取令牌"><a href="#第二步：获取令牌" class="headerlink" title="第二步：获取令牌"></a>第二步：获取令牌</h4><ul><li>grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%882.18.10.png" alt=""></p><h3 id="implicit：简化模式"><a href="#implicit：简化模式" class="headerlink" title="implicit：简化模式"></a>implicit：简化模式</h3><p>简化模式为授权码模式的简化版。即，授权码模式的第一步直接通过浏览器回显令牌</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all</span><br></pre></td></tr></table></figure><p><img src="%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%882.21.47.png" alt=""></p><h2 id="Spring-Cloud-OAuth2认证和授权项目"><a href="#Spring-Cloud-OAuth2认证和授权项目" class="headerlink" title="Spring Cloud OAuth2认证和授权项目"></a>Spring Cloud OAuth2认证和授权项目</h2><p>在父工程引入Spring Boot和Spring Cloud的相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="认证服务-distributed-security-uaa"><a href="#认证服务-distributed-security-uaa" class="headerlink" title="认证服务 distributed-security-uaa"></a>认证服务 distributed-security-uaa</h3><h4 id="依赖详情-pom-xml"><a href="#依赖详情-pom-xml" class="headerlink" title="依赖详情 pom.xml"></a>依赖详情 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka 客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- WEB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud OAuth2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-application-yml"><a href="#配置文件-application-yml" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/uaa</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">distributed-security-uaa</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">c1</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="number">123</span></span><br><span class="line">      <span class="comment"># 回调URL</span></span><br><span class="line">      <span class="attr">registered-redirect-uri:</span> <span class="string">https://www.ririiy.com</span></span><br><span class="line">      <span class="comment"># 令牌有效时间</span></span><br><span class="line">      <span class="attr">access-token-validity-seconds:</span> <span class="number">7200</span>  <span class="comment"># 两小时</span></span><br><span class="line">      <span class="comment"># 令牌刷新时间</span></span><br><span class="line">      <span class="attr">refresh-token-validity-seconds:</span> <span class="number">259200</span>  <span class="comment"># 三天</span></span><br><span class="line">      <span class="attr">resource-ids:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">authorization:</span></span><br><span class="line">      <span class="comment"># 放行check_token请求，便于检查access_token即令牌是否合法</span></span><br><span class="line">      <span class="attr">check-token-access:</span> <span class="string">permitAll()</span></span><br></pre></td></tr></table></figure><h4 id="开启Spring-Security"><a href="#开启Spring-Security" class="headerlink" title="开启Spring Security"></a>开启Spring Security</h4><p>如果不开启Spring Security的话，则会有相关提示</p><p><img src="Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%884.16.12.png" alt=""></p><p>创建Spring Security配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ririiy.security.distributed.uaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UaaServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(UaaServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源服务-distributed-security-resource"><a href="#资源服务-distributed-security-resource" class="headerlink" title="资源服务 distributed-security-resource"></a>资源服务 distributed-security-resource</h3><h4 id="依赖详情-pom-xml-1"><a href="#依赖详情-pom-xml-1" class="headerlink" title="依赖详情 pom.xml"></a>依赖详情 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- eureka 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- WEB --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- Spring Cloud OAuth2 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-application-yml-1"><a href="#配置文件-application-yml-1" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/res</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">distributed-security-res</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">r1</span></span><br><span class="line">      <span class="comment"># 检查token</span></span><br><span class="line">      <span class="attr">token-info-uri:</span> <span class="string">http://localhost:5000/uaa/oauth/check_token</span></span><br><span class="line">    <span class="comment"># 客户端信息  </span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">c1</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h4><p>这里随便定义一个controller模拟资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"r1"</span>, produces = <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">r1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"r1 资源"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主启动类-1"><a href="#主启动类-1" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ririiy.security.distributed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ResourceServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中心-distributed-security-registry"><a href="#注册中心-distributed-security-registry" class="headerlink" title="注册中心 distributed-security-registry"></a>注册中心 distributed-security-registry</h3><h4 id="依赖详情-pom-xml-2"><a href="#依赖详情-pom-xml-2" class="headerlink" title="依赖详情 pom.xml"></a>依赖详情 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka 服务端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-application-yml-2"><a href="#配置文件-application-yml-2" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">distributed-security-registry</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="主启动类-2"><a href="#主启动类-2" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RegistryServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> OAuth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC初始化和请求映射分析</title>
      <link href="/2019/11/22/SpringMVC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/11/22/SpringMVC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC初始化流程和请求适配流程分析</p><a id="more"></a><h1 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h1><p><code>SpringMVC</code>的核心是<code>DispatcherServlet</code>，所以<code>SpringMVC</code>的初始化说白了也就是<code>DispatcherServlet</code>的初始化。</p><p><img src="QQ%E6%88%AA%E5%9B%BE20191122202656.png" alt=""></p><p>SpringMVC首先执行<code>DispatcherServlet</code>中static代码块中的逻辑，将<code>DispatcherServlet.properties</code>文件中的配置属性加载到名为<code>defaultStrategies</code>的<code>Properties</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">    <span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">    <span class="comment">// by application developers.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由<code>Servlet</code>的规范可知，在<code>Web</code>容器（<code>Tomcat</code>等）启动的过程中会判断<code>Servlet</code>是否需要提前实例化，而是否提前实例化由程序员外部配置的<code>loadOnStartup</code>参数决定，并且<code>DispatcherServlet</code>的<code>loadOnStartup</code>参数通常都是设为1，即，在<code>Web</code>容器启动的过程中会实例化<code>DispatcherServlet</code>。在实例化<code>DispatcherServlet</code>的过程中，<code>Web</code>容器首先会调用<code>Servlet</code>的<code>init()</code>方法，完成对Servlet的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察发现该方法最终调用了<code>initServletBean()</code>，在<code>initServletBean()</code>中<code>SpringMVC</code>会调用<code>initWebApplicationContext()</code>方法完成<code>WebApplicationContext</code>的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">"Initializing Spring "</span> + getClass().getSimpleName() + <span class="string">" '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Initializing Servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化web环境</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">            <span class="string">"shown which may lead to unsafe logging of potentially sensitive data"</span> :</span><br><span class="line">        <span class="string">"masked to prevent unsafe logging of potentially sensitive data"</span>;</span><br><span class="line">        logger.debug(<span class="string">"enableLoggingRequestDetails='"</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                     <span class="string">"': request parameters and headers will be "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Completed initialization in "</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法最终会调用<code>configureAndRefreshWebApplicationContext(cwac)</code>，完成相关参数的设置之后，便调用了<code>refresh()</code>，完成对Spring容器的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                      ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(getServletContext());</span><br><span class="line">    wac.setServletConfig(getServletConfig());</span><br><span class="line">    wac.setNamespace(getNamespace());</span><br><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line">    <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">    <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postProcessWebApplicationContext(wac);</span><br><span class="line">    applyInitializers(wac);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SpringMVC会自动调用refresh方法</span></span><br><span class="line">    wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释了为什么SpringMVC为什么不用显式的调用<code>refresh()</code></p><p>值得注意的是<code>ContextRefreshListener</code>，该监听器为<code>FrameworkServlet</code>内部的监听器，主要是用来监听<code>Spring</code>容器<code>ContextRefreshedEvent</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextRefreshListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        FrameworkServlet.<span class="keyword">this</span>.onApplicationEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>refresh()</code>的最后一步<code>Spring</code>会发布<code>ContextRefreshedEvent</code>事件，而该事件会被<code>FrameworkServlet</code>内部的<code>ContextRefreshListener</code>监听到，并且会回调到<code>DispatcherServlet</code>中的<code>onRefresh</code>方法，继而调用了<code>DispatcherServlet</code>中的<code>initStrategies()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MultipartResolver</span></span><br><span class="line">    <span class="comment">// 解释了为什么一定要把bean的名字配置为multipartResolver</span></span><br><span class="line">    <span class="comment">// SpringMVC内部通过getBean方法调用的名字为multipartResolver,已经写死</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    <span class="comment">// 国际化</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    <span class="comment">// 前端主题样式</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 初始化HandlerMapping</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 视图转换器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    <span class="comment">// 重定向数据管理器</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>initMultipartResolver(context)</code>方法也就解释了为什么文件上传解析器的名字一定要为<code>multipartResolver</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Detected "</span> + <span class="keyword">this</span>.multipartResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.multipartResolver.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// Default is no multipart resolver.</span></span><br><span class="line">        <span class="keyword">this</span>.multipartResolver = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"No MultipartResolver '"</span> + MULTIPART_RESOLVER_BEAN_NAME + <span class="string">"' declared"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>SpringMVC</code>已经将其写死了</p><p><code>SpringMVC</code>会从<code>defaultStrategies</code>中获取默认的<code>HandlerMapping</code>和<code>HandlerAdapter</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line"><span class="attr">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span></span><br></pre></td></tr></table></figure><p>至此<code>Web</code>环境初始化完成</p><hr><h1 id="请求映射流程"><a href="#请求映射流程" class="headerlink" title="请求映射流程"></a>请求映射流程</h1><p>从浏览器发出请求，经过<code>HTTPServlet</code>和<code>FrameworkServlet</code>最终来到了<code>DispatcherServlet</code>的<code>doDispatch</code>方法进行处理</p><p><img src="QQ%E6%88%AA%E5%9B%BE20191122213023.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否有Multpart</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 推断当前请求的handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// ------------------------------注意------------------------------</span></span><br><span class="line">            <span class="comment">// 手动观察</span></span><br><span class="line">            <span class="comment">// 如果handler是一个bean，则getHandler返回的是一个对象</span></span><br><span class="line">            <span class="comment">// 如果handler是一个方法，则getHandler放回的是一个方法</span></span><br><span class="line">            <span class="comment">// Spring将handler交给对应的处理器去处理</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="comment">// Spring确定了如何调用handler的方法</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拦截器的前置处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 调用handler进行处理</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器后置处理方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringMVC</code>会遍历所有的<code>handlerMappings</code>找到能够处理该请求的handler，而<code>handlerMappings</code>的默认值为<code>DispatcherServlet</code>初始化时static代码块中从配置问价加载的<code>RequestMappingHandlerMapping</code>和<code>BeanNameUrlHandlerMapping</code></p><p>注意，如果是通过<code>@Controller</code>注解配置的<code>Handler</code>，则<code>getHandler()</code>方法返回的是一个方法；如果是通过实现接口（<code>Controller</code>，<code>HttpRequestHandler</code>）的方法配置的<code>Handler</code>，那么<code>getHandler()</code>返回的是一个对象</p><p>SpringMVC会在handler调用的前后分别执行拦截器的<code>applyPreHandle()</code>和<code>applyPostHandle()</code>方法，完成对请求的拦截</p><p>至此请求过程调用结束…</p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Spring中的事件"><a href="#Spring中的事件" class="headerlink" title="Spring中的事件"></a>Spring中的事件</h2><p>Spring中的事件是通过<code>applicationEventMulticaster</code>即广播器向所有的监听器发送的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层就是通过广播器拿到所有的监听器，循环调用监听的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC成为Handler的三种方式"><a href="#SpringMVC成为Handler的三种方式" class="headerlink" title="SpringMVC成为Handler的三种方式"></a>SpringMVC成为Handler的三种方式</h2><blockquote><p>@Controller</p></blockquote><p>老生常谈了，通过<code>@RequestMapping</code>完成映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IndexController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"com.hrious.weblearn.controller.IndexController.IndexController"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"com.hrious.weblearn.controller.IndexController.index"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"@controller"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/map.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"com.hrious.weblearn.controller.IndexController.map"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"123"</span>, <span class="string">"xxx"</span>);</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.springframework.web.servlet.mvc.Controller</p></blockquote><p>实现<code>Controller</code>接口，重写<code>handleRequest</code>方法。其中<code>bean</code>名称为请求映射地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"/index2.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController2</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">response.getWriter().write(<span class="string">"controller.."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.springframework.web.HttpRequestHandler</p></blockquote><p>实现<code>HttpRequestHandler</code>接口，重写<code>handleRequest</code>方法，同样bean名称为请求映射地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"/index3.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController3</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.getWriter().write(<span class="string">"HttpRequestHandler.."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>映射请求到对应的Handler</p><blockquote><p>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</p></blockquote><p>在实现（<code>Controller</code>，<code>HttpRequestHandler</code>）接口的Handler集合中寻找合适的Handler完成请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</p></blockquote><p>在添加了<code>@Controller</code>注解的Handler集合中寻找合适的Handler完成请求的处理</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>调用Handler的相关方法，完成对请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</p></blockquote><p>调用带有<code>@RequestMapping</code>注解的handler，完成请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</p></blockquote><p>调用实现了<code>Controller</code>的handler，完成请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter</p></blockquote><p>调用实现了<code>HttpRequestHandler</code>的handler，完成请求的处理</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
