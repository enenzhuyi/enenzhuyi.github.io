<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ学习与总结</title>
      <link href="/2020/05/02/RabbitMQ%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/"/>
      <url>/2020/05/02/RabbitMQ%E5%AD%A6%E4%B9%A0%E4%B8%8E%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>记录RabbitMQ学习过程中遇到的难题或者是坑，以及相关知识点的总结</p><a id="more"></a>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RabbitMQ </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux面试题总结</title>
      <link href="/2020/04/30/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/30/Linux%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了自己刷题过程中和网上常见的面试题</p><a id="more"></a><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-c: 建立压缩档案</span><br><span class="line">-x：解压</span><br><span class="line">-t：查看内容</span><br><span class="line">-r：向压缩归档文件末尾追加文件</span><br><span class="line">-u：更新原压缩包中的文件</span><br></pre></td></tr></table></figure><p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-z：有gzip属性的</span><br><span class="line">-j：有bz2属性的</span><br><span class="line">-Z：有compress属性的</span><br><span class="line">-v：显示所有过程</span><br><span class="line">-O：将文件解开到标准输出</span><br></pre></td></tr></table></figure><p>下面的参数-f是必须的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试 </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Aop概念知识点总结</title>
      <link href="/2020/04/30/Spring-Aop%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/30/Spring-Aop%E6%A6%82%E5%BF%B5%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了网上关于Spring AOP概念与知识点，外加自己的理解</p><a id="more"></a><h2 id="AOP术语"><a href="#AOP术语" class="headerlink" title="AOP术语"></a>AOP术语</h2><ul><li>通知<ul><li>定义：切面需要完成的工作。</li><li>定义了切面是什么，何时使用。</li><li>Spring中的五种通知类型：</li></ul></li></ul><blockquote><ol><li>Before——在方法调用之前调用通知</li><li>After——在方法完成之后调用通知，无论方法执行成功与否</li><li>After-returning——在方法执行成功之后调用通知</li><li>After-throwing——在方法抛出异常后进行通知</li><li>Around——通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为</li></ol></blockquote><ul><li>连接点<ul><li>定义：应用程序执行过程中能够插入一个切面的点</li><li>连接点可以是在调用方法时、抛出异常时、甚至是修改字段时</li><li>切面代码通过连接点插入到正常业务代码中</li><li>在程序运行过程中能够应用到通知</li></ul></li><li>切点<ul><li>定义：负责匹配通知所要织入的一个或多个连接点</li><li>通常通过使用明确的类或者是方法来指定</li><li>作用：定义通知应用的位置</li></ul></li><li>切面<ul><li>定义：是通知和切点的集合，通知和切点共同定义了切面的全部功能——它是什么，在何处完成什么功能。</li></ul></li><li>引入<ul><li>定义：向现有的类中增加方法或属性</li></ul></li><li>织入<ul><li>定义：将切面应用到目标对象来创建代理对象的过程</li><li>切面通过指定的连接点织入到目标对象，在目标对象生命周期中可以有多个连接点的织入</li></ul></li></ul><blockquote><ol><li>编译期——切面在目标类编译时期被织入，这种方式需要特殊编译器。AspectJ的织入编译器就是以这种方式织入切面。</li><li>类加载期——切面在类加载到</li><li>JVM ，这种方式需要特殊的类加载器，他可以在目标类被引入应用之前增强该目标类的字节码。AspectJ5 的 LTW 就支持这种织入方式</li><li>运行期——切面在应用运行期间的某个时刻被织入。一般情况下，在织入切面时候，AOP 容器会为目标对象动态的创建代理对象。Spring AOP 就是以这种方式织入切面。</li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring AOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring面试题总结</title>
      <link href="/2020/04/29/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/29/Spring%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了自己刷题过程中和网上常见的面试题</p><a id="more"></a><h2 id="Spring中Bean作用域？"><a href="#Spring中Bean作用域？" class="headerlink" title="Spring中Bean作用域？"></a>Spring中Bean作用域？</h2><ul><li><p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。</p></li><li><p>prototype : 每次请求都会创建一个新的 bean 实例。</p></li><li><p>request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。</p></li><li><p>session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</p></li><li><p>global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</p></li></ul><h2 id="Spring事务传播行为"><a href="#Spring事务传播行为" class="headerlink" title="Spring事务传播行为"></a>Spring事务传播行为</h2><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td>PROPAGATION_REQUIRED</td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。Spring中默认为PROPAGATION_REQUIRED。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_SUPPORTS</td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table><h2 id="Spring事务隔离级别"><a href="#Spring事务隔离级别" class="headerlink" title="Spring事务隔离级别"></a>Spring事务隔离级别</h2><table><thead><tr><th>隔离级别类型</th><th>说明</th></tr></thead><tbody><tr><td>ISOLATION_DEFAULT</td><td>使用后端数据库默认的隔离级别。Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</td></tr><tr><td>ISOLATION_READ_UNCOMMITTED</td><td>允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。</td></tr><tr><td>ISOLATION_READ_COMMITTED</td><td>允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。</td></tr><tr><td>ISOLATION_REPEATABLE_READ</td><td>对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。</td></tr><tr><td>ISOLATION_SERIALIZABLE</td><td>完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。</td></tr></tbody></table><p><strong>脏读：</strong>一个事务读取了被另一个事务改写但尚未提交的数据时。如果这些改变在稍后被回滚了，那么第一个事务读取的数据就会是无效的。</p><p><strong>不可重复读：</strong>一个事务执行相同的查询两次或两次以上，但每次查询结果都不相同时。这通常是由于另一个并发事务在两次查询之间更新了数据。</p><p><strong>幻读：</strong>当一个事务（1）读取几行记录后，另一个并发事务（2）插入了一些记录并提交，事务（1）再次查询，可以看到事务（2）添加的额外记录。</p><h2 id="什么是-Spring-框架"><a href="#什么是-Spring-框架" class="headerlink" title="什么是 Spring 框架?"></a>什么是 Spring 框架?</h2><p>​    我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-04-29%E4%B8%8A%E5%8D%889.41.07.png" alt=""></p><h2 id="列举一些重要的Spring模块？"><a href="#列举一些重要的Spring模块？" class="headerlink" title="列举一些重要的Spring模块？"></a>列举一些重要的Spring模块？</h2><ul><li><p><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IOC 依赖注入功能。</p></li><li><p>*<em>Spring  Aspects *</em> ：该模块为与AspectJ的集成提供支持。</p></li><li><p><strong>Spring AOP</strong> ：提供了面向方面的编程实现。</p></li><li><p><strong>Spring JDBC</strong> : Java数据库连接。</p></li><li><p><strong>Spring JMS</strong> ：Java消息服务。</p></li><li><p><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</p></li><li><p><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</p></li><li><p><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</p></li></ul><h2 id="谈谈自己对于-Spring-IoC-和-AOP-的理解"><a href="#谈谈自己对于-Spring-IoC-和-AOP-的理解" class="headerlink" title="谈谈自己对于 Spring IoC 和 AOP 的理解"></a>谈谈自己对于 Spring IoC 和 AOP 的理解</h2><p><strong>IoC</strong></p><p>​    IoC（Inverse of Control:控制反转）是一种<strong>设计思想</strong>，就是 <strong>将原本在程序中手动创建对象的控制权，交由Spring容器来管理。</strong>  IoC 在其他语言中也有应用，并非 Spirng 特有。 <strong>IoC 容器是 Spring 用来实现 IoC 的载体，  IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</strong></p><p>​    将对象之间的相互依赖关系交给 IOC 容器来管理，并由 IOC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。  <strong>IOC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</strong> 在实际项目中一个 Service 类可能有几百甚至上千个类作为它的底层，假如我们需要实例化这个 Service，你可能要每次都要搞清这个 Service 所有底层类的构造函数，这可能会把人逼疯。如果利用 IOC 的话，你只需要配置好，然后在需要的地方引用就行了，这大大增加了项目的可维护性且降低了开发难度。</p><p><strong>AOP</strong></p><p>​    AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，<strong>却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来</strong>，便于<strong>减少系统的重复代码</strong>，<strong>降低模块间的耦合度</strong>，并<strong>有利于未来的可拓展性和可维护性</strong>。</p><p>​    <strong>Spring AOP就是基于动态代理的</strong>，如果要代理的对象，实现了某个接口，那么Spring AOP会使用<strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用<strong>Cglib</strong> ，这时候Spring AOP会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p><p>​    此外，SpringAOP支持AspectJ表达式。</p><h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p>​    <strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>​    Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单。</p><p>​    如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p><h2 id="Spring-中的单例-bean-的线程安全问题了解吗？"><a href="#Spring-中的单例-bean-的线程安全问题了解吗？" class="headerlink" title="Spring 中的单例 bean 的线程安全问题了解吗？"></a>Spring 中的单例 bean 的线程安全问题了解吗？</h2><p>​    大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p><p>​    常见的有两种解决办法：</p><ol><li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li><li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li></ol><h2 id="Spring-中的-bean-生命周期？"><a href="#Spring-中的-bean-生命周期？" class="headerlink" title="Spring 中的 bean 生命周期？"></a>Spring 中的 bean 生命周期？</h2><ul><li><p>Bean 容器找到配置文件中 Spring Bean 的定义。</p></li><li><p>Bean 容器利用 Java Reflection API 创建一个Bean的实例。</p></li><li><p>如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</p></li><li><p>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入Bean的名字。</p></li><li><p>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</p></li><li><p>如果Bean实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoade</code> r对象的实例。</p></li><li><p>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</p></li><li><p>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</p></li><li><p>如果Bean实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</p></li><li><p>如果 Bean 在配置文件中的定义包含  init-method 属性，执行指定的方法。</p></li><li><p>如果有和加载这个 Bean的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</p></li><li><p>当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</p></li><li><p>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p></li></ul><p><strong>图示：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-04-29%E4%B8%8A%E5%8D%8810.06.32.png" alt=""></p><h2 id="说说自己对于-Spring-MVC-了解"><a href="#说说自己对于-Spring-MVC-了解" class="headerlink" title="说说自己对于 Spring MVC 了解?"></a>说说自己对于 Spring MVC 了解?</h2><p>​    MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p><p><strong>原理图：</strong></p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-04-29%E4%B8%8A%E5%8D%8810.17.47.png" alt=""></p><ol><li><p>客户端（浏览器）发送请求，直接请求到 <code>DispatcherServlet</code>。</p></li><li><p><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的 <code>Handler</code>。</p></li><li><p>解析到对应的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器）后，开始由 <code>HandlerAdapter</code> 适配器处理。</p></li><li><p><code>HandlerAdapter</code> 会根据 <code>Handler</code>来调用真正的处理器开处理请求，并处理相应的业务逻辑。</p></li><li><p>处理器处理完业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</p></li><li><p><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</p></li><li><p><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</p></li><li><p>把 <code>View</code> 返回给请求者（浏览器）</p></li></ol><h2 id="Spring-框架中用到了哪些设计模式？"><a href="#Spring-框架中用到了哪些设计模式？" class="headerlink" title="Spring 框架中用到了哪些设计模式？"></a>Spring 框架中用到了哪些设计模式？</h2><ul><li><p><strong>工厂设计模式</strong> : Spring使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</p></li><li><p><strong>代理设计模式</strong> : Spring AOP 功能的实现。</p></li><li><p><strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</p></li><li><p><strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</p></li><li><p><strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</p></li><li><p><strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</p></li><li><p><strong>适配器模式</strong> :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</p></li><li><p>……</p></li></ul><h2 id="Component-和-Bean-的区别是什么？"><a href="#Component-和-Bean-的区别是什么？" class="headerlink" title="@Component 和 @Bean 的区别是什么？"></a>@Component 和 @Bean 的区别是什么？</h2><ol><li>作用对象不同: <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li><li><code>@Bean</code> 注解比 <code>Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ol><p><code>@Bean</code>注解使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferService <span class="title">transferService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TransferServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码相当于下面的 xml 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transferService"</span> <span class="attr">class</span>=<span class="string">"com.acme.TransferServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OneService <span class="title">getService</span><span class="params">(status)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> (status)  &#123;</span><br><span class="line">        when <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl1();</span><br><span class="line">        when <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl2();</span><br><span class="line">        when <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> serviceImpl3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="将一个类声明为Spring的-bean-的注解有哪些"><a href="#将一个类声明为Spring的-bean-的注解有哪些" class="headerlink" title="将一个类声明为Spring的 bean 的注解有哪些?"></a>将一个类声明为Spring的 bean 的注解有哪些?</h2><p>我们一般使用 <code>@Autowired</code> 注解自动装配 bean，要想把类标识成可用于 <code>@Autowired</code> 注解自动装配的 bean 的类,采用以下注解可实现：</p><ul><li><code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个Bean不知道属于拿个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li></ul><h2 id="Spring-管理事务的方式有几种？"><a href="#Spring-管理事务的方式有几种？" class="headerlink" title="Spring 管理事务的方式有几种？"></a>Spring 管理事务的方式有几种？</h2><ol><li>编程式事务，在代码中硬编码。(不推荐使用)</li><li>声明式事务，在配置文件中配置（推荐使用）</li></ol><p><strong>声明式事务又分为两种：</strong></p><ol><li>基于XML的声明式事务</li><li>基于注解的声明式事务</li></ol>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis面试题总结</title>
      <link href="/2020/04/29/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/29/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了自己刷题过程中和网上常见的面试题</p><a id="more"></a><h2 id="实体对象与数据库字段名不一致，怎么办？"><a href="#实体对象与数据库字段名不一致，怎么办？" class="headerlink" title="实体对象与数据库字段名不一致，怎么办？"></a>实体对象与数据库字段名不一致，怎么办？</h2><ol><li>sql语句中使用别名</li><li>MyBatis开启驼峰命名规则</li><li>在映射文件中自定义ResultMap来映射字段名和实体类属性名的一一对应的关系。</li></ol><h2 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h2><p>#{} 是预编译处理，${}是字符串替换。</p><p>Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p><p>Mybatis在处理${}时，就是把${}替换成变量的值。</p><p>使用#{}可以有效的防止SQL注入，提高系统安全性。</p><h2 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h2><p><strong>方法一：</strong></p><p><strong>1. xml映射器：</strong></p><p>在定义xml映射器时设置属性useGeneratedKeys值为true，并分别指定属性keyProperty和keyColumn为对应的数据库记录主键字段与Java对象的主键属性。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"cn.mybatis.mydemo.mapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 插入数据：返回记录主键id值 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertPerson"</span> <span class="attr">parameterType</span>=<span class="string">"cn.mybatis.mydemo.domain.Person"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">keyColumn</span>=<span class="string">"id"</span> &gt;</span></span><br><span class="line">        insert into t_person(name,sex,age,create_time,update_time) </span><br><span class="line">        values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,now(),now())</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2. 接口映射器：</strong></p><p>在接口映射器中通过注解@Options分别设置参数useGeneratedKeys，keyProperty，keyColumn值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回主键字段id值</span></span><br><span class="line"><span class="meta">@Options</span>(useGeneratedKeys = <span class="keyword">true</span>, keyProperty = <span class="string">"id"</span>, keyColumn = <span class="string">"id"</span>)</span><br><span class="line"><span class="meta">@Insert</span>(<span class="string">"insert into t_person(name,sex,age,create_time,update_time) values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,now(),now())"</span>)</span><br><span class="line"><span class="function">Integer <span class="title">insertPerson</span><span class="params">(Person person)</span></span>;</span><br></pre></td></tr></table></figure><p>需要注意的是，在MyBatis中添加操作返回的是记录数并非记录主键id。因此，如果需要获取新添加记录的主键值，需要在执行添加操作之后，直接读取Java对象的主键属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer rows = sqlSession.getMapper(PersonMapper<span class="class">.<span class="keyword">class</span>).<span class="title">insertPerson</span>(<span class="title">person</span>)</span>;</span><br><span class="line">System.out.println(<span class="string">"rows = "</span> + rows); <span class="comment">// 添加操作返回记录数</span></span><br><span class="line">System.out.println(<span class="string">"id = "</span> + person.getId()); <span class="comment">// 执行添加操作之后通过Java对象获取主键属性值</span></span><br></pre></td></tr></table></figure><p><strong>方法二：</strong></p><p><strong>1. mysql</strong></p><p>在插入数据之后，mybatis再次查询mysql数据库，获得了主键id，然后填充到person对象的id属性的。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertPerson"</span> <span class="attr">parameterType</span>=<span class="string">"cn.mybatis.mydemo.domain.Person"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">resultType</span>=<span class="string">"INTEGER"</span> <span class="attr">order</span>=<span class="string">"AFTER"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    SELECT LAST_INSERT_ID()</span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">  insert into t_person(name,sex,age,create_time,update_time) </span><br><span class="line">  values(#&#123;name&#125;,#&#123;sex&#125;,#&#123;age&#125;,now(),now())</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li>SELECT LAST_INSERT_ID()： 获取刚刚插入的主键；</li><li>keyProperty：表示将返回的值设置到某一列，此处为id；</li><li>order：表明此代码相对于insert语句的执行顺序，BEFORE(适用于Oralce等取序列的数据库)/ARTER(适用于MySQL等支持自增长的数据库)；</li><li>resultType：返回的类型；</li></ol><p><strong>2. oracle</strong></p><p>先查询序列得到主键，将主键设置到person对象的id属性，最后将person对象插入数据库。</p><p>在执行insert之前执行select 序列.nextval() from dual取出序列最大值，将值设置到person对象的id属性</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertUser"</span> <span class="attr">parameterType</span>=<span class="string">"cn.itcast.mybatis.po.User"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    select 序列.nextval() from dual</span><br><span class="line">  <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  INSERT INTO USER(id,username,birthday,sex,address) VALUES( 序列.nextval(),#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数?"></a>在mapper中如何传递多个参数?</h2><p><strong>第一种：使用占位符</strong></p><p>与Spring整合的情况</p><p><strong>方式一：</strong></p><p>对应的xml,#{0}代表接收的是dao层中的第一个参数，#{1}代表dao层中第二参数，更多参数一致往后加即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectUser"</span><span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>&gt;</span>  </span><br><span class="line">    select *  fromuser_user_t   whereuser_name = #&#123;0&#125; anduser_area=#&#123;1&#125;  </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式二：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">usermapper</span> </span>&#123; </span><br><span class="line">  <span class="function">user <span class="title">selectuser</span><span class="params">(@param(“username”)</span> string username,                  @<span class="title">param</span><span class="params">(“hashedpassword”)</span> string hashedpassword)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">”selectuser”</span> <span class="attr">resulttype</span>=<span class="string">”user”</span>&gt;</span> </span><br><span class="line">  select id, username, hashedpassword </span><br><span class="line">  from some_table </span><br><span class="line">  where username = #&#123;username&#125; </span><br><span class="line">  and hashedpassword = #&#123;hashedpassword&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第二种：使用Map集合</strong></p><p>单独使用MyBatis的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//映射文件的命名空间.SQL片段的ID，就可以调用对应的映射文件中的SQL</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 由于我们的参数超过了两个，而方法中只有一个Object参数收集</span></span><br><span class="line"><span class="comment">     * 因此我们使用Map集合来装载我们的参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"start"</span>, start);</span><br><span class="line">    map.put(<span class="string">"end"</span>, end);</span><br><span class="line">    <span class="keyword">return</span> sqlSession.selectList(<span class="string">"StudentID.pagination"</span>, map);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    MybatisUtil.closeSqlSession();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--分页查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"pagination"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultMap</span>=<span class="string">"studentMap"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  /*根据key自动找到对应Map集合的value*/</span><br><span class="line">  select * from students limit #&#123;start&#125;,#&#123;end&#125;;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"><a href="#Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？" class="headerlink" title="Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？"></a>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</h2><ul><li>Mybatis动态sql可以让我们在Xml映射文件内，<strong>以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能</strong>。</li><li>Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。</li><li>其执行原理为，使用OGNL从sql参数对象中计算表达式的值，<strong>根据表达式的值动态拼接sql，以此来完成动态sql的功能</strong>。</li></ul><h2 id="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"><a href="#Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？" class="headerlink" title="Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？"></a>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</h2><p><strong>如果配置了namespace那么当然是可以重复的，因为我们的Statement实际上就是namespace+id</strong></p><p>如果没有配置namespace的话，那么相同的id就会导致覆盖了。</p><h2 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h2><ul><li>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</li><li>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</li></ul><h2 id="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"><a href="#通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？"></a>通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？</h2><ul><li>Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。</li><li>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement。</li></ul><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">com.mybatis3.mappers.StudentDao.findStudentById，</span><br><span class="line"></span><br><span class="line">可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id &#x3D; findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。</span><br></pre></td></tr></table></figure><p>Dao接口里的方法，<strong>是不能重载的，因为是全限名+方法名的保存和寻找策略</strong>。</p><p><strong>Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</strong></p><h2 id="接口绑定有几种实现方式-分别是怎么实现的"><a href="#接口绑定有几种实现方式-分别是怎么实现的" class="headerlink" title="接口绑定有几种实现方式,分别是怎么实现的?"></a>接口绑定有几种实现方式,分别是怎么实现的?</h2><ol><li>通过注解绑定，就是在接口的方法上面加上@Select@Update等注解里面包含Sql语句来绑定。</li><li>另外一种就是通过xml里面写SQL来绑定，在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</li></ol><h2 id="Mybatis是如何进行分页的？分页插件的原理是什么？"><a href="#Mybatis是如何进行分页的？分页插件的原理是什么？" class="headerlink" title="Mybatis是如何进行分页的？分页插件的原理是什么？"></a>Mybatis是如何进行分页的？分页插件的原理是什么？</h2><p>​    Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>​    <strong>分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</strong></p><p>举例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> student，拦截<span class="keyword">sql</span>后重写为：<span class="keyword">select</span> t.* <span class="keyword">from</span> （<span class="keyword">select</span> * <span class="keyword">from</span> student）t <span class="keyword">limit</span> <span class="number">0</span>，<span class="number">10</span></span><br></pre></td></tr></table></figure><h2 id="简述Mybatis的插件运行原理，以及如何编写一个插件"><a href="#简述Mybatis的插件运行原理，以及如何编写一个插件" class="headerlink" title="简述Mybatis的插件运行原理，以及如何编写一个插件"></a>简述Mybatis的插件运行原理，以及如何编写一个插件</h2><p>​    Mybatis仅可以<strong>编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能</strong>，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>​    实现Mybatis的Interceptor接口并复写intercept()方法，<strong>然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</strong></p><h2 id="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？</h2><p>​    Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，<strong>可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</strong></p><p>​    它的原理是，<strong>使用CGLIB创建目标对象的代理对象</strong>，当调用目标方法时，<strong>进入拦截器方法</strong>，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>​    当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h2 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h2><p>Mybatis有三种基本的Executor执行器，<strong>SimpleExecutor、ReuseExecutor、BatchExecutor</strong>。</p><ul><li>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，<strong>用完立刻关闭Statement对象</strong>。</li><li>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，<strong>就是重复使用Statement对象</strong>。</li><li>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），<strong>它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同</strong>。</li></ul><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h2 id="MyBatis与Hibernate有哪些不同？"><a href="#MyBatis与Hibernate有哪些不同？" class="headerlink" title="MyBatis与Hibernate有哪些不同？"></a>MyBatis与Hibernate有哪些不同？</h2><ul><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句，不过mybatis可以通过XML或注解方式灵活配置要运行的sql语句，并将java对象和sql语句映射生成最终执行的sql，最后将sql执行的结果再映射生成java对象。</li><li>Mybatis学习门槛低，简单易学，程序员直接编写原生态sql，可严格控制sql执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发，例如互联网软件、企业运营类软件等，因为这类软件需求变化频繁，一但需求变化要求成果输出迅速。但是灵活的前提是mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象/关系映射能力强，数据库无关性好，对于关系模型要求高的软件（例如需求固定的定制化软件）如果用hibernate开发可以节省很多代码，提高效率。但是Hibernate的缺点是学习门槛高，要精通门槛更高，而且怎么设计O/R映射，在性能和对象模型之间如何权衡，以及怎样用好Hibernate需要具有很强的经验和能力才行。</li></ul><h2 id="Mybatis一级缓存、二级缓存"><a href="#Mybatis一级缓存、二级缓存" class="headerlink" title="Mybatis一级缓存、二级缓存"></a>Mybatis一级缓存、二级缓存</h2><p>Mybatis查询缓存包括，一级缓存、二级缓存。</p><p><strong>一级缓存：</strong></p><p>​    <strong>SqlSession</strong>级别的缓存。在第一次查询时，将查询结果缓存到<strong>SqlSession</strong>对象中。在第二次查询时，若是同一个<strong>SqlSession</strong>对象，则从缓存中获取数据。</p><p>​    只要执行<strong>SqlSession</strong>的commit方法，那么就会直接将SqlSession缓存对象全部清空掉。</p><p><strong>二级缓存：</strong></p><p>​    <strong>namespace</strong>级别的缓存，范围是同一个<strong>namespace</strong>下的所有<strong>xxxMapper</strong>对象。</p><p>​    MyBatis默认开启二级缓存，MyBatis提供Cache接口</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试 </tag>
            
            <tag> MyBatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础面试题总结</title>
      <link href="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>总结了自己刷题过程中和网上常见的面试题</p><a id="more"></a><h2 id="i-和-i"><a href="#i-和-i" class="headerlink" title="i++和++i"></a>i++和++i</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i+ ++i * i++;</span><br><span class="line">    System.out.println(i);   </span><br><span class="line">    System.out.println(j);</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p>明确局部变量表和操作数栈两个概念</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>在局部变量表里将<code>i</code>的值赋为1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i++;</span><br></pre></td></tr></table></figure><p>将<code>i</code>的值（1）压入操作数栈，<code>i</code>自增1，变为2。</p><p>弹出栈顶元素，将1赋值给<code>i</code>，<code>i</code>变为1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = i++;</span><br></pre></td></tr></table></figure><p>将<code>i</code>的值（1）压入操作数栈，<code>i</code>自增1，变为2。</p><p>弹出栈顶元素，将1赋值给<code>j</code>，<code>j</code>变为1.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = i+ ++i * i++;</span><br></pre></td></tr></table></figure><p>根据运算优先级判断执行顺序</p><p>将<code>i</code>的值（2）压入操作数栈</p><p><code>i</code>值自增1，变为3，将<code>i</code>的值（3）压入操作数栈</p><p>将<code>i</code>的值（3）压入操作数栈，<code>i</code>自增1，变为4</p><p>操作数栈弹出两个元素（3，3），进行乘法运算，结果为9，并压入操作数栈</p><p>操作数栈弹出两个元素（9，2），进行加法运算，结果为11，并压入操作数栈</p><p>操作数栈弹出一个元素（11），赋值给<code>k</code></p><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>Father类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        System.out.print(<span class="string">"(1)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.print(<span class="string">"(2)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.print(<span class="string">"(2-1)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"(3)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(4)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(5)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Son类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        System.out.print(<span class="string">"(6)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">"(7)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"(8)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(9)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(10)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5)(1)(10)(6)(9)(3)(2-1)(9)(8)(7)</span><br><span class="line">(9)(3)(2-1)(9)(8)(7)</span><br></pre></td></tr></table></figure><p>Java初始化过程，包括类初始化和实例初始化两部分</p><p><strong>类初始化过程</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.main()所在类</span><br><span class="line"></span><br><span class="line">2.子类在初始化前需要先初始化父类</span><br><span class="line"></span><br><span class="line">3.执行&lt;clinit&gt;方法</span><br><span class="line">  静态成员变量赋值和执行静态代码块</span><br><span class="line">  按照自上而下的顺序对静态成员变量赋值和执行静态代码块</span><br><span class="line">  只执行一次</span><br></pre></td></tr></table></figure><p><strong>实例初始化</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.执行&lt;init&gt;方法</span><br><span class="line">  非静态变量赋值、执行非静态代码块和构造方法</span><br><span class="line">  按照自上而下的顺序对非静态变量赋值、执行非静态代码块，最后执行构造方法</span><br><span class="line">  子类在执行&lt;init&gt;之前会执行父类的&lt;init&gt;，父类构造方法由子类super()所决定，默认为无参构造</span><br><span class="line">  每次创建都会执行</span><br><span class="line"></span><br><span class="line">2.注意字类的重写方法（多态性）</span><br></pre></td></tr></table></figure><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://cdn.jsdelivr.net/gh/enenzhuyi/assets@master/img/3807435_1530271039524_20577AE82E2EC5D6D44DD2CA01C99BBA.png" alt=""></p><p>异常分为运行时异常，非运行时异常和error，其中error是系统异常，只能重启系统解决。非运行时异常需要我们自己补获，而运行异常是程序运行时由虚拟机帮助我们补获。运行时异常包括数组的溢出，内存的溢出空指针，分母为0等！</p><h2 id="强制性异常与非强制性异常"><a href="#强制性异常与非强制性异常" class="headerlink" title="强制性异常与非强制性异常"></a>强制性异常与非强制性异常</h2><p>java中的异常分为两大类，强制性异常(CheckedException)和非强制性异常(UncheckedException)。而java中除了RuntimeException外，都是强制性异常。</p><ul><li>强制性异常：所谓强制性异常就是在编写程序的过程中必需在抛出异常的部分try catch 或者向上throws异常。 </li><li>非强制性异常：所谓非强制性异常就和上面相反了。不过你当然也可以try catch或者thows，只不过这不是强制性的。 </li></ul><h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型必须完全与被重写方法的返回类型相同；</li><li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法不能被重写，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li><li>构造方法不能被重写。</li><li>如果不能继承这个类，则不能重写这个类的某个方法。</li></ul><h2 id="方法参数传递，传值or传引用"><a href="#方法参数传递，传值or传引用" class="headerlink" title="方法参数传递，传值or传引用"></a>方法参数传递，传值or传引用</h2><p>调用方法的时候，本质上都是将值COPY一份传递给被调方法。不过，对于基本类型来说，传递的值是其原有值的副本，修改形参不会对原有的值造成影响。对于引用类型来说，传递的值为对象的真实地址，修改形参会对原有的值造成影响。此外，需要注意String、Integer（-128~127）等不可变对象。</p><h2 id="变量类型和作用域"><a href="#变量类型和作用域" class="headerlink" title="变量类型和作用域"></a>变量类型和作用域</h2><p>变量类型主要包括局部变量和成员变量。</p><p>局部变量保存在方法栈桢中，只能用<code>final</code>关键字进行修饰，作用域为当前<code>{}</code>内。局部变量没有<strong>初始值</strong>，需要进行初始化。</p><p>成员变量包括类变量和实例变量，能够被jvm初始化，可以用<code>public</code>、<code>protected</code>、<code>private</code>、<code>static</code>、<code>final</code>、<code>transient</code>、<code>volatile</code>关键字进行修饰。在初始化过程中注意就近原则。</p><p>类变量保存在方法区中，作用域为<strong>当前类</strong>。</p><p>实例变量保存在堆中，作用域为<strong>当前实例</strong>。</p><p>若局部变量和类变量重名，则可以使用<strong>类名.变量名</strong>进行访问。</p><p>若局部变量和成员变量重名，则可以使用<strong>this.变量名</strong>进行访问。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table><thead><tr><th>数据类型</th><th>大小/位</th><th>包装类</th><th>默认值（零值）</th><th>可表示数据范围</th></tr></thead><tbody><tr><td>byte(字节)</td><td>8-bit</td><td>Byte</td><td>(byte)0</td><td>-128~127</td></tr><tr><td>short(短整数)</td><td>16-bit</td><td>Short</td><td>(short)0</td><td>-32768~32767</td></tr><tr><td>int(整数)</td><td>32-bit</td><td>Integer</td><td>0</td><td>-2147483648~2147483647</td></tr><tr><td>long(长整数)</td><td>64-bit</td><td>Long</td><td>0L</td><td>-9223372036854775808~9223372036854775807</td></tr><tr><td>float(单精度)</td><td>32-bit</td><td>Float</td><td>0.0F</td><td>1.4E-45~3.4028235E38</td></tr><tr><td>double(双精度)</td><td>64-bit</td><td>Double</td><td>0.0D</td><td>4.9E-324~1.7976931348623157E308</td></tr><tr><td>boolean</td><td></td><td>Boolean</td><td>flase</td><td>true或false</td></tr><tr><td>char(字符)</td><td>16-bit</td><td>Character</td><td>‘\u0000’（对应数字0，输出为空）</td><td>0~65535</td></tr></tbody></table><p>第一类：整数类型  byte short int long，byte、short在计算时默认转int</p><p>第二类：浮点型  float double</p><p>第三类：逻辑型   boolean(它只有两个值可取true false)</p><p>第四类：字符型  char</p><p>低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double。不同的数据类型不能自动装箱拆箱</p><h2 id="枚举成员初始化"><a href="#枚举成员初始化" class="headerlink" title="枚举成员初始化"></a>枚举成员初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AccountType &#123;</span><br><span class="line">    SAVING, FIXED, CURRENT;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“It is a account type”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型。上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span> </span>&#123; System.out.println(“It is a account type”); &#125;</span><br></pre></td></tr></table></figure><p>会变成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(s,i); </span><br><span class="line">System.out.println(“It is a account type”); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在这个类中，会添加若干字段来代表具体的枚举类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType SAVING;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType FIXED;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType CURRENT;</span><br></pre></td></tr></table></figure><p>而且还会添加一段static代码段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  SAVING = <span class="keyword">new</span> AccountType(<span class="string">"SAVING"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">  CURRENT = <span class="keyword">new</span> AccountType(<span class="string">"CURRENT"</span>, <span class="number">0</span>);</span><br><span class="line">  $VALUES = <span class="keyword">new</span> AccountType[]&#123;</span><br><span class="line">    SAVING, FIXED, CURRENT</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）</p><p>在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。</p><h2 id="ThreadLocal内部真的维护了个map吗？"><a href="#ThreadLocal内部真的维护了个map吗？" class="headerlink" title="ThreadLocal内部真的维护了个map吗？"></a>ThreadLocal内部真的维护了个map吗？</h2><p>ThreadLocal类用于创建一个线程本地变量。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap，也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。</p><p>ThreadLocal的使用场景：</p><p>数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点是占用了较多的空间。</p><h2 id="public类名与文件名"><a href="#public类名与文件名" class="headerlink" title="public类名与文件名"></a>public类名与文件名</h2><p>一个文件中可以有多个类，如果没有public类，则可以与任意类名相同。如果有public类则文件名必须与此类名相同，因为一个文件中只能有一个public类。如果文件中只有一个类，则文件名必须与类名相同</p><h2 id="String拼接"><a href="#String拼接" class="headerlink" title="String拼接"></a>String拼接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象   </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中。而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。</p><h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><blockquote><p>Returns a canonical representation for the string object.A pool of strings, initially empty, is maintained privately by the class String.When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"go"</span>).append(<span class="string">"od"</span>).toString();</span><br><span class="line">System.out.println(s1.intern() == s1);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">System.out.println(s2.intern() == s2);<span class="comment">// false java字符串会被jvm在启动过程中加载</span></span><br></pre></td></tr></table></figure><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&lt;&lt;表示左移位</p><p>&gt;&gt;表示带符号右移位</p><p>&gt;&gt;&gt;表示无符号右移，左边空出的位以0填充</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>在计算机系统中，数值一律用<strong>补码</strong>来表示（存储）</p><p>正数符号位是0，负数符号位是1</p><p>正数原码，反码，补码相同</p><p>负数反码除了符号位不变，其他位取反，补码=反码+1</p><blockquote><p><strong>以下</strong> <strong>b</strong> <strong>的值是：</strong> <strong>byte b = (byte)129;</strong></p></blockquote><p>129为int类型，转byte，被截取为1000 0001。此时1000 0001为截取后所代表数字的补码，要将其转化为原码。</p><p><strong>补码：</strong>1000 0001</p><p><strong>反码：</strong>1000 0000</p><p><strong>原码：</strong>1111 1111</p><p>b=-127</p><blockquote><p>执行如下程序代码</p><p>char chr = 127;</p><p>int sum = 200;</p><p>chr += 1;</p><p>sum += chr;</p><p>后，sum的值是  ; （   ）</p><p>备注：同时考虑c/c++和Java的情况的话</p></blockquote><p>Java中byte占一个字节，char占两个字节, 所以对于Java来说127不会发生溢出，输出328</p><p>但是对于c/c++语言来说，char占一个字节, 会发生溢出，对127加一发生溢出，0111 1111 –&gt; 1000 0000, 1000 0000为补码-128，所以结果为200-128=72</p><h2 id="泛型PECS原则"><a href="#泛型PECS原则" class="headerlink" title="泛型PECS原则"></a>泛型PECS原则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 只看尖括号里边的！！明确点和范围两个概念</span><br><span class="line">2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;，List&lt;B&gt;，List&lt;Object&gt;</span><br><span class="line">3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围</span><br><span class="line">4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</span><br><span class="line">5. 尖括号小范围赋值给大范围，对；大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值。否则，不能赋值</span><br><span class="line">6. List&lt;?&gt;和List 是相等的，都代表最大范围</span><br><span class="line">7. List既是点也是范围，当表示范围时，表示最大范围</span><br></pre></td></tr></table></figure><p><strong>具体实例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;A&gt; a;</span><br><span class="line">    List list;</span><br><span class="line">    list = a;   <span class="comment">//对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内</span></span><br><span class="line">    List&lt;B&gt; b;</span><br><span class="line">    a = b;      <span class="comment">//错，点之间不能相互赋值</span></span><br><span class="line">    List&lt;?&gt; qm;</span><br><span class="line">    List&lt;Object&gt; o;</span><br><span class="line">    qm = o;     <span class="comment">//对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内</span></span><br><span class="line">    List&lt;D&gt; d;</span><br><span class="line">    List&lt;? extends B&gt; downB;</span><br><span class="line">    downB = d;  <span class="comment">//对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中</span></span><br><span class="line">    List&lt;?extends A&gt; downA;</span><br><span class="line">    a = downA;  <span class="comment">//错，范围不能赋值给点</span></span><br><span class="line">    a = o;      <span class="comment">//错，List&lt;Object&gt;只是一个点</span></span><br><span class="line">    downA = downB;  <span class="comment">//对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终类（final类、不可变类）"><a href="#最终类（final类、不可变类）" class="headerlink" title="最终类（final类、不可变类）"></a>最终类（final类、不可变类）</h2><p>最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li><p>数字，字母，符号（只有_和$两种），数字不能开头。</p></li><li><p>不能是关键字及两个保留关键字（goto，const）或者显式常量（null，true，false）。</p></li></ul><h2 id="关键字（keywords）"><a href="#关键字（keywords）" class="headerlink" title="关键字（keywords）"></a>关键字（keywords）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class    extends implements null      strictfp     true</span><br><span class="line">assert   const    false   import     package   super        try</span><br><span class="line">boolean  continue final   instanceof private   switch       void</span><br><span class="line">break    default  finally int        protected synchronized volatile</span><br><span class="line">byte     do       float   interface  public    this         while</span><br><span class="line">case     double   for     long       return    throw</span><br><span class="line">catch    else     goto    native     short     throws</span><br><span class="line">char     enum     if      new        static    transient</span><br></pre></td></tr></table></figure><h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byValue cast const false future generic goto inner null operator outer rest true var</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li><p>普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。</p></li><li><p>构造函数不能被继承，构造方法只能被显式或隐式的调用。</p></li></ul><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>[://] 表示匹配 :// 中的任何一个字符，也就是匹配 : 或 /</p><p>[htps] 表示匹配 htps 中的任何一个字符，[htps]+ 表示一次或多次匹配前面的字符或子表达式，所以 [htps]+ 可以匹配 https</p><h2 id="a的b次幂"><a href="#a的b次幂" class="headerlink" title="a的b次幂"></a>a的b次幂</h2><p>Math类中的一个静态方法 ： pow(double a, double b)</p><p>^表示异或，就是相同是0，不同是1</p><h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SuperTest().test();<span class="comment">//test07.SuperTest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestSuper和Date的getClass都没有重写，他们都是调用Object的getClass，而Object的getClass作用是返回的是运行时的类的名字。这个运行时的类就是当前类，所以super.getClass().getName()返回的是test07.SuperTest，与Date类无关。要返回Date类的名字需要写super.getClass().getSuperclass()</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    split(<span class="number">12</span>);<span class="comment">//12136</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">      System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析过程，伪代码：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sout split(6) &#x3D; &#123;</span><br><span class="line">    sout split(3) &#x3D; &#123;</span><br><span class="line">        sout split(2) &#x3D; &#123;</span><br><span class="line">            sout split(1)</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">        sout split(1)</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ol><li><p>接口中属性为public static final，方法为public abstract，接口中不可以有构造方法。</p></li><li><p>抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已</p></li><li><p>Java不允许类多重继承</p></li><li><p>jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体</p></li></ol><h3 id="线程停止方法"><a href="#线程停止方法" class="headerlink" title="线程停止方法"></a>线程停止方法</h3><p>sleep让线程休眠，yield让运行中的线程回到就绪状态，synchronized只是同步阻塞，让线程进入对象的阻塞队列</p><h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ol><li>静态初始化</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><p>需要<strong>注意</strong>的是，写成如下形式是<strong>错误</strong>的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul><li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h3 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h3><p><strong>USES-A：</strong>依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。</p><p><strong>关联关系：</strong>A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。</p><p><strong>HAS-A：</strong>聚合关系，拥有关系，是<strong>关联关系</strong>的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。</p><p><strong>IS-A：</strong>表示继承。父类与子类，这个就不解释了。</p><p>要注意：还有一种关系：<strong>组合关系</strong>也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f[][] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> []f[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> f[][] = <span class="keyword">new</span> <span class="keyword">float</span>[][<span class="number">6</span>];<span class="comment">//error</span></span><br><span class="line"><span class="keyword">float</span> [][]f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> [][]f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][];</span><br></pre></td></tr></table></figure><p>数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。</p><h3 id="字符编码和国际化"><a href="#字符编码和国际化" class="headerlink" title="字符编码和国际化"></a>字符编码和国际化</h3><ol><li>Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。</li><li>不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。</li></ol><p>例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”);</p><ol start="3"><li>Java虚拟机中通常使用UTF-16的方式保存一个字符（char）</li><li>ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。</li></ol><h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><ol><li><p>虚函数的存在是为了多态。Java中其实没有虚函数的概念，它的<strong>普通函数</strong>就相当于<strong>C++的虚函数</strong>，动态绑定是Java的默认行为。如果Java中不希望某个函数具有虚函数特性，可以加上<strong>final关键字</strong>变成<strong>非虚函数</strong>。</p></li><li><p>抽象函数或者说是纯虚函数的存在是为了定义接口。Java中纯虚函数形式为：abstract void print();</p></li></ol><h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i01==i02);<span class="comment">//true</span></span><br><span class="line">System.out.println(i01==i03);<span class="comment">//true</span></span><br><span class="line">System.out.println(i03==i04);<span class="comment">//false</span></span><br><span class="line">System.out.println(i02==i04);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><ol><li>无论如何，Integer=xxx与new Integer不会相等，不会经历拆箱过程</li><li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。例如，java在编译Integer i2 = 128的时候，被翻译成-&gt; Integer i2 = Integer.valueOf(128); 而valueOf()函数会对-128到127之间的数进行缓存</li><li>两个都是new出来的,都为false</li><li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li></ol><h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><blockquote><p>例题：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">     </span><br><span class="line">    t.join();</span><br><span class="line">    System.out.print(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为子线程的休眠时间太长，因此主线程很有可能在子线程之前结束也就是输出结果是12，但是子线程用了join函数，因此主线程必须等待子线程执行完毕才结束因此输出结果只能是21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.join();      <span class="comment">//使调用线程 t 在此之前执行完毕。</span></span><br><span class="line">t.join(<span class="number">1000</span>);  <span class="comment">//等待 t 线程，等待时间是1000毫秒</span></span><br></pre></td></tr></table></figure><h3 id="常见的锁"><a href="#常见的锁" class="headerlink" title="常见的锁"></a>常见的锁</h3><ol><li><p>自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p></li><li><p>阻塞锁 被阻塞的线程，不会争夺锁。</p></li><li><p>可重入锁 多次进入改锁的域</p></li><li><p>读写锁</p></li><li><p>互斥锁 锁本身就是互斥的</p></li><li><p>悲观锁 不相信，这里会是安全的，必须全部上锁</p></li><li><p>乐观锁 相信，这里是安全的。</p></li><li><p>公平锁 有优先级的锁</p></li><li><p>非公平锁 无优先级的锁</p></li><li><p>偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p></li><li><p>对象锁 锁住对象</p></li><li><p>线程锁</p></li><li><p>锁粗化 多锁变成一个，自己处理</p></li><li><p>轻量级锁 CAS 实现</p></li><li><p>锁消除 偏向锁就是锁消除的一种</p></li><li><p>锁膨胀 jvm实现，锁粗化</p></li><li><p>信号量 使用阻塞锁 实现的一种策略</p></li><li><p>排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p></li></ol><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ol><li><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</p></li><li><p>包装类的equals()方法不处理数据转型</p></li></ol><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol><li><p>&amp; 与操作</p></li><li><p>| 或操作</p></li><li><p>! 非操作</p></li><li><p>~ 取反操作</p></li></ol><h3 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h3><p>hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。</p><p><strong><em>那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？</em></strong>因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</p><p><strong><em>那么hashCode()既然效率这么高为什么还要equals()呢？</em></strong> 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。</p><p><strong><em>所以我们可以得出：</em></strong></p><ol><li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</p></li><li><p>hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p></li></ol><p>所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低。所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）。如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><blockquote><p>列题：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"1314520"</span>;</span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>, v4 =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i]) &#123;</span><br><span class="line">            <span class="keyword">default</span>: v4++;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: v1++;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>: v2++;</span><br><span class="line">            cas3 <span class="string">'3'</span>: v3++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d, %d, %d"</span>, v4,v1,v2,v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>result：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3567</span><br></pre></td></tr></table></figure><p>default顾名思义是缺省情况，只有任何条件都不匹配的情况下才会执行，故会匹配到s[i]为‘4’，‘5’，‘0’ 的情况。于是v4++三次，v4=3。并且这个default后没有使用break语句，于是case‘1’、‘2’、‘3’都会执行三次。注意到所有语句都没有加break，则语句执行过之后会继续下面的case语句。另外由于s[i]中有两个1，故v1,v2,v3此时为5.另外有一个2，v2,v3++后为6，还有一个case3 于是v3++.最终v3为7。</p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol><li>数组是一个对象，不同类型的数组具有不同的类</li><li>数组是一个连续的存储结构</li><li>可以二维数组，且可以有多维数组，都是在Java中合法的</li><li>查看源码可以知道数组的equals方法是object的equals，比较的是内存地址</li></ol><h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><p>一个字符常量表示为一个字符或一个转义序列，被一对ASCII<strong>单引号</strong>关闭。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol><li>Class类位于java.lang包下。Method, Filed等类位于java.lang.reflet包下</li></ol><h3 id="导致InterruptedException异常"><a href="#导致InterruptedException异常" class="headerlink" title="导致InterruptedException异常"></a>导致InterruptedException异常</h3><ol><li>java.lang.Object 类的 wait 方法</li><li>java.lang.Thread 类的 sleep 方法</li><li>java.lang.Thread 类的 join 方法</li></ol><h3 id="汉字长度"><a href="#汉字长度" class="headerlink" title="汉字长度"></a>汉字长度</h3><p>java的String底层是char数组，它的length()返回数组大小。一个汉字等于一个字符（char），一个汉字也等于二个字节（byte）。</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ol><li>Bootstrap ClassLoader，主要加载JVM自身工作需要的类。</li><li>Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。</li><li>Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</li><li>JVM类加载机制为<strong>双亲委托模型</strong>。如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。<strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</li></ol><h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><ol><li>不同的数据类型不能自动装箱拆箱</li></ol><h3 id="jdk命令"><a href="#jdk命令" class="headerlink" title="jdk命令"></a>jdk命令</h3><ol><li><p>jps：查看本机java进程信息。</p></li><li><p>jstack：打印线程的<strong>栈</strong>信息，制作线程dump文件。</p></li><li><p>jmap：打印内存映射，制作<strong>堆</strong>dump文件</p></li><li><p>jstat：性能监控工具</p></li><li><p>jhat：内存分析工具</p></li><li><p>jconsole：简易的可视化控制台</p></li><li><p>jvisualvm：功能强大的控制台</p></li></ol><p>java、javac、jar等开发工具是用Java编写的。</p><h3 id="static属性和方法"><a href="#static属性和方法" class="headerlink" title="static属性和方法"></a>static属性和方法</h3><blockquote><p>例题：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Test test=<span class="keyword">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>result：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能编译通过，并正确运行</span><br></pre></td></tr></table></figure><p>静态方法属于静态绑定，编译器根据引用类型所属的静态类型为它绑定其对应的方法。此语句会翻译成invokestatic，该指令的调用中不会涉及this,所以不会依赖对象！ 还有引用类型=null，其实就是指该引用在堆中没有对应的对象，但是编译的时候还是能根据声明找到其所属的静态类型。</p><h3 id="存根类"><a href="#存根类" class="headerlink" title="存根类"></a>存根类</h3><p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。</p><blockquote><p>dubbo远程调用可以有这么一个本地存根，场景是：用户要远程调用资源进行登录页面才能访问资源，但是无论登录成功还是不成功都得远程调用，这样就浪费了资源，所以我们就把验证这部分工作放在本地执行（本地存根），当用户验证（验证码等）工作放在本地，stub存根决定是否远程调用，也就是动态链接（动态连接使得大部分的连接过程延迟,直到程序开始运行）。</p></blockquote><h3 id="static与重载"><a href="#static与重载" class="headerlink" title="static与重载"></a>static与重载</h3><blockquote><p>例题：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Collection&lt;?&gt;[] collections = </span><br><span class="line">&#123;<span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="keyword">new</span> ArrayList&lt;String&gt;(), <span class="keyword">new</span> HashMap&lt;String, String&gt;().values();</span><br><span class="line">Super subToSuper = <span class="keyword">new</span> Sub();</span><br><span class="line"><span class="keyword">for</span> (Collection&lt;?&gt; collection: collections) &#123;</span><br><span class="line">System.out.println(subToSuper.getType(collection));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Super:collection”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Super:list”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Super:arrayList”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Set&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Super:set”;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(HashSet&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> “Super:hashSet”;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Sub"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><ol><li>重载静态多分派——根据传入重载方法的参数类型，选择更加合适的一个重载方法</li><li>static方法不能被子类覆写，在子类中定义了和父类完全相同的static方法，则父类的static方法被隐藏，Son.staticmethod()或new Son().staticmethod()都是调用的子类的static方法，如果是Father.staticmethod()或者Father f = new Son(); f.staticmethod()调用的都是父类的static方法。</li><li>此题如果都不是static方法，则最终的结果是A. 调用子类的getType，输出collection</li></ol><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td>( )　[ ] 　.</td><td>从左到右</td></tr><tr><td>2</td><td>! 　~　 ++　 –</td><td>从右到左</td></tr><tr><td>3</td><td>*　 /　 %</td><td>从左到右</td></tr><tr><td>4</td><td>+　 -</td><td>从左到右</td></tr><tr><td>5</td><td>&lt;&lt; 　&gt;&gt;　 &gt;&gt;&gt;</td><td>从左到右</td></tr><tr><td>6</td><td>&lt; 　&lt;=　 &gt; 　&gt;=　 instanceof</td><td>从左到右</td></tr><tr><td>7</td><td>== 　!=</td><td>从左到右</td></tr><tr><td>8</td><td>&amp;</td><td>从左到右</td></tr><tr><td>9</td><td>^</td><td>从左到右</td></tr><tr><td>10</td><td>|</td><td>从左到右</td></tr><tr><td>11</td><td>&amp;&amp;</td><td>从左到右</td></tr><tr><td>12</td><td>||</td><td>从左到右</td></tr><tr><td>13</td><td>? :</td><td>从左到右</td></tr><tr><td>14</td><td>= 　+= 　-= 　*=　 /=　 %=　 &amp;=   |=   ^=　 ~= 　&lt;&lt;= 　&gt;&gt;=　 &gt;&gt;&gt;=</td><td>从右到左</td></tr><tr><td>15</td><td>,</td><td>从右到左</td></tr></tbody></table><p>当多个运算符出现在一个表达式中，谁的优先级别高，就先执行谁。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果完全不一样。</p><blockquote><p>例题</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complicatedexpression_r</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> x=<span class="number">20</span>, y=<span class="number">30</span>;</span><br><span class="line">Boolean b;</span><br><span class="line">b = x &gt; <span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &gt; <span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span>;</span><br><span class="line">System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题中符号的优先级排序是：’&gt;’，’&lt;’，’&amp;&amp;’，’||’。</p><p><strong>即：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=(x&gt;<span class="number">50</span>&amp;&amp;y&gt;<span class="number">60</span>)||(x&gt;<span class="number">50</span>&amp;&amp;y&lt;-<span class="number">60</span>)||(x&lt;-<span class="number">50</span>&amp;&amp;y&gt;<span class="number">60</span>)||(x&lt;-<span class="number">50</span>&amp;&amp;y&lt;-<span class="number">60</span>);</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure><h3 id="Java体系结构"><a href="#Java体系结构" class="headerlink" title="Java体系结构"></a>Java体系结构</h3><ul><li>Java程序设计语言</li><li>Java.class文件格式</li><li>Java应用编程接口（API）</li><li>Java虚拟机</li></ul><h3 id="Java不可被继承的类"><a href="#Java不可被继承的类" class="headerlink" title="Java不可被继承的类"></a>Java不可被继承的类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public final class Byte</span><br><span class="line"></span><br><span class="line">public final class Character</span><br><span class="line"></span><br><span class="line">public static final class Character.UnicodeBlock</span><br><span class="line"></span><br><span class="line">public final class Class&lt;T&gt;</span><br><span class="line"></span><br><span class="line">public final class Compile</span><br><span class="line"></span><br><span class="line">public final class Double</span><br><span class="line"></span><br><span class="line">public final class Float</span><br><span class="line"></span><br><span class="line">public final class Integer</span><br><span class="line"></span><br><span class="line">public final class Long</span><br><span class="line"></span><br><span class="line">public final class Math</span><br><span class="line"></span><br><span class="line">public final class ProcessBuilder</span><br><span class="line"></span><br><span class="line">public final class RuntimePermission</span><br><span class="line"></span><br><span class="line">public final class Short</span><br><span class="line"></span><br><span class="line">public final class StackTraceElement</span><br><span class="line"></span><br><span class="line">public final class StrictMath</span><br><span class="line"></span><br><span class="line">public final class String</span><br><span class="line"></span><br><span class="line">public final class StringBuffer</span><br><span class="line"></span><br><span class="line">public final class StringBuilder</span><br><span class="line"></span><br><span class="line">public final class System</span><br><span class="line"></span><br><span class="line">public final class Void</span><br></pre></td></tr></table></figure><h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h3><p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</p><h3 id="switch作用选择"><a href="#switch作用选择" class="headerlink" title="switch作用选择"></a>switch作用选择</h3><p>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int；从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型；从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p><h3 id="位运算提高计算性能"><a href="#位运算提高计算性能" class="headerlink" title="位运算提高计算性能"></a>位运算提高计算性能</h3><p>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p><blockquote><p>补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。</p></blockquote><h3 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h3><p>​    JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>​    由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。</p><p>​    类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p><blockquote><p>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；<br>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；<br>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p></blockquote><h3 id="静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？"><a href="#静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？"></a>静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Inner(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Inner(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：new Outer().new Inner();</p></blockquote><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/327715682_1562312226456_ACED241801E307EE7A39612F85A94EBF.png" alt=""></p><h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了<strong>新生代</strong>。</p><p>如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是<strong>老年代</strong>的用处。当不够用时，这些对象将直接通过<strong>分配担保</strong>机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>在JDK1.8之前<strong>运行时常量池</strong>被放在方法区,属于线程共享,JDK1.8之后,元空间取代了方法区,<strong>运行时常量池</strong>被也被放在元空间中,<strong>运行时常池</strong> 主要存放, class文件元信息描述,编译后的代码，引用类型数据，类文件常量池。所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。<strong>运行时常量池</strong>是在类加载完成之后，将每个class常量池中的符号引用值转存到<strong>运行时常量池</strong>中，也就是说，每个class都有一个<strong>运行时常量池</strong>，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p><p><strong>运行时常量池</strong>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><h3 id="CMS的GC过程"><a href="#CMS的GC过程" class="headerlink" title="CMS的GC过程"></a>CMS的GC过程</h3><ol><li>初始标记:暂停用户线程，对引用进行遍历并标记</li><li>并发标记：在并发情况下，遍历除1中标记过的线程并标记</li><li>并发预清理：并发情况下对以上的标记进行清理</li><li>重标记：由于3过程是并发的，可能会产生一些引用，所以需要暂停用户线程重新标记</li><li>并发清理：清理4过程产生的标记</li><li>并发重置：做一些收尾工作</li></ol><h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>Xms 起始内存</p><p>Xmx 最大内存</p><p>Xmn 新生代内存</p><p>Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小</p><p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p><p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。其中 Eden 和 Survivor 区的比例默认是 8:1:1。</p><p>-XX:MaxPermSize=n:设置持久代大小</p><p>收集器设置<br>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器<br>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename<br>并行收集器设置<br>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p><blockquote><p>假如某个JAVA进程的JVM参数配置如下：<br>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,<br>请问eden区最终分配的大小是多少？</p></blockquote><p>故该题为500*（3/5）=300M</p><h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h3 id="Cookie的获取方式"><a href="#Cookie的获取方式" class="headerlink" title="Cookie的获取方式"></a>Cookie的获取方式</h3><p>request.getCookies</p><p>返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</p><p>request.getHeader</p><p>以字符串形式返回指定的请求头的值。Cookie也是头的一种；</p><h3 id="request-属性参数"><a href="#request-属性参数" class="headerlink" title="request 属性参数"></a>request 属性参数</h3><p>request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。</p><h3 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h3><p>可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知</p><h3 id="forward和redirect区别"><a href="#forward和redirect区别" class="headerlink" title="forward和redirect区别"></a>forward和redirect区别</h3><ol><li>从地址栏显示来说</li></ol><p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。</p><p>redirect是服务端根据逻辑，发送一个状态码,告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL。</p><ol start="2"><li>从数据共享来说</li></ol><p>forward：转发页面和转发到的页面可以共享request里面的数据。</p><p>redirect：不能共享数据。</p><ol start="3"><li>从运用地方来说</li></ol><p>forward：一般用于用户登陆的时候,根据角色转发到相应的模块。</p><p>redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</p><ol start="4"><li>从效率来说</li></ol><p>forward：高。</p><p>redirect：低。</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java面试 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试</title>
      <link href="/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/"/>
      <url>/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试</p><a id="more"></a><p>参照<a href="https://docs.docker.com/install/linux/docker-ce/centos/" target="_blank" rel="noopener">官网</a>教程，实现<code>CentOS7</code>安装<code>docker</code>，注意的是这里的<code>docker</code>是<code>ce</code>版本的</p><h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure><h2 id="安装docker-ce版本"><a href="#安装docker-ce版本" class="headerlink" title="安装docker ce版本"></a>安装docker ce版本</h2><h3 id="安装所使用的仓库"><a href="#安装所使用的仓库" class="headerlink" title="安装所使用的仓库"></a>安装所使用的仓库</h3><h4 id="安装相关依赖"><a href="#安装相关依赖" class="headerlink" title="安装相关依赖"></a>安装相关依赖</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><h4 id="设置stable仓库"><a href="#设置stable仓库" class="headerlink" title="设置stable仓库"></a>设置stable仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><h4 id="安装docker-ce版本-1"><a href="#安装docker-ce版本-1" class="headerlink" title="安装docker ce版本"></a>安装docker ce版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io -y</span><br></pre></td></tr></table></figure><h3 id="开启docker"><a href="#开启docker" class="headerlink" title="开启docker"></a>开启docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure><h3 id="设置docker开机启动"><a href="#设置docker开机启动" class="headerlink" title="设置docker开机启动"></a>设置docker开机启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure><h3 id="查看安装"><a href="#查看安装" class="headerlink" title="查看安装"></a>查看安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure><h2 id="安装docker-compose"><a href="#安装docker-compose" class="headerlink" title="安装docker-compose"></a>安装docker-compose</h2><h3 id="下载安装脚本"><a href="#下载安装脚本" class="headerlink" title="下载安装脚本"></a>下载安装脚本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.5/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="赋予脚本可执行权限"><a href="#赋予脚本可执行权限" class="headerlink" title="赋予脚本可执行权限"></a>赋予脚本可执行权限</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br></pre></td></tr></table></figure><h3 id="查看安装-1"><a href="#查看安装-1" class="headerlink" title="查看安装"></a>查看安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><h2 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h2><h3 id="官网脚本"><a href="#官网脚本" class="headerlink" title="官网脚本"></a>官网脚本</h3><p>docker官方出品</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- get.docker.com | bash</span><br></pre></td></tr></table></figure><h3 id="一件脚本"><a href="#一件脚本" class="headerlink" title="一件脚本"></a>一件脚本</h3><p>按照官方教程总结</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt;(curl https://raw.githubusercontent.com/qianxiaoxinrou/Linux_script/master/docker_install.sh)</span><br></pre></td></tr></table></figure><h3 id="本地脚本安装"><a href="#本地脚本安装" class="headerlink" title="本地脚本安装"></a>本地脚本安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker_install.sh</span></span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">need_add=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"1. 卸载自带docker"</span></span><br><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"2. 安装相关依赖"</span></span><br><span class="line">sudo yum install -y yum-utils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"3. 设置stable仓库"</span></span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"4. 安装docker ce版本"</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"5. 启动docker"</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"6. 设置docker开机启动"</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line"><span class="built_in">read</span> -p <span class="string">"是否需要将当前用户添加到docker用户组: (y)es 是 : (n)0 否: "</span> need_add</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$need_add</span>"</span> == <span class="string">"y"</span> ] || [ <span class="string">"<span class="variable">$need_add</span>"</span> == <span class="string">"yes"</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"将 <span class="variable">$&#123;USER&#125;</span> 添加到 docker 用户组"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"7. 安装docker-compose"</span></span><br><span class="line">sudo curl -L <span class="string">"https://github.com/docker/compose/releases/download/1.25.0/docker-compose-<span class="variable">$(uname -s)</span>-<span class="variable">$(uname -m)</span>"</span> -o /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line">sudo chmod +x /usr/<span class="built_in">local</span>/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"8. 安装完成"</span></span><br><span class="line">docker version</span><br><span class="line">docker-compose version</span><br></pre></td></tr></table></figure><h2 id="额外配置"><a href="#额外配置" class="headerlink" title="额外配置"></a>额外配置</h2><p>有时当前并不是root用户，所以要将当前用户添加到docker用户组中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gpasswd -a <span class="variable">$&#123;USER&#125;</span> docker</span><br></pre></td></tr></table></figure><h2 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h2><p>参照 <a href="https://www.94ish.me/1635.html" target="_blank" rel="noopener">千影</a> 的Linux网络优化脚本</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CenOS7配置ssh免密登录</title>
      <link href="/2020/04/19/CenOS7%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/2020/04/19/CenOS7%E9%85%8D%E7%BD%AEssh%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>CenOS7配置ssh免密登录</p><a id="more"></a><h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><p>我是Mac系统，其他系统类似</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br></pre></td></tr></table></figure><p>若<code>.ssh</code>文件夹不存在则创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p .ssh</span><br></pre></td></tr></table></figure><p>生成ssh密钥</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -m PEM -t rsa</span><br></pre></td></tr></table></figure><p>将<code>id_rsa.pub</code>上传到服务器，我这里则是上传到的是服务器的<code>/root</code></p><h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><p>这里以<code>root</code>用户为例</p><p>若<code>/root/.ssh</code>文件夹不存在，则创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir -p .ssh</span><br></pre></td></tr></table></figure><p>将证书内容写入到文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure><p>修改ssh配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/ssh/sshd_config</span><br><span class="line"><span class="comment">#配置远程登录</span></span><br><span class="line">RSAAuthentication yes</span><br><span class="line">PubkeyAuthentication yes</span><br><span class="line"><span class="comment">#禁用密码登录(可选)</span></span><br><span class="line">PasswordAuthentication yes 改为 PasswordAuthentication no</span><br></pre></td></tr></table></figure><h2 id="重启ssh服务"><a href="#重启ssh服务" class="headerlink" title="重启ssh服务"></a>重启ssh服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>彻底搞懂 nginx 的 location 字段</title>
      <link href="/2020/04/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-nginx-%E7%9A%84-location-%E5%AD%97%E6%AE%B5/"/>
      <url>/2020/04/19/%E5%BD%BB%E5%BA%95%E6%90%9E%E6%87%82-nginx-%E7%9A%84-location-%E5%AD%97%E6%AE%B5/</url>
      
        <content type="html"><![CDATA[<p>彻底搞懂 nginx 的 location 字段</p><a id="more"></a><h2 id="前缀符号"><a href="#前缀符号" class="headerlink" title="前缀符号"></a>前缀符号</h2><ul><li><code>=</code>：对<code>URI</code>和<code>location</code>进行精确匹配，如果找到精确匹配，那么匹配便会终止</li><li><code>~</code>：正则匹配，区分大小写</li><li><code>~*</code>：正则匹配，不区分大小写</li><li><code>^~</code>：当最长前缀匹配中包含该字符时，则不会匹配正则表达式</li><li><code>@</code>：不是用来处理常规请求，而是被用来请求重定向</li></ul><h2 id="匹配顺序"><a href="#匹配顺序" class="headerlink" title="匹配顺序"></a>匹配顺序</h2><p>1、<code>nginx</code>会匹配那些定义了<em>prefix string<em>的<code>location</code>，能够完成*</em>最长*<em>匹配</em>prefix string</em></p><p>的<code>location</code>会被nginx记录</p><p>2、按照 <em>regular expressions*在配置文件出现的顺序进行匹配，找到了第一个匹配的 *regular expressions</em> ，那么<code>nginx</code>便停止匹配。如果没有找到与之相匹配的 <em>regular expressions</em>，<code>nginx</code>将会使用之前被记录下来的最长匹配<em>prefix string</em>的<code>location</code></p><p>3、如果最长匹配<em>prefix string</em>的<code>location</code>中有 <code>^~</code> ，那么<code>nginx</code>将不会进行<em>regular expressions</em>匹配</p><p>4、同理最长匹配<em>prefix string</em>的<code>location</code>中有 <code>=</code> ，<code>nginx</code>会对<code>URI</code>和<code>location</code>进行精确匹配，如果<code>nginx</code>找到了精确匹配，那么匹配将会终止</p><p>5、如果<code>location</code>的<em>prefix string</em>是以<code>/</code>结尾，那么请求可以进行特殊的处理（<code>proxy_pass</code>、<code>fastcgi_pass</code>，<code>uwsgi_pass</code>，<code>scgi_pass</code>、<code>memcached_pass</code>、<code>grpc_pass</code>）。</p><p>6、如果<code>步骤5</code>中<code>location</code>的<code>prefix string</code>同时存在<code>/</code>结尾和不带<code>/</code>结尾的，那么不带<code>/</code>结尾的将会永久的被以<code>301</code>状态码的方式重定向到<code>/</code>结尾的<code>location</code>中。如果对这种情况不是很满意的话，可以使用精确匹配的方式解决该问题：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">location /user/ &#123;</span><br><span class="line">    proxy_pass http://user.example.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /user &#123;</span><br><span class="line">    proxy_pass http://login.example.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 学习笔记 | 持续更新~~~</title>
      <link href="/2020/04/18/docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/"/>
      <url>/2020/04/18/docker-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<p>列出了docker常见的命令，及一些个人总结的知识点</p><a id="more"></a><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><blockquote><p>查看本地镜像</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><ul><li><p><code>-a</code>：显示所有镜像</p></li><li><p><code>-q</code>：显示镜像id</p></li></ul><blockquote><p>查找</p></blockquote><p>在dockerhub上寻找</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search tomcat</span><br></pre></td></tr></table></figure><ul><li><code>-s</code>：列出收藏数大于指定数量</li></ul><blockquote><p>下载镜像</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull tomcat</span><br></pre></td></tr></table></figure><p>默认是tomcat:latest</p><blockquote><p>删除镜像</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi tomcat / 镜像ID</span><br></pre></td></tr></table></figure><p>删除单个的情况，版本号不写默认是latest，删除多个可以用<code>空格</code>隔开</p><ul><li><code>-f</code>：强制删除</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi -f $(docker images -qa)</span><br></pre></td></tr></table></figure><p>删除本机全部镜像</p><blockquote><p>生成镜像</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit tomcat 当前正在运行的容器实例 命名空间/镜像名:版本编号</span><br></pre></td></tr></table></figure><p>根据容器实例生成镜像</p><ul><li><code>-m</code>：描述信息</li><li><code>-a</code>：作者</li></ul><p>方式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile路径 -t 命名空间/镜像名 .</span><br></pre></td></tr></table></figure><p>根据Dockerfile生成镜像</p><ul><li><p><code>-f</code>：Dockerfile路径</p></li><li><p><code>-t</code>：镜像的名字及标签，通常 name:tag 或者 name 格式；可以在一次构建中为一个镜像设置多个标签。</p></li><li><p><code>.</code>：当前路径</p></li></ul><blockquote><p>查看镜像历史</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">history</span> 镜像id</span><br></pre></td></tr></table></figure><hr><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><blockquote><p>创建一个新的容器并运行一个命令</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run centos</span><br></pre></td></tr></table></figure><p>本地有镜像的话则运行本地镜像，本地没有镜像的话则会去hub上pull</p><ul><li><code>-i</code>：已交互的方式运行容器，通常都是配合<strong>-t</strong>参数使用</li><li><code>-t</code>：为容器重新分配一个伪终端</li><li><code>--name</code>：别名</li><li><code>-d</code>：后台运行容器，并返回容器id，即启动守护式容器</li><li><code>-p</code>：主机端口:docker容器端口</li><li><code>-P</code>：随机分配端口</li><li><code>-v</code>：绑定一个卷，主机路径:容器路径</li><li><code>--rm</code>：运行结束时自动销毁</li><li><code>--restart</code>：设置容器重启策略，no，默认策略，在容器退出时不重启容器；on-failure，在容器非正常退出时（退出状态非0），才会重启容器；on-failure:3，在容器非正常退出时重启容器，最多重启3次；always，在容器退出时总是重启容器；unless-stopped，在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器</li></ul><p>值得说明的是，docker容器实例在后台运行，就必须要有一个前台进程，如果容器运行的不是那些一直挂起的命令，那么docker则会自动退出</p><blockquote><p>启动一个或多个已经被停止的容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start centos</span><br></pre></td></tr></table></figure><p>通常用来启动已经停止的容器</p><blockquote><p>列出当前运行的所有容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><ul><li><code>-a</code>：正在运行和历史上运行过得容器</li><li><code>-l</code>：上次运行的容器实例</li><li><code>-n</code>：最近n个创建的容器</li><li><code>-q</code>：只显示容器id</li></ul><blockquote><p>退出容器</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>关闭容器，无法再次进入</p><p>方式2：</p><p>Ctrl + p + q</p><p>关闭容器之后还可以再次进入</p><blockquote><p>重启容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart centos</span><br></pre></td></tr></table></figure><blockquote><p>停止容器</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop centos</span><br></pre></td></tr></table></figure><p>正常停止</p><p>方式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">kill</span> centos</span><br></pre></td></tr></table></figure><p>强制停止，类似于拔电源</p><blockquote><p>删除容器</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm centos</span><br></pre></td></tr></table></figure><p>删除单个</p><ul><li><code>-f</code>：强制删除</li></ul><p>删除多个</p><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f $(docker ps -aq)</span><br></pre></td></tr></table></figure><p>方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -aq | xargs docker rm -f</span><br></pre></td></tr></table></figure><blockquote><p>查看日志</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs centos</span><br></pre></td></tr></table></figure><ul><li><code>-t</code>：时间</li><li><code>-f</code>：跟随最新的日志</li><li><code>--tail</code>：显示最后多少条</li></ul><blockquote><p>查看容器内运行的进程</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top centos</span><br></pre></td></tr></table></figure><blockquote><p>查看容器内部的细节</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect centos</span><br></pre></td></tr></table></figure><blockquote><p>重新进入docker进行交互</p></blockquote><p>方式1：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker attach centos</span><br></pre></td></tr></table></figure><p>直接进入容器启动的命令行终端，不会启动新的进程</p><p>方式2：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> centos</span><br></pre></td></tr></table></figure><p>不进入容器却能够和容器交互</p><p>如果使用<strong>docker exec centos -it /bin/bash</strong>的话，则效果和<strong>docker attach centos</strong>相同</p><blockquote><p>拷贝文件到宿主机</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp centos:/tmp/yum.log /root</span><br></pre></td></tr></table></figure><p>将docker中<code>/tmp/yum.log</code>文件拷贝到宿主机<code>/root</code>中</p><hr><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><blockquote><p>添加数据卷</p></blockquote><p>方式1：</p><p>使用直接命令的方式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径:/容器内目录 镜像名</span><br></pre></td></tr></table></figure><p>容器退出后，主机修改共享文件后，docker容器中文件也会被修改</p><blockquote><p>查看数据卷和容器是否绑定成功</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect 容器id</span><br></pre></td></tr></table></figure><p>在返回的json串中，查看volume属性</p><blockquote><p>设置权限</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /宿主机绝对路径:/容器内目录:ro 镜像名</span><br></pre></td></tr></table></figure><ul><li><code>ro</code>：read only（只读）</li></ul><blockquote><p>出现Permission denied错误</p></blockquote><p>增加<code>--privileged=true</code>参数</p><p>方式2：</p><p>使用Dokcerfile添加，Dockerfile是对docker中镜像的描述。在Dockerfile中增加一下代码<code>VOLUME [&quot;/data1&quot;, &quot;/data2&quot;]</code>，值得注意的是， 通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的</p><blockquote><p>拷贝文件到容器</p></blockquote><p>方式1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www/</span><br></pre></td></tr></table></figure><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下</p><p>方式2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp /www/runoob 96f7f14e99ab:/www</span><br></pre></td></tr></table></figure><p>将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www</p><p>方式3:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp  96f7f14e99ab:/www /tmp/</span><br></pre></td></tr></table></figure><p>将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中</p><hr><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>使用一个容器作为父容器，专门用来存放数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --volumes-from 父容器id 子容器id</span><br></pre></td></tr></table></figure><p>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止</p><hr><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><h3 id="保留字指令"><a href="#保留字指令" class="headerlink" title="保留字指令"></a>保留字指令</h3><ul><li><code>FROM</code>：当前镜像是基于那个镜像的</li><li><code>MAINTAINER</code>：镜像作者及作者邮箱</li><li><code>RUN</code>：容器构建时所需要执行的命令</li><li><code>EXPOSE</code>：当前容器对外暴露出的端口</li><li><code>WORKDIR</code>：创建容器后，终端默认进来的工作目录</li><li><code>ARG</code>：构建参数和 <code>ENV</code> 的效果一样，都是设置环境变量。所不同的是，<code>ARG</code> 所设置的构建环境的环境变量，在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用 <code>ARG</code> 保存密码之类的信息，因为 <code>docker history</code> 还是可以看到所有值的。</li><li><code>ENV</code>：设置环境变量，在这之后的<code>RUN</code>指令都可以使用该变量</li><li><code>ADD</code>：拷贝（<code>COPY</code>） + 解压缩</li><li><code>COPY</code>：直接拷贝</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY src dest</span><br></pre></td></tr></table></figure><ul><li><code>VOLUME</code>：容器数据卷，主机路径:容器路径</li><li><code>CMD</code>：容器启动时要运行的命令。<code>CMD</code>指令可以有多个，但只有最后一个会生效，<code>CMD</code>会被<strong>docker run</strong>之后的参数替换（命令参数会被覆盖）</li><li><code>ENTRYPOINT</code>：容器启动时要运行的命令。（命令参数会被追加组合）</li><li><code>ONBUILD</code>：父镜像在子镜像<code>build</code>时被触发</li></ul><h2 id="实战篇"><a href="#实战篇" class="headerlink" title="实战篇"></a>实战篇</h2><h3 id="自定义tomcat"><a href="#自定义tomcat" class="headerlink" title="自定义tomcat"></a>自定义tomcat</h3><h4 id="创建Dockerfile文件"><a href="#创建Dockerfile文件" class="headerlink" title="创建Dockerfile文件"></a>创建Dockerfile文件</h4><p>内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 父镜像</span></span><br><span class="line">FROM centos:7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 作者信息</span></span><br><span class="line">MAINTAINER weiguangchao&lt;3409885610@qq.com&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制并解压</span></span><br><span class="line">ADD jdk-8u231-linux-x64.tar.gz /usr/<span class="built_in">local</span></span><br><span class="line">ADD apache-tomcat-9.0.27.tar.gz /usr/<span class="built_in">local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line">WORKDIR /usr/<span class="built_in">local</span>/apache-tomcat-9.0.27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/jdk1.8.0_231</span><br><span class="line">ENV CATALINA_HOME /usr/<span class="built_in">local</span>/apache-tomcat-9.0.27</span><br><span class="line">ENV PATH <span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$CATALINA_HOME</span>/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置对外暴露端口</span></span><br><span class="line">EXPOSE 8080</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装结束后运行的命令</span></span><br><span class="line">CMD startup.sh &amp;&amp; tail -f /usr/<span class="built_in">local</span>/apache-tomcat-9.0.27/logs/catalina.out</span><br></pre></td></tr></table></figure><h4 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -f Dockerfile2 -t weiguangchao/mytomcat:1.0 .</span><br></pre></td></tr></table></figure><h4 id="启动tomcat"><a href="#启动tomcat" class="headerlink" title="启动tomcat"></a>启动tomcat</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">-d \</span><br><span class="line">-p 9999:8080 \</span><br><span class="line">-v /root/webapps:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.27/webapps \</span><br><span class="line">-v /root/logs/:/usr/<span class="built_in">local</span>/apache-tomcat-9.0.27/logs \</span><br><span class="line">容器ID</span><br></pre></td></tr></table></figure><h4 id="创建index-html"><a href="#创建index-html" class="headerlink" title="创建index.html"></a>创建index.html</h4><p>在<code>~/webapps</code>创建<code>ROOT/index.html</code>文件</p><p>内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>ocg, I can do it!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>浏览器地址栏输入 <a href="http://192.168.153.130:9999/index.html" target="_blank" rel="noopener">http://192.168.153.130:9999/index.html</a> </p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/791982538.png" alt=""></p><h4 id="提交到hub"><a href="#提交到hub" class="headerlink" title="提交到hub"></a>提交到hub</h4><p>这里以阿里云为例，其实阿里云镜像服务里面已经提供了相关操作的代码了</p><blockquote><p>步骤1：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=阿里云用户名 registry.cn-shenzhen.aliyuncs.com</span><br></pre></td></tr></table></figure><blockquote><p>步骤2：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]</span><br></pre></td></tr></table></figure><blockquote><p>步骤3：</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker push registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]</span><br></pre></td></tr></table></figure><p> 根据实际镜像信息替换示例中的[ImageId]和[镜像版本号]参数。 </p><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-shenzhen.aliyuncs.com/weiguangchao/mytomcat:[镜像版本号]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Cloud OAuth2.0认证与授权</title>
      <link href="/2020/01/29/Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/"/>
      <url>/2020/01/29/Spring-Cloud-OAuth2-0%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>Spring Cloud OAuth2.0认证和授权</p><a id="more"></a><h2 id="OAuth2授权模式"><a href="#OAuth2授权模式" class="headerlink" title="OAuth2授权模式"></a>OAuth2授权模式</h2><h3 id="authorization-code：授权码模式"><a href="#authorization-code：授权码模式" class="headerlink" title="authorization_code：授权码模式"></a>authorization_code：授权码模式</h3><h4 id="第一步：客户端获取授权码"><a href="#第一步：客户端获取授权码" class="headerlink" title="第一步：客户端获取授权码"></a>第一步：客户端获取授权码</h4><p>客户端向认证服务器发送请求，试图获取授权码</p><ul><li>response_type：表示授权类型，必选项，此处的值固定为”code”</li><li>client_id：表示客户端的ID，必选项</li><li>redirect_uri：表示重定向URI，可选项</li><li>scope：表示申请的权限范围，可选项</li><li>state：表示客户端的当前状态，可以指定任意值，认证服务器会原封不动地返回这个值。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;code&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all&amp;state&#x3D;1</span><br></pre></td></tr></table></figure><h4 id="第二步：用户同意授权"><a href="#第二步：用户同意授权" class="headerlink" title="第二步：用户同意授权"></a>第二步：用户同意授权</h4><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%881.48.25.png" alt=""></p><h4 id="第三步：客户端通过授权码获取令牌"><a href="#第三步：客户端通过授权码获取令牌" class="headerlink" title="第三步：客户端通过授权码获取令牌"></a>第三步：客户端通过授权码获取令牌</h4><p>第三步本是一次请求，这里为了针对性才将此拆开</p><h5 id="1）设置客户端身份"><a href="#1）设置客户端身份" class="headerlink" title="1）设置客户端身份"></a>1）设置客户端身份</h5><ul><li>client_id：表示客户端ID，必选项。</li><li>client_secret：表示客户端密钥，必选项</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8A%E5%8D%8811.59.39.png" alt=""></p><h5 id="2）获取令牌"><a href="#2）获取令牌" class="headerlink" title="2）获取令牌"></a>2）获取令牌</h5><ul><li>grant_type：表示使用的授权模式，必选项，此处的值固定为”authorization_code”。</li><li>code：表示上一步获得的授权码，必选项。</li><li>redirect_uri：表示重定向URI，必选项，且必须与A步骤中的该参数值保持一致。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%881.57.21.png" alt=""></p><p>令牌参数说明：</p><ul><li>access_token：表示访问令牌，必选项。</li><li>token_type：表示令牌类型，该值大小写不敏感，必选项，可以是bearer类型或mac类型。</li><li>expires_in：表示过期时间，单位为秒。如果省略该参数，必须其他方式设置过期时间。</li><li>refresh_token：表示更新令牌，用来获取下一次的访问令牌，可选项。</li><li>scope：表示权限范围，如果与客户端申请的范围一致，此项可省略。</li></ul><p>由于授权码参数类似，就只在这里说明一次</p><h3 id="password：密码模式"><a href="#password：密码模式" class="headerlink" title="password：密码模式"></a>password：密码模式</h3><h4 id="第一步：用户向客户端提供用户名和密码"><a href="#第一步：用户向客户端提供用户名和密码" class="headerlink" title="第一步：用户向客户端提供用户名和密码"></a>第一步：用户向客户端提供用户名和密码</h4><p>客户端通过用户提供的用户名和密码向认证服务器申请令牌</p><h4 id="第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌"><a href="#第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌" class="headerlink" title="第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌"></a>第二部：客户端通过用户提供的用户名和密码以及id和密钥向认证服务器申请令牌</h4><h5 id="1）设置客户端身份-1"><a href="#1）设置客户端身份-1" class="headerlink" title="1）设置客户端身份"></a>1）设置客户端身份</h5><ul><li>client_id：表示客户端ID，必选项。</li><li>client_secret：表示客户端密钥，必选项</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8A%E5%8D%8811.59.39.png" alt=""></p><h5 id="2）获取令牌-1"><a href="#2）获取令牌-1" class="headerlink" title="2）获取令牌"></a>2）获取令牌</h5><ul><li>grant_type：表示授权类型，此处的值固定为”password”，必选项。</li><li>username：表示用户名，必选项。</li><li>password：表示用户的密码，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%882.12.27.png" alt=""></p><h3 id="client-credentials：客户端模式"><a href="#client-credentials：客户端模式" class="headerlink" title="client_credentials：客户端模式"></a>client_credentials：客户端模式</h3><h4 id="第一步：设置客户端身份"><a href="#第一步：设置客户端身份" class="headerlink" title="第一步：设置客户端身份"></a>第一步：设置客户端身份</h4><ul><li>client_id：表示客户端ID，必选项。</li><li>client_secret：表示客户端密钥，必选项</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8A%E5%8D%8811.59.39.png" alt=""></p><h4 id="第二步：获取令牌"><a href="#第二步：获取令牌" class="headerlink" title="第二步：获取令牌"></a>第二步：获取令牌</h4><ul><li>grant_type：表示授权类型，此处的值固定为”client_credentials”，必选项。</li><li>scope：表示权限范围，可选项。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%882.18.10.png" alt=""></p><h3 id="implicit：简化模式"><a href="#implicit：简化模式" class="headerlink" title="implicit：简化模式"></a>implicit：简化模式</h3><p>简化模式为授权码模式的简化版。即，授权码模式的第一步直接通过浏览器回显令牌</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:5000&#x2F;uaa&#x2F;oauth&#x2F;authorize?response_type&#x3D;token&amp;client_id&#x3D;c1&amp;redirect_uri&#x3D;https:&#x2F;&#x2F;www.ririiy.com&amp;scope&#x3D;all</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%882.21.47.png" alt=""></p><h2 id="Spring-Cloud-OAuth2认证和授权项目"><a href="#Spring-Cloud-OAuth2认证和授权项目" class="headerlink" title="Spring Cloud OAuth2认证和授权项目"></a>Spring Cloud OAuth2认证和授权项目</h2><p>在父工程引入Spring Boot和Spring Cloud的相关依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Inherit defaults from Spring Boot --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>Hoxton.SR1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="认证服务-distributed-security-uaa"><a href="#认证服务-distributed-security-uaa" class="headerlink" title="认证服务 distributed-security-uaa"></a>认证服务 distributed-security-uaa</h3><h4 id="依赖详情-pom-xml"><a href="#依赖详情-pom-xml" class="headerlink" title="依赖详情 pom.xml"></a>依赖详情 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka 客户端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- WEB --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Cloud OAuth2 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-application-yml"><a href="#配置文件-application-yml" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5000</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/uaa</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">distributed-security-uaa</span></span><br><span class="line">  <span class="attr">security:</span></span><br><span class="line">    <span class="attr">user:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">user</span></span><br><span class="line">      <span class="attr">password:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">c1</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="number">123</span></span><br><span class="line">      <span class="comment"># 回调URL</span></span><br><span class="line">      <span class="attr">registered-redirect-uri:</span> <span class="string">https://www.ririiy.com</span></span><br><span class="line">      <span class="comment"># 令牌有效时间</span></span><br><span class="line">      <span class="attr">access-token-validity-seconds:</span> <span class="number">7200</span>  <span class="comment"># 两小时</span></span><br><span class="line">      <span class="comment"># 令牌刷新时间</span></span><br><span class="line">      <span class="attr">refresh-token-validity-seconds:</span> <span class="number">259200</span>  <span class="comment"># 三天</span></span><br><span class="line">      <span class="attr">resource-ids:</span> <span class="string">r1</span></span><br><span class="line">    <span class="attr">authorization:</span></span><br><span class="line">      <span class="comment"># 放行check_token请求，便于检查access_token即令牌是否合法</span></span><br><span class="line">      <span class="attr">check-token-access:</span> <span class="string">permitAll()</span></span><br></pre></td></tr></table></figure><h4 id="开启Spring-Security"><a href="#开启Spring-Security" class="headerlink" title="开启Spring Security"></a>开启Spring Security</h4><p>如果不开启Spring Security的话，则会有相关提示</p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/%E6%88%AA%E5%B1%8F2020-01-31%E4%B8%8B%E5%8D%884.16.12.png" alt=""></p><p>创建Spring Security配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主启动类"><a href="#主启动类" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ririiy.security.distributed.uaa;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UaaServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(UaaServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="资源服务-distributed-security-resource"><a href="#资源服务-distributed-security-resource" class="headerlink" title="资源服务 distributed-security-resource"></a>资源服务 distributed-security-resource</h3><h4 id="依赖详情-pom-xml-1"><a href="#依赖详情-pom-xml-1" class="headerlink" title="依赖详情 pom.xml"></a>依赖详情 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- eureka 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- WEB --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- Spring Cloud OAuth2 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-application-yml-1"><a href="#配置文件-application-yml-1" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">7000</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="attr">context-path:</span> <span class="string">/res</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">distributed-security-res</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:3000/eureka/</span></span><br><span class="line"><span class="attr">security:</span></span><br><span class="line">  <span class="attr">oauth2:</span></span><br><span class="line">    <span class="attr">resource:</span></span><br><span class="line">      <span class="attr">id:</span> <span class="string">r1</span></span><br><span class="line">      <span class="comment"># 检查token</span></span><br><span class="line">      <span class="attr">token-info-uri:</span> <span class="string">http://localhost:5000/uaa/oauth/check_token</span></span><br><span class="line">    <span class="comment"># 客户端信息  </span></span><br><span class="line">    <span class="attr">client:</span></span><br><span class="line">      <span class="attr">client-id:</span> <span class="string">c1</span></span><br><span class="line">      <span class="attr">client-secret:</span> <span class="number">123</span></span><br></pre></td></tr></table></figure><h4 id="定义资源"><a href="#定义资源" class="headerlink" title="定义资源"></a>定义资源</h4><p>这里随便定义一个controller模拟资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(value = <span class="string">"r1"</span>, produces = <span class="string">"text/html;charset=utf-8"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">r1</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"r1 资源"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="主启动类-1"><a href="#主启动类-1" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ririiy.security.distributed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"><span class="keyword">import</span> org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableResourceServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ResourceServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册中心-distributed-security-registry"><a href="#注册中心-distributed-security-registry" class="headerlink" title="注册中心 distributed-security-registry"></a>注册中心 distributed-security-registry</h3><h4 id="依赖详情-pom-xml-2"><a href="#依赖详情-pom-xml-2" class="headerlink" title="依赖详情 pom.xml"></a>依赖详情 pom.xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- eureka 服务端 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="配置文件-application-yml-2"><a href="#配置文件-application-yml-2" class="headerlink" title="配置文件 application.yml"></a>配置文件 application.yml</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">3000</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">distributed-security-registry</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">registerWithEureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetchRegistry:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">serviceUrl:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br></pre></td></tr></table></figure><h4 id="主启动类-2"><a href="#主启动类-2" class="headerlink" title="主启动类"></a>主启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegistryServiceApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RegistryServiceApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Cloud </tag>
            
            <tag> OAuth2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC初始化和请求映射分析</title>
      <link href="/2019/11/22/SpringMVC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/"/>
      <url>/2019/11/22/SpringMVC%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E8%AF%B7%E6%B1%82%E6%98%A0%E5%B0%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC初始化流程和请求适配流程分析</p><a id="more"></a><h1 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h1><p><code>SpringMVC</code>的核心是<code>DispatcherServlet</code>，所以<code>SpringMVC</code>的初始化说白了也就是<code>DispatcherServlet</code>的初始化。</p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/QQ%E6%88%AA%E5%9B%BE20191122202656.png" alt=""></p><p>SpringMVC首先执行<code>DispatcherServlet</code>中static代码块中的逻辑，将<code>DispatcherServlet.properties</code>文件中的配置属性加载到名为<code>defaultStrategies</code>的<code>Properties</code>中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// Load default strategy implementations from properties file.</span></span><br><span class="line">    <span class="comment">// This is currently strictly internal and not meant to be customized</span></span><br><span class="line">    <span class="comment">// by application developers.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassPathResource resource = <span class="keyword">new</span> ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not load '"</span> + DEFAULT_STRATEGIES_PATH + <span class="string">"': "</span> + ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由<code>Servlet</code>的规范可知，在<code>Web</code>容器（<code>Tomcat</code>等）启动的过程中会判断<code>Servlet</code>是否需要提前实例化，而是否提前实例化由程序员外部配置的<code>loadOnStartup</code>参数决定，并且<code>DispatcherServlet</code>的<code>loadOnStartup</code>参数通常都是设为1，即，在<code>Web</code>容器启动的过程中会实例化<code>DispatcherServlet</code>。在实例化<code>DispatcherServlet</code>的过程中，<code>Web</code>容器首先会调用<code>Servlet</code>的<code>init()</code>方法，完成对Servlet的初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    <span class="comment">// Set bean properties from init parameters.</span></span><br><span class="line">    PropertyValues pvs = <span class="keyword">new</span> ServletConfigPropertyValues(getServletConfig(), <span class="keyword">this</span>.requiredProperties);</span><br><span class="line">    <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(<span class="keyword">this</span>);</span><br><span class="line">            ResourceLoader resourceLoader = <span class="keyword">new</span> ServletContextResourceLoader(getServletContext());</span><br><span class="line">            bw.registerCustomEditor(Resource<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">ResourceEditor</span>(<span class="title">resourceLoader</span>, <span class="title">getEnvironment</span>()))</span>;</span><br><span class="line">            initBeanWrapper(bw);</span><br><span class="line">            bw.setPropertyValues(pvs, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isErrorEnabled()) &#123;</span><br><span class="line">                logger.error(<span class="string">"Failed to set bean properties on servlet '"</span> + getServletName() + <span class="string">"'"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Let subclasses do whatever initialization they like.</span></span><br><span class="line">    initServletBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过观察发现该方法最终调用了<code>initServletBean()</code>，在<code>initServletBean()</code>中<code>SpringMVC</code>会调用<code>initWebApplicationContext()</code>方法完成<code>WebApplicationContext</code>的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">    getServletContext().log(<span class="string">"Initializing Spring "</span> + getClass().getSimpleName() + <span class="string">" '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Initializing Servlet '"</span> + getServletName() + <span class="string">"'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 初始化web环境</span></span><br><span class="line">        <span class="keyword">this</span>.webApplicationContext = initWebApplicationContext();</span><br><span class="line">        initFrameworkServlet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (ServletException | RuntimeException ex) &#123;</span><br><span class="line">        logger.error(<span class="string">"Context initialization failed"</span>, ex);</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">        String value = <span class="keyword">this</span>.enableLoggingRequestDetails ?</span><br><span class="line">            <span class="string">"shown which may lead to unsafe logging of potentially sensitive data"</span> :</span><br><span class="line">        <span class="string">"masked to prevent unsafe logging of potentially sensitive data"</span>;</span><br><span class="line">        logger.debug(<span class="string">"enableLoggingRequestDetails='"</span> + <span class="keyword">this</span>.enableLoggingRequestDetails +</span><br><span class="line">                     <span class="string">"': request parameters and headers will be "</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">        logger.info(<span class="string">"Completed initialization in "</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法最终会调用<code>configureAndRefreshWebApplicationContext(cwac)</code>，完成相关参数的设置之后，便调用了<code>refresh()</code>，完成对Spring容器的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configureAndRefreshWebApplicationContext</span><span class="params">(ConfigurableWebApplicationContext wac)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ObjectUtils.identityToString(wac).equals(wac.getId())) &#123;</span><br><span class="line">        <span class="comment">// The application context id is still set to its original default value</span></span><br><span class="line">        <span class="comment">// -&gt; assign a more useful id based on available information</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.contextId != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac.setId(<span class="keyword">this</span>.contextId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Generate default id...</span></span><br><span class="line">            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +</span><br><span class="line">                      ObjectUtils.getDisplayString(getServletContext().getContextPath()) + <span class="string">'/'</span> + getServletName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wac.setServletContext(getServletContext());</span><br><span class="line">    wac.setServletConfig(getServletConfig());</span><br><span class="line">    wac.setNamespace(getNamespace());</span><br><span class="line">    wac.addApplicationListener(<span class="keyword">new</span> SourceFilteringListener(wac, <span class="keyword">new</span> ContextRefreshListener()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The wac environment's #initPropertySources will be called in any case when the context</span></span><br><span class="line">    <span class="comment">// is refreshed; do it eagerly here to ensure servlet property sources are in place for</span></span><br><span class="line">    <span class="comment">// use in any post-processing or initialization that occurs below prior to #refresh</span></span><br><span class="line">    ConfigurableEnvironment env = wac.getEnvironment();</span><br><span class="line">    <span class="keyword">if</span> (env <span class="keyword">instanceof</span> ConfigurableWebEnvironment) &#123;</span><br><span class="line">        ((ConfigurableWebEnvironment) env).initPropertySources(getServletContext(), getServletConfig());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postProcessWebApplicationContext(wac);</span><br><span class="line">    applyInitializers(wac);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SpringMVC会自动调用refresh方法</span></span><br><span class="line">    wac.refresh();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里解释了为什么SpringMVC为什么不用显式的调用<code>refresh()</code></p><p>值得注意的是<code>ContextRefreshListener</code>，该监听器为<code>FrameworkServlet</code>内部的监听器，主要是用来监听<code>Spring</code>容器<code>ContextRefreshedEvent</code>事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextRefreshListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> </span>&#123;</span><br><span class="line">        FrameworkServlet.<span class="keyword">this</span>.onApplicationEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>refresh()</code>的最后一步<code>Spring</code>会发布<code>ContextRefreshedEvent</code>事件，而该事件会被<code>FrameworkServlet</code>内部的<code>ContextRefreshListener</code>监听到，并且会回调到<code>DispatcherServlet</code>中的<code>onRefresh</code>方法，继而调用了<code>DispatcherServlet</code>中的<code>initStrategies()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// MultipartResolver</span></span><br><span class="line">    <span class="comment">// 解释了为什么一定要把bean的名字配置为multipartResolver</span></span><br><span class="line">    <span class="comment">// SpringMVC内部通过getBean方法调用的名字为multipartResolver,已经写死</span></span><br><span class="line">    initMultipartResolver(context);</span><br><span class="line">    <span class="comment">// 国际化</span></span><br><span class="line">    initLocaleResolver(context);</span><br><span class="line">    <span class="comment">// 前端主题样式</span></span><br><span class="line">    initThemeResolver(context);</span><br><span class="line">    <span class="comment">// 初始化HandlerMapping</span></span><br><span class="line">    initHandlerMappings(context);</span><br><span class="line">    initHandlerAdapters(context);</span><br><span class="line">    initHandlerExceptionResolvers(context);</span><br><span class="line">    initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">// 视图转换器</span></span><br><span class="line">    initViewResolvers(context);</span><br><span class="line">    <span class="comment">// 重定向数据管理器</span></span><br><span class="line">    initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>initMultipartResolver(context)</code>方法也就解释了为什么文件上传解析器的名字一定要为<code>multipartResolver</code>了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initMultipartResolver</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"Detected "</span> + <span class="keyword">this</span>.multipartResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Detected "</span> + <span class="keyword">this</span>.multipartResolver.getClass().getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">        <span class="comment">// Default is no multipart resolver.</span></span><br><span class="line">        <span class="keyword">this</span>.multipartResolver = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">"No MultipartResolver '"</span> + MULTIPART_RESOLVER_BEAN_NAME + <span class="string">"' declared"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为<code>SpringMVC</code>已经将其写死了</p><p><code>SpringMVC</code>会从<code>defaultStrategies</code>中获取默认的<code>HandlerMapping</code>和<code>HandlerAdapter</code></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span></span><br><span class="line"><span class="attr">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</span></span><br><span class="line"></span><br><span class="line"><span class="meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span></span><br><span class="line">org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\</span><br><span class="line"><span class="attr">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</span></span><br></pre></td></tr></table></figure><p>至此<code>Web</code>环境初始化完成</p><hr><h1 id="请求映射流程"><a href="#请求映射流程" class="headerlink" title="请求映射流程"></a>请求映射流程</h1><p>从浏览器发出请求，经过<code>HTTPServlet</code>和<code>FrameworkServlet</code>最终来到了<code>DispatcherServlet</code>的<code>doDispatch</code>方法进行处理</p><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/QQ%E6%88%AA%E5%9B%BE20191122213023.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    HttpServletRequest processedRequest = request;</span><br><span class="line">    HandlerExecutionChain mappedHandler = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> multipartRequestParsed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步</span></span><br><span class="line">    WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">null</span>;</span><br><span class="line">        Exception dispatchException = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 检查是否有Multpart</span></span><br><span class="line">            processedRequest = checkMultipart(request);</span><br><span class="line">            multipartRequestParsed = (processedRequest != request);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler for the current request.</span></span><br><span class="line">            <span class="comment">// 推断当前请求的handler</span></span><br><span class="line">            mappedHandler = getHandler(processedRequest);</span><br><span class="line">            <span class="keyword">if</span> (mappedHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                noHandlerFound(processedRequest, response);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Determine handler adapter for the current request.</span></span><br><span class="line">            <span class="comment">// ------------------------------注意------------------------------</span></span><br><span class="line">            <span class="comment">// 手动观察</span></span><br><span class="line">            <span class="comment">// 如果handler是一个bean，则getHandler返回的是一个对象</span></span><br><span class="line">            <span class="comment">// 如果handler是一个方法，则getHandler放回的是一个方法</span></span><br><span class="line">            <span class="comment">// Spring将handler交给对应的处理器去处理</span></span><br><span class="line">            HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Process last-modified header, if supported by the handler.</span></span><br><span class="line">            <span class="comment">// Spring确定了如何调用handler的方法</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">boolean</span> isGet = <span class="string">"GET"</span>.equals(method);</span><br><span class="line">            <span class="keyword">if</span> (isGet || <span class="string">"HEAD"</span>.equals(method)) &#123;</span><br><span class="line">                <span class="keyword">long</span> lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">new</span> ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 拦截器的前置处理</span></span><br><span class="line">            <span class="keyword">if</span> (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Actually invoke the handler.</span></span><br><span class="line">            <span class="comment">// 调用handler进行处理</span></span><br><span class="line">            mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            applyDefaultViewName(processedRequest, mv);</span><br><span class="line">            <span class="comment">// 调用拦截器后置处理方法</span></span><br><span class="line">            mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            dispatchException = ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">            <span class="comment">// As of 4.3, we're processing Errors thrown from handler methods as well,</span></span><br><span class="line">            <span class="comment">// making them available for @ExceptionHandler methods and other scenarios.</span></span><br><span class="line">            dispatchException = <span class="keyword">new</span> NestedServletException(<span class="string">"Handler dispatch failed"</span>, err);</span><br><span class="line">        &#125;</span><br><span class="line">        processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable err) &#123;</span><br><span class="line">        triggerAfterCompletion(processedRequest, response, mappedHandler,</span><br><span class="line">                               <span class="keyword">new</span> NestedServletException(<span class="string">"Handler processing failed"</span>, err));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">            <span class="comment">// Instead of postHandle and afterCompletion</span></span><br><span class="line">            <span class="keyword">if</span> (mappedHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Clean up any resources used by a multipart request.</span></span><br><span class="line">            <span class="keyword">if</span> (multipartRequestParsed) &#123;</span><br><span class="line">                cleanupMultipart(processedRequest);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringMVC</code>会遍历所有的<code>handlerMappings</code>找到能够处理该请求的handler，而<code>handlerMappings</code>的默认值为<code>DispatcherServlet</code>初始化时static代码块中从配置问价加载的<code>RequestMappingHandlerMapping</code>和<code>BeanNameUrlHandlerMapping</code></p><p>注意，如果是通过<code>@Controller</code>注解配置的<code>Handler</code>，则<code>getHandler()</code>方法返回的是一个方法；如果是通过实现接口（<code>Controller</code>，<code>HttpRequestHandler</code>）的方法配置的<code>Handler</code>，那么<code>getHandler()</code>返回的是一个对象</p><p>SpringMVC会在handler调用的前后分别执行拦截器的<code>applyPreHandle()</code>和<code>applyPostHandle()</code>方法，完成对请求的拦截</p><p>至此请求过程调用结束…</p><hr><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><h2 id="Spring中的事件"><a href="#Spring中的事件" class="headerlink" title="Spring中的事件"></a>Spring中的事件</h2><p>Spring中的事件是通过<code>applicationEventMulticaster</code>即广播器向所有的监听器发送的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(event, <span class="string">"Event must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decorate event as an ApplicationEvent if necessary</span></span><br><span class="line">    ApplicationEvent applicationEvent;</span><br><span class="line">    <span class="keyword">if</span> (event <span class="keyword">instanceof</span> ApplicationEvent) &#123;</span><br><span class="line">        applicationEvent = (ApplicationEvent) event;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        applicationEvent = <span class="keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="keyword">this</span>, event);</span><br><span class="line">        <span class="keyword">if</span> (eventType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.earlyApplicationEvents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.earlyApplicationEvents.add(applicationEvent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Publish event via parent context as well...</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parent <span class="keyword">instanceof</span> AbstractApplicationContext) &#123;</span><br><span class="line">            ((AbstractApplicationContext) <span class="keyword">this</span>.parent).publishEvent(event, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.parent.publishEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层就是通过广播器拿到所有的监听器，循环调用监听的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, @Nullable ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">    ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">    Executor executor = getTaskExecutor();</span><br><span class="line">    <span class="keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executor.execute(() -&gt; invokeListener(listener, event));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            invokeListener(listener, event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringMVC成为Handler的三种方式"><a href="#SpringMVC成为Handler的三种方式" class="headerlink" title="SpringMVC成为Handler的三种方式"></a>SpringMVC成为Handler的三种方式</h2><blockquote><p>@Controller</p></blockquote><p>老生常谈了，通过<code>@RequestMapping</code>完成映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IndexController</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"com.hrious.weblearn.controller.IndexController.IndexController"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/index.do"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"com.hrious.weblearn.controller.IndexController.index"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"@controller"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/map.do"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"com.hrious.weblearn.controller.IndexController.map"</span>);</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="string">"123"</span>, <span class="string">"xxx"</span>);</span><br><span class="line"><span class="keyword">return</span> map;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.springframework.web.servlet.mvc.Controller</p></blockquote><p>实现<code>Controller</code>接口，重写<code>handleRequest</code>方法。其中<code>bean</code>名称为请求映射地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"/index2.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController2</span> <span class="keyword">implements</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">response.getWriter().write(<span class="string">"controller.."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>org.springframework.web.HttpRequestHandler</p></blockquote><p>实现<code>HttpRequestHandler</code>接口，重写<code>handleRequest</code>方法，同样bean名称为请求映射地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"/index3.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IndexController3</span> <span class="keyword">implements</span> <span class="title">HttpRequestHandler</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">response.getWriter().write(<span class="string">"HttpRequestHandler.."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h2><p>映射请求到对应的Handler</p><blockquote><p>org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping</p></blockquote><p>在实现（<code>Controller</code>，<code>HttpRequestHandler</code>）接口的Handler集合中寻找合适的Handler完成请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping</p></blockquote><p>在添加了<code>@Controller</code>注解的Handler集合中寻找合适的Handler完成请求的处理</p><h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>调用Handler的相关方法，完成对请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter</p></blockquote><p>调用带有<code>@RequestMapping</code>注解的handler，完成请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter</p></blockquote><p>调用实现了<code>Controller</code>的handler，完成请求的处理</p><blockquote><p>org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter</p></blockquote><p>调用实现了<code>HttpRequestHandler</code>的handler，完成请求的处理</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
