<!DOCTYPE html>
<html>
<head hexo-theme='https://volantis.js.org/#2.6.2'>
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
    
  
  <!-- 渲染优化 -->
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <!-- 页面元数据 -->
  
    <title>Java基础面试题总结 - enenZhuyi&#39;s日常随笔</title>
  
    <meta name="keywords" content="Java面试,Java">
  
  
    <meta name="description" content="总结了自己刷题过程中和网上常见的面试题">
  

  <!-- feed -->
  

  <!-- import meta -->
  

  <!-- link -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13/css/all.min.css">
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css">

  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css">

  

  

  
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css">
  

  <!-- import link -->
  

  
  
    
<link rel="stylesheet" href="/css/style.css">

  

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>

  
  
</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>
<header class="l_header shadow blur">
  <div class='container'>
  <div class='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h'>
        <li><a class="s-comment fas fa-comments fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
          <li><a class="s-toc fas fa-list fa-fw" target="_self" href='javascript:void(0)'></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
          
            VOLANTIS <b><sup style='color:#3AA757'>2.6.2</sup></b>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h'>
          
          
          
            
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
          
				</ul>
			</div>

      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fas fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="Search..." />
        </form>
      </div>

			<ul class='switcher nav-list-h'>
				
					<li><a class="s-search fas fa-search fa-fw" target="_self" href='javascript:void(0)'></a></li>
				
				<li>
          <a class="s-menu fas fa-bars fa-fw" target="_self" href='javascript:void(0)'></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="flat-box" href=/
                  
                  
                  
                    id="home"
                  >
                  <i class='fas fa-rss fa-fw'></i>博客
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/categories/
                  
                  
                  
                    id="categories"
                  >
                  <i class='fas fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/tags/
                  
                  
                  
                    id="tags"
                  >
                  <i class='fas fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/archives/
                  
                  
                  
                    id="archives"
                  >
                  <i class='fas fa-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/friends/
                  
                  
                  
                    id="friends"
                  >
                  <i class='fas fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="flat-box" href=/about/
                  
                  
                  
                    id="about"
                  >
                  <i class='fas fa-info-circle fa-fw'></i>关于
                </a>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>
		</div>
	</div>
  </div>
</header>

<script>setLoadingBarProgress(40);</script>



  <div class="l_body nocover">
    <div class='body-wrapper'>
      

<div class='l_main'>
  

  
    <article id="post" class="post white-box shadow article-type-post" itemscope itemprop="blogPost">
      


  <section class='meta'>
    
      
      
      <div class="meta" id="header-meta">
        
          
  
    <h1 class="title">
      <a href="/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">
        Java基础面试题总结
      </a>
    </h1>
  


        
        <div class='new-meta-box'>
          
            
          
            
              
<div class='new-meta-item author'>
  <a href="https://enenzhuyi.github.io" rel="nofollow">
    <img src="https://cdn.jsdelivr.net/gh/enenzhuyi/assets@master/img/1589080794804.jpeg">
    <p>enenZhuyi</p>
  </a>
</div>

            
          
            
              
  
  <div class='new-meta-item category'>
    <a href='/categories/%E9%9D%A2%E8%AF%95/' rel="nofollow">
      <i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>
      <p>面试</p>
    </a>
  </div>


            
          
            
              <div class="new-meta-item date">
  <a class='notlink'>
    <i class="fas fa-calendar-alt fa-fw" aria-hidden="true"></i>
    <p>发布于：Apr 19, 2020</p>
  </a>
</div>

            
          
            
              

            
          
            
              
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>10.4k words</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>41 min</p>
    </a>
  </div>


            
          
        </div>
        
          <hr>
        
      </div>
    
  </section>


      <section class="article typo">
        <div class="article-entry" itemprop="articleBody">
          
          <p>总结了自己刷题过程中和网上常见的面试题</p>
<a id="more"></a>

<h2 id="i-和-i"><a href="#i-和-i" class="headerlink" title="i++和++i"></a>i++和++i</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    i = i++;</span><br><span class="line">    <span class="keyword">int</span> j = i++;</span><br><span class="line">    <span class="keyword">int</span> k = i+ ++i * i++;</span><br><span class="line">    System.out.println(i);   </span><br><span class="line">    System.out.println(j);</span><br><span class="line">    System.out.println(k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">11</span><br></pre></td></tr></table></figure>

<p>明确局部变量表和操作数栈两个概念</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在局部变量表里将<code>i</code>的值赋为1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i = i++;</span><br></pre></td></tr></table></figure>

<p>将<code>i</code>的值（1）压入操作数栈，<code>i</code>自增1，变为2。</p>
<p>弹出栈顶元素，将1赋值给<code>i</code>，<code>i</code>变为1。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = i++;</span><br></pre></td></tr></table></figure>

<p>将<code>i</code>的值（1）压入操作数栈，<code>i</code>自增1，变为2。</p>
<p>弹出栈顶元素，将1赋值给<code>j</code>，<code>j</code>变为1.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> k = i+ ++i * i++;</span><br></pre></td></tr></table></figure>

<p>根据运算优先级判断执行顺序</p>
<p>将<code>i</code>的值（2）压入操作数栈</p>
<p><code>i</code>值自增1，变为3，将<code>i</code>的值（3）压入操作数栈</p>
<p>将<code>i</code>的值（3）压入操作数栈，<code>i</code>自增1，变为4</p>
<p>操作数栈弹出两个元素（3，3），进行乘法运算，结果为9，并压入操作数栈</p>
<p>操作数栈弹出两个元素（9，2），进行加法运算，结果为11，并压入操作数栈</p>
<p>操作数栈弹出一个元素（11），赋值给<code>k</code></p>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>Father类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        System.out.print(<span class="string">"(1)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father() &#123;</span><br><span class="line">        System.out.print(<span class="string">"(2)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Father(<span class="keyword">int</span> i) &#123;</span><br><span class="line">        System.out.print(<span class="string">"(2-1)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"(3)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(4)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(5)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Son类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> i = method();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> j = test();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span>  &#123;</span><br><span class="line">        System.out.print(<span class="string">"(6)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Son() &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.print(<span class="string">"(7)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">"(8)"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(9)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"(10)"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(5)(1)(10)(6)(9)(3)(2-1)(9)(8)(7)</span><br><span class="line">(9)(3)(2-1)(9)(8)(7)</span><br></pre></td></tr></table></figure>

<p>Java初始化过程，包括类初始化和实例初始化两部分</p>
<p><strong>类初始化过程</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.main()所在类</span><br><span class="line"></span><br><span class="line">2.子类在初始化前需要先初始化父类</span><br><span class="line"></span><br><span class="line">3.执行&lt;clinit&gt;方法</span><br><span class="line">  静态成员变量赋值和执行静态代码块</span><br><span class="line">  按照自上而下的顺序对静态成员变量赋值和执行静态代码块</span><br><span class="line">  只执行一次</span><br></pre></td></tr></table></figure>

<p><strong>实例初始化</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.执行&lt;init&gt;方法</span><br><span class="line">  非静态变量赋值、执行非静态代码块和构造方法</span><br><span class="line">  按照自上而下的顺序对非静态变量赋值、执行非静态代码块，最后执行构造方法</span><br><span class="line">  子类在执行&lt;init&gt;之前会执行父类的&lt;init&gt;，父类构造方法由子类super()所决定，默认为无参构造</span><br><span class="line">  每次创建都会执行</span><br><span class="line"></span><br><span class="line">2.注意字类的重写方法（多态性）</span><br></pre></td></tr></table></figure>

<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p><img src="https://cdn.jsdelivr.net/gh/enenzhuyi/assets@master/img/3807435_1530271039524_20577AE82E2EC5D6D44DD2CA01C99BBA.png" alt=""></p>
<p>异常分为运行时异常，非运行时异常和error，其中error是系统异常，只能重启系统解决。非运行时异常需要我们自己补获，而运行异常是程序运行时由虚拟机帮助我们补获。运行时异常包括数组的溢出，内存的溢出空指针，分母为0等！</p>
<h2 id="强制性异常与非强制性异常"><a href="#强制性异常与非强制性异常" class="headerlink" title="强制性异常与非强制性异常"></a>强制性异常与非强制性异常</h2><p>java中的异常分为两大类，强制性异常(CheckedException)和非强制性异常(UncheckedException)。而java中除了RuntimeException外，都是强制性异常。</p>
<ul>
<li>强制性异常：所谓强制性异常就是在编写程序的过程中必需在抛出异常的部分try catch 或者向上throws异常。 </li>
<li>非强制性异常：所谓非强制性异常就和上面相反了。不过你当然也可以try catch或者thows，只不过这不是强制性的。 </li>
</ul>
<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ul>
<li>参数列表必须完全与被重写方法的相同；</li>
<li>返回类型必须完全与被重写方法的返回类型相同；</li>
<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>
<li>父类的成员方法只能被它的子类重写。</li>
<li>声明为final的方法不能被重写。</li>
<li>声明为static的方法不能被重写，但是能够被再次声明。</li>
<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>
<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>
<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。</li>
<li>构造方法不能被重写。</li>
<li>如果不能继承这个类，则不能重写这个类的某个方法。</li>
</ul>
<h2 id="方法参数传递，传值or传引用"><a href="#方法参数传递，传值or传引用" class="headerlink" title="方法参数传递，传值or传引用"></a>方法参数传递，传值or传引用</h2><p>调用方法的时候，本质上都是将值COPY一份传递给被调方法。不过，对于基本类型来说，传递的值是其原有值的副本，修改形参不会对原有的值造成影响。对于引用类型来说，传递的值为对象的真实地址，修改形参会对原有的值造成影响。此外，需要注意String、Integer（-128~127）等不可变对象。</p>
<h2 id="变量类型和作用域"><a href="#变量类型和作用域" class="headerlink" title="变量类型和作用域"></a>变量类型和作用域</h2><p>变量类型主要包括局部变量和成员变量。</p>
<p>局部变量保存在方法栈桢中，只能用<code>final</code>关键字进行修饰，作用域为当前<code>{}</code>内。局部变量没有<strong>初始值</strong>，需要进行初始化。</p>
<p>成员变量包括类变量和实例变量，能够被jvm初始化，可以用<code>public</code>、<code>protected</code>、<code>private</code>、<code>static</code>、<code>final</code>、<code>transient</code>、<code>volatile</code>关键字进行修饰。在初始化过程中注意就近原则。</p>
<p>类变量保存在方法区中，作用域为<strong>当前类</strong>。</p>
<p>实例变量保存在堆中，作用域为<strong>当前实例</strong>。</p>
<p>若局部变量和类变量重名，则可以使用<strong>类名.变量名</strong>进行访问。</p>
<p>若局部变量和成员变量重名，则可以使用<strong>this.变量名</strong>进行访问。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><table>
<thead>
<tr>
<th>数据类型</th>
<th>大小/位</th>
<th>包装类</th>
<th>默认值（零值）</th>
<th>可表示数据范围</th>
</tr>
</thead>
<tbody><tr>
<td>byte(字节)</td>
<td>8-bit</td>
<td>Byte</td>
<td>(byte)0</td>
<td>-128~127</td>
</tr>
<tr>
<td>short(短整数)</td>
<td>16-bit</td>
<td>Short</td>
<td>(short)0</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>int(整数)</td>
<td>32-bit</td>
<td>Integer</td>
<td>0</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>long(长整数)</td>
<td>64-bit</td>
<td>Long</td>
<td>0L</td>
<td>-9223372036854775808~9223372036854775807</td>
</tr>
<tr>
<td>float(单精度)</td>
<td>32-bit</td>
<td>Float</td>
<td>0.0F</td>
<td>1.4E-45~3.4028235E38</td>
</tr>
<tr>
<td>double(双精度)</td>
<td>64-bit</td>
<td>Double</td>
<td>0.0D</td>
<td>4.9E-324~1.7976931348623157E308</td>
</tr>
<tr>
<td>boolean</td>
<td></td>
<td>Boolean</td>
<td>flase</td>
<td>true或false</td>
</tr>
<tr>
<td>char(字符)</td>
<td>16-bit</td>
<td>Character</td>
<td>‘\u0000’（对应数字0，输出为空）</td>
<td>0~65535</td>
</tr>
</tbody></table>
<p>第一类：整数类型  byte short int long，byte、short在计算时默认转int</p>
<p>第二类：浮点型  float double</p>
<p>第三类：逻辑型   boolean(它只有两个值可取true false)</p>
<p>第四类：字符型  char</p>
<p>低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte&lt;char&lt;short&lt;int&lt;long&lt;float&lt;double。不同的数据类型不能自动装箱拆箱</p>
<h2 id="枚举成员初始化"><a href="#枚举成员初始化" class="headerlink" title="枚举成员初始化"></a>枚举成员初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> AccountType &#123;</span><br><span class="line">    SAVING, FIXED, CURRENT;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(“It is a account type”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类在后台实现时，实际上是转化为一个继承了java.lang.Enum类的实体类，原先的枚举类型变成对应的实体类型。上例中AccountType变成了个class AccountType，并且会生成一个新的构造函数，若原来有构造函数，则在此基础上添加两个参数，生成新的构造函数，如上例子中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">()</span> </span>&#123; System.out.println(“It is a account type”); &#125;</span><br></pre></td></tr></table></figure>

<p>会变成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AccountType</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(s,i); </span><br><span class="line">	System.out.println(“It is a account type”); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在这个类中，会添加若干字段来代表具体的枚举类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType SAVING;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType FIXED;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AccountType CURRENT;</span><br></pre></td></tr></table></figure>

<p>而且还会添加一段static代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">  SAVING = <span class="keyword">new</span> AccountType(<span class="string">"SAVING"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="comment">//... </span></span><br><span class="line">  CURRENT = <span class="keyword">new</span> AccountType(<span class="string">"CURRENT"</span>, <span class="number">0</span>);</span><br><span class="line">  $VALUES = <span class="keyword">new</span> AccountType[]&#123;</span><br><span class="line">    SAVING, FIXED, CURRENT</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以此来初始化枚举中的每个具体类型。（并将所有具体类型放到一个$VALUE数组中，以便用序号访问具体类型）</p>
<p>在初始化过程中new AccountType构造函数被调用了三次，所以Enum中定义的构造函数中的打印代码被执行了3遍。</p>
<h2 id="ThreadLocal内部真的维护了个map吗？"><a href="#ThreadLocal内部真的维护了个map吗？" class="headerlink" title="ThreadLocal内部真的维护了个map吗？"></a>ThreadLocal内部真的维护了个map吗？</h2><p>ThreadLocal类用于创建一个线程本地变量。在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap，也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。</p>
<p>ThreadLocal的使用场景：</p>
<p>数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点是占用了较多的空间。</p>
<h2 id="public类名与文件名"><a href="#public类名与文件名" class="headerlink" title="public类名与文件名"></a>public类名与文件名</h2><p>一个文件中可以有多个类，如果没有public类，则可以与任意类名相同。如果有public类则文件名必须与此类名相同，因为一个文件中只能有一个public类。如果文件中只有一个类，则文件名必须与类名相同</p>
<h2 id="String拼接"><a href="#String拼接" class="headerlink" title="String拼接"></a>String拼接</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"a"</span>;</span><br><span class="line">String b = <span class="string">"b"</span>;</span><br><span class="line"></span><br><span class="line">String str1 = <span class="string">"a"</span> + <span class="string">"b"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">String str2 = a + b; <span class="comment">//在堆上创建的新的对象   </span></span><br><span class="line">String str3 = <span class="string">"ab"</span>;<span class="comment">//常量池中的对象</span></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//true </span></span><br><span class="line">System.out.println(str2 == str3);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<p>字面量”+”拼接是在编译期间进行的，拼接后的字符串存放在字符串池中。而字符串引用的”+”拼接运算实在运行时进行的，新创建的字符串存放在堆中。</p>
<h2 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern()"></a>String.intern()</h2><blockquote>
<p>Returns a canonical representation for the string object.A pool of strings, initially empty, is maintained privately by the class String.When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> StringBuilder(<span class="string">"go"</span>).append(<span class="string">"od"</span>).toString();</span><br><span class="line">System.out.println(s1.intern() == s1);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">System.out.println(s2.intern() == s2);<span class="comment">// false java字符串会被jvm在启动过程中加载</span></span><br></pre></td></tr></table></figure>

<h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h2><p>&lt;&lt;表示左移位</p>
<p>&gt;&gt;表示带符号右移位</p>
<p>&gt;&gt;&gt;表示无符号右移，左边空出的位以0填充</p>
<h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p>在计算机系统中，数值一律用<strong>补码</strong>来表示（存储）</p>
<p>正数符号位是0，负数符号位是1</p>
<p>正数原码，反码，补码相同</p>
<p>负数反码除了符号位不变，其他位取反，补码=反码+1</p>
<blockquote>
<p><strong>以下</strong> <strong>b</strong> <strong>的值是：</strong> <strong>byte b = (byte)129;</strong></p>
</blockquote>
<p>129为int类型，转byte，被截取为1000 0001。此时1000 0001为截取后所代表数字的补码，要将其转化为原码。</p>
<p><strong>补码：</strong>1000 0001</p>
<p><strong>反码：</strong>1000 0000</p>
<p><strong>原码：</strong>1111 1111</p>
<p>b=-127</p>
<blockquote>
<p>执行如下程序代码</p>
<p>char chr = 127;</p>
<p>int sum = 200;</p>
<p>chr += 1;</p>
<p>sum += chr;</p>
<p>后，sum的值是  ; （   ）</p>
<p>备注：同时考虑c/c++和Java的情况的话</p>
</blockquote>
<p>Java中byte占一个字节，char占两个字节, 所以对于Java来说127不会发生溢出，输出328</p>
<p>但是对于c/c++语言来说，char占一个字节, 会发生溢出，对127加一发生溢出，0111 1111 –&gt; 1000 0000, 1000 0000为补码-128，所以结果为200-128=72</p>
<h2 id="泛型PECS原则"><a href="#泛型PECS原则" class="headerlink" title="泛型PECS原则"></a>泛型PECS原则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 只看尖括号里边的！！明确点和范围两个概念</span><br><span class="line">2. 如果尖括号里的是一个类，那么尖括号里的就是一个点，比如List&lt;A&gt;，List&lt;B&gt;，List&lt;Object&gt;</span><br><span class="line">3. 如果尖括号里面带有问号，那么代表一个范围，&lt;? extends A&gt; 代表小于等于A的范围，&lt;? super A&gt;代表大于等于A的范围，&lt;?&gt;代表全部范围</span><br><span class="line">4. 尖括号里的所有点之间互相赋值都是错，除非是俩相同的点</span><br><span class="line">5. 尖括号小范围赋值给大范围，对；大范围赋值给小范围，错。如果某点包含在某个范围里，那么可以赋值。否则，不能赋值</span><br><span class="line">6. List&lt;?&gt;和List 是相等的，都代表最大范围</span><br><span class="line">7. List既是点也是范围，当表示范围时，表示最大范围</span><br></pre></td></tr></table></figure>

<p><strong>具体实例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;A&gt; a;</span><br><span class="line">    List list;</span><br><span class="line">    list = a;   <span class="comment">//对，因为List就是List&lt;?&gt;，代表最大的范围，A只是其中的一个点，肯定被包含在内</span></span><br><span class="line">    List&lt;B&gt; b;</span><br><span class="line">    a = b;      <span class="comment">//错，点之间不能相互赋值</span></span><br><span class="line">    List&lt;?&gt; qm;</span><br><span class="line">    List&lt;Object&gt; o;</span><br><span class="line">    qm = o;     <span class="comment">//对，List&lt;?&gt;代表最大的范围，List&lt;Object&gt;只是一个点，肯定被包含在内</span></span><br><span class="line">    List&lt;D&gt; d;</span><br><span class="line">    List&lt;? extends B&gt; downB;</span><br><span class="line">    downB = d;  <span class="comment">//对，List&lt;? extends B&gt;代表小于等于B的范围，List&lt;D&gt;是一个点，在其中</span></span><br><span class="line">    List&lt;?extends A&gt; downA;</span><br><span class="line">    a = downA;  <span class="comment">//错，范围不能赋值给点</span></span><br><span class="line">    a = o;      <span class="comment">//错，List&lt;Object&gt;只是一个点</span></span><br><span class="line">    downA = downB;  <span class="comment">//对，小于等于A的范围包含小于等于B的范围，因为B本来就比A小，B时A的子类嘛</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="最终类（final类、不可变类）"><a href="#最终类（final类、不可变类）" class="headerlink" title="最终类（final类、不可变类）"></a>最终类（final类、不可变类）</h2><p>最终类就是被final修饰的类，最终方法就是被final修饰的方法。最终类不能被继承，最终方法不能被重写。</p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li><p>数字，字母，符号（只有_和$两种），数字不能开头。</p>
</li>
<li><p>不能是关键字及两个保留关键字（goto，const）或者显式常量（null，true，false）。</p>
</li>
</ul>
<h2 id="关键字（keywords）"><a href="#关键字（keywords）" class="headerlink" title="关键字（keywords）"></a>关键字（keywords）</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">abstract class    extends implements null      strictfp     true</span><br><span class="line">assert   const    false   import     package   super        try</span><br><span class="line">boolean  continue final   instanceof private   switch       void</span><br><span class="line">break    default  finally int        protected synchronized volatile</span><br><span class="line">byte     do       float   interface  public    this         while</span><br><span class="line">case     double   for     long       return    throw</span><br><span class="line">catch    else     goto    native     short     throws</span><br><span class="line">char     enum     if      new        static    transient</span><br></pre></td></tr></table></figure>

<h2 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">byValue cast const false future generic goto inner null operator outer rest true var</span><br></pre></td></tr></table></figure>

<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul>
<li><p>普通的类方法是可以和类名同名的，和构造方法唯一的区分就是，构造方法没有返回值。</p>
</li>
<li><p>构造函数不能被继承，构造方法只能被显式或隐式的调用。</p>
</li>
</ul>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>[://] 表示匹配 :// 中的任何一个字符，也就是匹配 : 或 /</p>
<p>[htps] 表示匹配 htps 中的任何一个字符，[htps]+ 表示一次或多次匹配前面的字符或子表达式，所以 [htps]+ 可以匹配 https</p>
<h2 id="a的b次幂"><a href="#a的b次幂" class="headerlink" title="a的b次幂"></a>a的b次幂</h2><p>Math类中的一个静态方法 ： pow(double a, double b)</p>
<p>^表示异或，就是相同是0，不同是1</p>
<h2 id="getClass"><a href="#getClass" class="headerlink" title="getClass"></a>getClass</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test07;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperTest</span> <span class="keyword">extends</span> <span class="title">Date</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[]args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SuperTest().test();<span class="comment">//test07.SuperTest</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>TestSuper和Date的getClass都没有重写，他们都是调用Object的getClass，而Object的getClass作用是返回的是运行时的类的名字。这个运行时的类就是当前类，所以super.getClass().getName()返回的是test07.SuperTest，与Date类无关。要返回Date类的名字需要写super.getClass().getSuperclass()</p>
<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    split(<span class="number">12</span>);<span class="comment">//12136</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (number % <span class="number">2</span> != <span class="number">0</span>) System.out.print(split((number + <span class="number">1</span>) / <span class="number">2</span>));</span><br><span class="line">      System.out.print(split(number / <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> number;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析过程，伪代码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sout split(6) &#x3D; &#123;</span><br><span class="line">    sout split(3) &#x3D; &#123;</span><br><span class="line">        sout split(2) &#x3D; &#123;</span><br><span class="line">            sout split(1)</span><br><span class="line">            return 2</span><br><span class="line">        &#125;</span><br><span class="line">        sout split(1)</span><br><span class="line">        return 3;</span><br><span class="line">    &#125;</span><br><span class="line">    return 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><ol>
<li><p>接口中属性为public static final，方法为public abstract，接口中不可以有构造方法。</p>
</li>
<li><p>抽象类可以有构造方法,只是不能直接创建抽象类的实例对象而已</p>
</li>
<li><p>Java不允许类多重继承</p>
</li>
<li><p>jdk1.8后接口中的方法可以有方法体，jdk1.8之前不可以有方法体</p>
</li>
</ol>
<h3 id="线程停止方法"><a href="#线程停止方法" class="headerlink" title="线程停止方法"></a>线程停止方法</h3><p>sleep让线程休眠，yield让运行中的线程回到就绪状态，synchronized只是同步阻塞，让线程进入对象的阻塞队列</p>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><ol>
<li>静态初始化</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<p>需要<strong>注意</strong>的是，写成如下形式是<strong>错误</strong>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h3><ul>
<li>被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；</li>
<li>被重载的方法可以改变返回类型；</li>
<li>被重载的方法可以改变访问修饰符；</li>
<li>被重载的方法可以声明新的或更广的检查异常；</li>
<li>方法能够在同一个类中或者在一个子类中被重载。</li>
<li>无法以返回值类型作为重载函数的区分标准。</li>
</ul>
<h3 id="类之间关系"><a href="#类之间关系" class="headerlink" title="类之间关系"></a>类之间关系</h3><p><strong>USES-A：</strong>依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。</p>
<p><strong>关联关系：</strong>A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。</p>
<p><strong>HAS-A：</strong>聚合关系，拥有关系，是<strong>关联关系</strong>的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。</p>
<p><strong>IS-A：</strong>表示继承。父类与子类，这个就不解释了。</p>
<p>要注意：还有一种关系：<strong>组合关系</strong>也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。</p>
<h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f[][] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> []f[] = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> f[][] = <span class="keyword">new</span> <span class="keyword">float</span>[][<span class="number">6</span>];<span class="comment">//error</span></span><br><span class="line"><span class="keyword">float</span> [][]f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line"><span class="keyword">float</span> [][]f = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">6</span>][];</span><br></pre></td></tr></table></figure>

<p>数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值，它代表的是在该二维数组中有多少个一维数组。</p>
<h3 id="字符编码和国际化"><a href="#字符编码和国际化" class="headerlink" title="字符编码和国际化"></a>字符编码和国际化</h3><ol>
<li>Java一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节。</li>
<li>不同的编码之间是可以转换的，通常流程如下：将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串。</li>
</ol>
<p>例：String newUTF8Str = new String(oldGBKStr.getBytes(“GBK”), “UTF8”);</p>
<ol start="3">
<li>Java虚拟机中通常使用UTF-16的方式保存一个字符（char）</li>
<li>ResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的。</li>
</ol>
<h3 id="虚函数和纯虚函数"><a href="#虚函数和纯虚函数" class="headerlink" title="虚函数和纯虚函数"></a>虚函数和纯虚函数</h3><ol>
<li><p>虚函数的存在是为了多态。Java中其实没有虚函数的概念，它的<strong>普通函数</strong>就相当于<strong>C++的虚函数</strong>，动态绑定是Java的默认行为。如果Java中不希望某个函数具有虚函数特性，可以加上<strong>final关键字</strong>变成<strong>非虚函数</strong>。</p>
</li>
<li><p>抽象函数或者说是纯虚函数的存在是为了定义接口。Java中纯虚函数形式为：abstract void print();</p>
</li>
</ol>
<h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer i01=<span class="number">59</span>;</span><br><span class="line"><span class="keyword">int</span> i02=<span class="number">59</span>;</span><br><span class="line">Integer i03=Integer.valueOf(<span class="number">59</span>);</span><br><span class="line">Integer i04=<span class="keyword">new</span> Integer(<span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(i01==i02);<span class="comment">//true</span></span><br><span class="line">System.out.println(i01==i03);<span class="comment">//true</span></span><br><span class="line">System.out.println(i03==i04);<span class="comment">//false</span></span><br><span class="line">System.out.println(i02==i04);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<ol>
<li>无论如何，Integer=xxx与new Integer不会相等，不会经历拆箱过程</li>
<li>两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false。例如，java在编译Integer i2 = 128的时候，被翻译成-&gt; Integer i2 = Integer.valueOf(128); 而valueOf()函数会对-128到127之间的数进行缓存</li>
<li>两个都是new出来的,都为false</li>
<li>int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比</li>
</ol>
<h3 id="Thread-join"><a href="#Thread-join" class="headerlink" title="Thread.join()"></a>Thread.join()</h3><blockquote>
<p>例题：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">	Thread t=<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.print(<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">     </span><br><span class="line">    t.join();</span><br><span class="line">    System.out.print(<span class="string">"1"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为子线程的休眠时间太长，因此主线程很有可能在子线程之前结束也就是输出结果是12，但是子线程用了join函数，因此主线程必须等待子线程执行完毕才结束因此输出结果只能是21</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t.join();      <span class="comment">//使调用线程 t 在此之前执行完毕。</span></span><br><span class="line">t.join(<span class="number">1000</span>);  <span class="comment">//等待 t 线程，等待时间是1000毫秒</span></span><br></pre></td></tr></table></figure>

<h3 id="常见的锁"><a href="#常见的锁" class="headerlink" title="常见的锁"></a>常见的锁</h3><ol>
<li><p>自旋锁 ,自旋，jvm默认是10次吧，有jvm自己控制。for去争取锁</p>
</li>
<li><p>阻塞锁 被阻塞的线程，不会争夺锁。</p>
</li>
<li><p>可重入锁 多次进入改锁的域</p>
</li>
<li><p>读写锁</p>
</li>
<li><p>互斥锁 锁本身就是互斥的</p>
</li>
<li><p>悲观锁 不相信，这里会是安全的，必须全部上锁</p>
</li>
<li><p>乐观锁 相信，这里是安全的。</p>
</li>
<li><p>公平锁 有优先级的锁</p>
</li>
<li><p>非公平锁 无优先级的锁</p>
</li>
<li><p>偏向锁 无竞争不锁，有竞争挂起，转为轻量锁</p>
</li>
<li><p>对象锁 锁住对象</p>
</li>
<li><p>线程锁</p>
</li>
<li><p>锁粗化 多锁变成一个，自己处理</p>
</li>
<li><p>轻量级锁 CAS 实现</p>
</li>
<li><p>锁消除 偏向锁就是锁消除的一种</p>
</li>
<li><p>锁膨胀 jvm实现，锁粗化</p>
</li>
<li><p>信号量 使用阻塞锁 实现的一种策略</p>
</li>
<li><p>排它锁：X锁，若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。</p>
</li>
</ol>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ol>
<li><p>包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱</p>
</li>
<li><p>包装类的equals()方法不处理数据转型</p>
</li>
</ol>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ol>
<li><p>&amp; 与操作</p>
</li>
<li><p>| 或操作</p>
</li>
<li><p>! 非操作</p>
</li>
<li><p>~ 取反操作</p>
</li>
</ol>
<h3 id="hashCode和equals"><a href="#hashCode和equals" class="headerlink" title="hashCode和equals"></a>hashCode和equals</h3><p>hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。</p>
<p><strong><em>那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？</em></strong>因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</p>
<p><strong><em>那么hashCode()既然效率这么高为什么还要equals()呢？</em></strong> 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。</p>
<p><strong><em>所以我们可以得出：</em></strong></p>
<ol>
<li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</p>
</li>
<li><p>hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p>
</li>
</ol>
<p>所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低。所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）。如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p>
<h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><blockquote>
<p>列题：</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="string">"1314520"</span>;</span><br><span class="line">    <span class="keyword">int</span> v1 = <span class="number">0</span>, v2 = <span class="number">0</span>, v3 = <span class="number">0</span>, v4 =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i]) &#123;</span><br><span class="line">            <span class="keyword">default</span>: v4++;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'1'</span>: v1++;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'2'</span>: v2++;</span><br><span class="line">            cas3 <span class="string">'3'</span>: v3++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d, %d, %d"</span>, v4,v1,v2,v3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>result：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3567</span><br></pre></td></tr></table></figure>

<p>default顾名思义是缺省情况，只有任何条件都不匹配的情况下才会执行，故会匹配到s[i]为‘4’，‘5’，‘0’ 的情况。于是v4++三次，v4=3。并且这个default后没有使用break语句，于是case‘1’、‘2’、‘3’都会执行三次。注意到所有语句都没有加break，则语句执行过之后会继续下面的case语句。另外由于s[i]中有两个1，故v1,v2,v3此时为5.另外有一个2，v2,v3++后为6，还有一个case3 于是v3++.最终v3为7。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ol>
<li>数组是一个对象，不同类型的数组具有不同的类</li>
<li>数组是一个连续的存储结构</li>
<li>可以二维数组，且可以有多维数组，都是在Java中合法的</li>
<li>查看源码可以知道数组的equals方法是object的equals，比较的是内存地址</li>
</ol>
<h3 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h3><p>一个字符常量表示为一个字符或一个转义序列，被一对ASCII<strong>单引号</strong>关闭。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ol>
<li>Class类位于java.lang包下。Method, Filed等类位于java.lang.reflet包下</li>
</ol>
<h3 id="导致InterruptedException异常"><a href="#导致InterruptedException异常" class="headerlink" title="导致InterruptedException异常"></a>导致InterruptedException异常</h3><ol>
<li>java.lang.Object 类的 wait 方法</li>
<li>java.lang.Thread 类的 sleep 方法</li>
<li>java.lang.Thread 类的 join 方法</li>
</ol>
<h3 id="汉字长度"><a href="#汉字长度" class="headerlink" title="汉字长度"></a>汉字长度</h3><p>java的String底层是char数组，它的length()返回数组大小。一个汉字等于一个字符（char），一个汉字也等于二个字节（byte）。</p>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ol>
<li>Bootstrap ClassLoader，主要加载JVM自身工作需要的类。</li>
<li>Extension ClassLoader，主要加载%JAVA_HOME%\lib\ext目录下的库类。</li>
<li>Application ClassLoader，主要加载Classpath指定的库类，一般情况下这是程序中的默认类加载器，也是<strong>ClassLoader.getSystemClassLoader()</strong> 的返回值。（这里的Classpath默认指的是环境变量中配置的Classpath，但是可以在执行Java命令的时候使用-cp 参数来修改当前程序使用的Classpath）</li>
<li>JVM类加载机制为<strong>双亲委托模型</strong>。如此，因此所有的类加载请求最终都应该传送到顶层的<strong>Bootstrap ClassLoader</strong>中，只有当父加载器反馈自己无法完成加载请求时，子加载器才会尝试自己加载。<strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</strong>双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。</li>
</ol>
<h3 id="自动装箱"><a href="#自动装箱" class="headerlink" title="自动装箱"></a>自动装箱</h3><ol>
<li>不同的数据类型不能自动装箱拆箱</li>
</ol>
<h3 id="jdk命令"><a href="#jdk命令" class="headerlink" title="jdk命令"></a>jdk命令</h3><ol>
<li><p>jps：查看本机java进程信息。</p>
</li>
<li><p>jstack：打印线程的<strong>栈</strong>信息，制作线程dump文件。</p>
</li>
<li><p>jmap：打印内存映射，制作<strong>堆</strong>dump文件</p>
</li>
<li><p>jstat：性能监控工具</p>
</li>
<li><p>jhat：内存分析工具</p>
</li>
<li><p>jconsole：简易的可视化控制台</p>
</li>
<li><p>jvisualvm：功能强大的控制台</p>
</li>
</ol>
<p>java、javac、jar等开发工具是用Java编写的。</p>
<h3 id="static属性和方法"><a href="#static属性和方法" class="headerlink" title="static属性和方法"></a>static属性和方法</h3><blockquote>
<p>例题：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        Test test=<span class="keyword">null</span>;</span><br><span class="line">        test.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>result：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能编译通过，并正确运行</span><br></pre></td></tr></table></figure>

<p>静态方法属于静态绑定，编译器根据引用类型所属的静态类型为它绑定其对应的方法。此语句会翻译成invokestatic，该指令的调用中不会涉及this,所以不会依赖对象！ 还有引用类型=null，其实就是指该引用在堆中没有对应的对象，但是编译的时候还是能根据声明找到其所属的静态类型。</p>
<h3 id="存根类"><a href="#存根类" class="headerlink" title="存根类"></a>存根类</h3><p>存根类是一个类，它实现了一个接口，它的作用是：如果一个接口有很多方法，如果要实现这个接口，就要实现所有的方法。但是一个类从业务来说，可能只需要其中一两个方法。如果直接去实现这个接口，除了实现所需的方法，还要实现其他所有的无关方法。而如果通过继承存根类就实现接口，就免去了这种麻烦。</p>
<blockquote>
<p>dubbo远程调用可以有这么一个本地存根，场景是：用户要远程调用资源进行登录页面才能访问资源，但是无论登录成功还是不成功都得远程调用，这样就浪费了资源，所以我们就把验证这部分工作放在本地执行（本地存根），当用户验证（验证码等）工作放在本地，stub存根决定是否远程调用，也就是动态链接（动态连接使得大部分的连接过程延迟,直到程序开始运行）。</p>
</blockquote>
<h3 id="static与重载"><a href="#static与重载" class="headerlink" title="static与重载"></a>static与重载</h3><blockquote>
<p>例题：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Collection&lt;?&gt;[] collections = </span><br><span class="line">		&#123;<span class="keyword">new</span> HashSet&lt;String&gt;(), <span class="keyword">new</span> ArrayList&lt;String&gt;(), <span class="keyword">new</span> HashMap&lt;String, String&gt;().values();</span><br><span class="line">	Super subToSuper = <span class="keyword">new</span> Sub();</span><br><span class="line">	<span class="keyword">for</span> (Collection&lt;?&gt; collection: collections) &#123;</span><br><span class="line">		System.out.println(subToSuper.getType(collection));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Super:collection”;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Super:list”;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(ArrayList&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Super:arrayList”;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Set&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Super:set”;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">(HashSet&lt;?&gt; set)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> “Super:hashSet”;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getType</span><span class="params">(Collection&lt;?&gt; collection)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Sub"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<ol>
<li>重载静态多分派——根据传入重载方法的参数类型，选择更加合适的一个重载方法</li>
<li>static方法不能被子类覆写，在子类中定义了和父类完全相同的static方法，则父类的static方法被隐藏，Son.staticmethod()或new Son().staticmethod()都是调用的子类的static方法，如果是Father.staticmethod()或者Father f = new Son(); f.staticmethod()调用的都是父类的static方法。</li>
<li>此题如果都不是static方法，则最终的结果是A. 调用子类的getType，输出collection</li>
</ol>
<h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>( )　[ ] 　.</td>
<td>从左到右</td>
</tr>
<tr>
<td>2</td>
<td>! 　~　 ++　 –</td>
<td>从右到左</td>
</tr>
<tr>
<td>3</td>
<td>*　 /　 %</td>
<td>从左到右</td>
</tr>
<tr>
<td>4</td>
<td>+　 -</td>
<td>从左到右</td>
</tr>
<tr>
<td>5</td>
<td>&lt;&lt; 　&gt;&gt;　 &gt;&gt;&gt;</td>
<td>从左到右</td>
</tr>
<tr>
<td>6</td>
<td>&lt; 　&lt;=　 &gt; 　&gt;=　 instanceof</td>
<td>从左到右</td>
</tr>
<tr>
<td>7</td>
<td>== 　!=</td>
<td>从左到右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左到右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左到右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左到右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左到右</td>
</tr>
<tr>
<td>13</td>
<td>? :</td>
<td>从左到右</td>
</tr>
<tr>
<td>14</td>
<td>= 　+= 　-= 　*=　 /=　 %=　 &amp;=   |=   ^=　 ~= 　&lt;&lt;= 　&gt;&gt;=　 &gt;&gt;&gt;=</td>
<td>从右到左</td>
</tr>
<tr>
<td>15</td>
<td>,</td>
<td>从右到左</td>
</tr>
</tbody></table>
<p>当多个运算符出现在一个表达式中，谁的优先级别高，就先执行谁。在一个多运算符的表达式中，运算符优先级不同会导致最后得出的结果完全不一样。</p>
<blockquote>
<p>例题</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complicatedexpression_r</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> x=<span class="number">20</span>, y=<span class="number">30</span>;</span><br><span class="line">	Boolean b;</span><br><span class="line">	b = x &gt; <span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &gt; <span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &gt; <span class="number">60</span> || x &lt; -<span class="number">50</span> &amp;&amp; y &lt; -<span class="number">60</span>;</span><br><span class="line">	System.out.println(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>题中符号的优先级排序是：’&gt;’，’&lt;’，’&amp;&amp;’，’||’。</p>
<p><strong>即：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b=(x&gt;<span class="number">50</span>&amp;&amp;y&gt;<span class="number">60</span>)||(x&gt;<span class="number">50</span>&amp;&amp;y&lt;-<span class="number">60</span>)||(x&lt;-<span class="number">50</span>&amp;&amp;y&gt;<span class="number">60</span>)||(x&lt;-<span class="number">50</span>&amp;&amp;y&lt;-<span class="number">60</span>);</span><br></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">false</span><br></pre></td></tr></table></figure>

<h3 id="Java体系结构"><a href="#Java体系结构" class="headerlink" title="Java体系结构"></a>Java体系结构</h3><ul>
<li>Java程序设计语言</li>
<li>Java.class文件格式</li>
<li>Java应用编程接口（API）</li>
<li>Java虚拟机</li>
</ul>
<h3 id="Java不可被继承的类"><a href="#Java不可被继承的类" class="headerlink" title="Java不可被继承的类"></a>Java不可被继承的类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public final class Byte</span><br><span class="line"></span><br><span class="line">public final class Character</span><br><span class="line"></span><br><span class="line">public static final class Character.UnicodeBlock</span><br><span class="line"></span><br><span class="line">public final class Class&lt;T&gt;</span><br><span class="line"></span><br><span class="line">public final class Compile</span><br><span class="line"></span><br><span class="line">public final class Double</span><br><span class="line"></span><br><span class="line">public final class Float</span><br><span class="line"></span><br><span class="line">public final class Integer</span><br><span class="line"></span><br><span class="line">public final class Long</span><br><span class="line"></span><br><span class="line">public final class Math</span><br><span class="line"></span><br><span class="line">public final class ProcessBuilder</span><br><span class="line"></span><br><span class="line">public final class RuntimePermission</span><br><span class="line"></span><br><span class="line">public final class Short</span><br><span class="line"></span><br><span class="line">public final class StackTraceElement</span><br><span class="line"></span><br><span class="line">public final class StrictMath</span><br><span class="line"></span><br><span class="line">public final class String</span><br><span class="line"></span><br><span class="line">public final class StringBuffer</span><br><span class="line"></span><br><span class="line">public final class StringBuilder</span><br><span class="line"></span><br><span class="line">public final class System</span><br><span class="line"></span><br><span class="line">public final class Void</span><br></pre></td></tr></table></figure>



<h3 id="四舍五入"><a href="#四舍五入" class="headerlink" title="四舍五入"></a>四舍五入</h3><p>Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加0.5然后进行下取整。</p>
<h3 id="switch作用选择"><a href="#switch作用选择" class="headerlink" title="switch作用选择"></a>switch作用选择</h3><p>在Java 5以前，switch(expr)中，expr只能是byte、short、char、int；从Java 5开始，Java中引入了枚举类型，expr也可以是enum类型；从Java 7开始，expr还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。</p>
<h3 id="位运算提高计算性能"><a href="#位运算提高计算性能" class="headerlink" title="位运算提高计算性能"></a>位运算提高计算性能</h3><p>2 &lt;&lt; 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。</p>
<blockquote>
<p>补充：我们为编写的类重写hashCode方法时，可能会看到如下所示的代码，其实我们不太理解为什么要使用这样的乘法运算来产生哈希码（散列码），而且为什么这个数是个素数，为什么通常选择31这个数？前两个问题的答案你可以自己百度一下，选择31是因为可以用移位和减法运算来代替乘法，从而得到更好的性能。说到这里你可能已经想到了：31 * num 等价于(num &lt;&lt; 5) - num，左移5位相当于乘以2的5次方再减去自身就相当于乘以31，现在的VM都能自动完成这个优化。</p>
</blockquote>
<h3 id="描述一下JVM加载class文件的原理机制？"><a href="#描述一下JVM加载class文件的原理机制？" class="headerlink" title="描述一下JVM加载class文件的原理机制？"></a>描述一下JVM加载class文件的原理机制？</h3><p>​    JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。<br>​    由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1) 如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2) 如果类中存在初始化语句，就依次执行这些初始化语句。</p>
<p>​    类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。从Java 2（JDK 1.2）开始，类加载过程采取了父亲委托机制（PDM）。PDM更好的保证了Java平台的安全性，在该机制中，JVM自带的Bootstrap是根加载器，其他的加载器都有且仅有一个父类加载器。类的加载首先请求父类加载器加载，父类加载器无能为力时才由其子类加载器自行加载。JVM不会向Java程序提供对Bootstrap的引用。下面是关于几个类加载器的说明：</p>
<blockquote>
<p>Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）；<br>Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap；<br>System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。</p>
</blockquote>
<h3 id="静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？"><a href="#静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？" class="headerlink" title="静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？"></a>静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Inner(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">new</span> Inner(); </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意</strong>：Java中非静态内部类对象的创建要依赖其外部类对象，上面的面试题中foo和main方法都是静态方法，静态方法中没有this，也就是说没有所谓的外部类对象，因此无法创建内部类对象，如果要在静态方法中创建内部类对象，可以这样做：new Outer().new Inner();</p>
</blockquote>
<h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p><img src="https://cdn.jsdelivr.net/gh/qianxiaoxinrou/assets@master/img/327715682_1562312226456_ACED241801E307EE7A39612F85A94EBF.png" alt=""></p>
<h2 id="jvm"><a href="#jvm" class="headerlink" title="jvm"></a>jvm</h2><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将内存按8:1:1分成一块Eden和两小块Survivor区，每次将Eden和Survivor中存活的对象复制到另一块空闲的Survivor中。这三块区域并不是堆的全部，而是构成了<strong>新生代</strong>。</p>
<p>如果回收时，空闲的那一小块Survivor不够用了怎么办？这就是<strong>老年代</strong>的用处。当不够用时，这些对象将直接通过<strong>分配担保</strong>机制进入老年代。那么老年代也使用标记-复制策略吧？当然不行！老年代中的对象可不像新生代中的，每次回收都会清除掉大部分。如果贸然采用复制的策略，老年代的回收效率可想而知。</p>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>在JDK1.8之前<strong>运行时常量池</strong>被放在方法区,属于线程共享,JDK1.8之后,元空间取代了方法区,<strong>运行时常量池</strong>被也被放在元空间中,<strong>运行时常池</strong> 主要存放, class文件元信息描述,编译后的代码，引用类型数据，类文件常量池。所谓的运行时常量池其实就是将编译后的类信息放入运行时的一个区域中，用来动态获取类信息。<strong>运行时常量池</strong>是在类加载完成之后，将每个class常量池中的符号引用值转存到<strong>运行时常量池</strong>中，也就是说，每个class都有一个<strong>运行时常量池</strong>，类在解析之后，将符号引用替换成直接引用，与全局常量池中的引用值保持一致。</p>
<p><strong>运行时常量池</strong>是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p>
<h3 id="CMS的GC过程"><a href="#CMS的GC过程" class="headerlink" title="CMS的GC过程"></a>CMS的GC过程</h3><ol>
<li>初始标记:暂停用户线程，对引用进行遍历并标记</li>
<li>并发标记：在并发情况下，遍历除1中标记过的线程并标记</li>
<li>并发预清理：并发情况下对以上的标记进行清理</li>
<li>重标记：由于3过程是并发的，可能会产生一些引用，所以需要暂停用户线程重新标记</li>
<li>并发清理：清理4过程产生的标记</li>
<li>并发重置：做一些收尾工作</li>
</ol>
<h3 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h3><p>Xms 起始内存</p>
<p>Xmx 最大内存</p>
<p>Xmn 新生代内存</p>
<p>Xss 栈大小。 就是创建线程后，分配给每一个线程的内存大小</p>
<p>-XX:NewRatio=n:设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4</p>
<p>-XX:SurvivorRatio=n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。其中 Eden 和 Survivor 区的比例默认是 8:1:1。</p>
<p>-XX:MaxPermSize=n:设置持久代大小</p>
<p>收集器设置<br>-XX:+UseSerialGC:设置串行收集器<br>-XX:+UseParallelGC:设置并行收集器<br>-XX:+UseParalledlOldGC:设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC:设置并发收集器<br>垃圾回收统计信息<br>-XX:+PrintGC<br>-XX:+PrintGCDetails<br>-XX:+PrintGCTimeStamps<br>-Xloggc:filename<br>并行收集器设置<br>-XX:ParallelGCThreads=n:设置并行收集器收集时使用的CPU数。并行收集线程数。<br>-XX:MaxGCPauseMillis=n:设置并行收集最大暂停时间<br>-XX:GCTimeRatio=n:设置垃圾回收时间占程序运行时间的百分比。公式为1/(1+n)<br>并发收集器设置<br>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况。<br>-XX:ParallelGCThreads=n:设置并发收集器年轻代收集方式为并行收集时，使用的CPU数。并行收集线程数。</p>
<blockquote>
<p>假如某个JAVA进程的JVM参数配置如下：<br>-Xms1G -Xmx2G -Xmn500M -XX:MaxPermSize=64M -XX:+UseConcMarkSweepGC -XX:SurvivorRatio=3,<br>请问eden区最终分配的大小是多少？</p>
</blockquote>
<p>故该题为500*（3/5）=300M</p>
<h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><h3 id="Cookie的获取方式"><a href="#Cookie的获取方式" class="headerlink" title="Cookie的获取方式"></a>Cookie的获取方式</h3><p>request.getCookies</p>
<p>返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。</p>
<p>request.getHeader</p>
<p>以字符串形式返回指定的请求头的值。Cookie也是头的一种；</p>
<h3 id="request-属性参数"><a href="#request-属性参数" class="headerlink" title="request 属性参数"></a>request 属性参数</h3><p>request.getAttribute()方法返回request范围内存在的对象，而request.getParameter()方法是获取http提交过来的数据。getAttribute是返回对象,getParameter返回字符串。</p>
<h3 id="HttpSessionAttributeListener"><a href="#HttpSessionAttributeListener" class="headerlink" title="HttpSessionAttributeListener"></a>HttpSessionAttributeListener</h3><p>可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知</p>
<h3 id="forward和redirect区别"><a href="#forward和redirect区别" class="headerlink" title="forward和redirect区别"></a>forward和redirect区别</h3><ol>
<li>从地址栏显示来说</li>
</ol>
<p>forward是服务器请求资源，服务器直接访问目标地址的URL，把那个URL的响应内容读取过来，然后把这些内容再发给浏览器。浏览器根本不知道服务器发送的内容从哪里来的，所以它的地址栏还是原来的地址。</p>
<p>redirect是服务端根据逻辑，发送一个状态码,告诉浏览器重新去请求那个地址，所以地址栏显示的是新的URL。</p>
<ol start="2">
<li>从数据共享来说</li>
</ol>
<p>forward：转发页面和转发到的页面可以共享request里面的数据。</p>
<p>redirect：不能共享数据。</p>
<ol start="3">
<li>从运用地方来说</li>
</ol>
<p>forward：一般用于用户登陆的时候,根据角色转发到相应的模块。</p>
<p>redirect：一般用于用户注销登陆时返回主页面和跳转到其它的网站等。</p>
<ol start="4">
<li>从效率来说</li>
</ol>
<p>forward：高。</p>
<p>redirect：低。</p>

          
            <br>
            
              
  
    
    



  

  
    
    



  

  
    
    

<section class="widget copyright  desktop mobile">
  <div class='content'>
    
      <blockquote>
        
          
            <p>博客内容遵循 署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</p>

          
        
          
            <p>本文永久链接是：<a href=https://enenzhuyi.github.io/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/>https://enenzhuyi.github.io/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a></p>
          
        
      </blockquote>
    
  </div>
</section>

  

  
    
    

<section class="widget qrcode  desktop mobile">
  

  <div class='content article-entry'>
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
      
        <div class='fancybox'><img src='https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/qrcode/wiki_volantis.png'
        
          height='64px'
        ></div>
      
    
  </div>
</section>

  


            
          
        </div>
        
          


  <section class='meta' id="footer-meta">
    <div class='new-meta-box'>
      
        
          <div class="new-meta-item date" itemprop="dateUpdated" datetime="2020-05-12T10:05:04+08:00">
  <a class='notlink'>
    <i class="fas fa-edit fa-fw" aria-hidden="true"></i>
    <p>更新于：May 12, 2020</p>
  </a>
</div>

        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java%E9%9D%A2%E8%AF%95/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Java面试</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i><p>Java</p></a></div>


        
      
        
          

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer"
          
          href="http://connect.qq.com/widget/shareqq/index.html?url=https://enenzhuyi.github.io/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/&title=Java基础面试题总结 - enenZhuyi's日常随笔&summary=总结了自己刷题过程中和网上常见的面试题"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qq.png">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer"
          
          href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=https://enenzhuyi.github.io/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/&title=Java基础面试题总结 - enenZhuyi's日常随笔&summary=总结了自己刷题过程中和网上常见的面试题"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/qzone.png">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer"
          
          href="http://service.weibo.com/share/share.php?url=https://enenzhuyi.github.io/2020/04/19/Java%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/&title=Java基础面试题总结 - enenZhuyi's日常随笔&summary=总结了自己刷题过程中和网上常见的面试题"
          
          >
          
            <img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets/logo/128/weibo.png">
          
        </a>
      
    
  </div>
</div>



        
      
        
          
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fas fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>10.4k words</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fas fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>41 min</p>
    </a>
  </div>


        
      
    </div>
  </section>


        
        
          <div class="prev-next">
            
              <a class='prev' href='/2020/04/29/MyBatis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/'>
                <p class='title'><i class="fas fa-chevron-left" aria-hidden="true"></i>MyBatis面试题总结</p>
                <p class='content'>总结了自己刷题过程中和网上常见的面试题


实体对象与数据库字段名不一致，怎么办？
sql语句中使用别名
MyBatis开启驼峰命名规则
在映射文件中自定义ResultMap来映射字段名和实体类...</p>
              </a>
            
            
              <a class='next' href='/2020/04/19/CentOS7-%E5%AE%89%E8%A3%85-docker-%E5%92%8C-docker-compose-shell-%E8%84%9A%E6%9C%AC%E5%88%9D%E6%AC%A1%E5%B0%9D%E8%AF%95/'>
                <p class='title'>CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试<i class="fas fa-chevron-right" aria-hidden="true"></i></p>
                <p class='content'>CentOS7 安装 docker 和 docker-compose | shell 脚本初次尝试


参照官网教程，实现CentOS7安装docker，注意的是这里的docker是ce版本的
...</p>
              </a>
            
          </div>
        
      </section>
    </article>
  

  
    <!-- 显示推荐文章和评论 -->



  


  




<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->



  <script>
    window.subData = {
      title: 'Java基础面试题总结',
      tools: true
    }
  </script>


</div>
<aside class='l_side'>
  
  

  
    
    


  <section class="widget toc-wrapper shadow desktop mobile">
    
  <header>
    
      <i class="fas fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#i-和-i"><span class="toc-text">i++和++i</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类初始化"><span class="toc-text">类初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-text">异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#强制性异常与非强制性异常"><span class="toc-text">强制性异常与非强制性异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法重写"><span class="toc-text">方法重写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法参数传递，传值or传引用"><span class="toc-text">方法参数传递，传值or传引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量类型和作用域"><span class="toc-text">变量类型和作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本数据类型"><span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举成员初始化"><span class="toc-text">枚举成员初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal内部真的维护了个map吗？"><span class="toc-text">ThreadLocal内部真的维护了个map吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#public类名与文件名"><span class="toc-text">public类名与文件名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String拼接"><span class="toc-text">String拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#String-intern"><span class="toc-text">String.intern()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#位运算符"><span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原码、反码、补码"><span class="toc-text">原码、反码、补码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型PECS原则"><span class="toc-text">泛型PECS原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#最终类（final类、不可变类）"><span class="toc-text">最终类（final类、不可变类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#标识符"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字（keywords）"><span class="toc-text">关键字（keywords）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#保留字"><span class="toc-text">保留字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造方法"><span class="toc-text">构造方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正则表达式"><span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a的b次幂"><span class="toc-text">a的b次幂</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getClass"><span class="toc-text">getClass</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递归"><span class="toc-text">递归</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#接口和抽象类"><span class="toc-text">接口和抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线程停止方法"><span class="toc-text">线程停止方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一维数组"><span class="toc-text">一维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重载"><span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类之间关系"><span class="toc-text">类之间关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#二维数组"><span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符编码和国际化"><span class="toc-text">字符编码和国际化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#虚函数和纯虚函数"><span class="toc-text">虚函数和纯虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Integer"><span class="toc-text">Integer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Thread-join"><span class="toc-text">Thread.join()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见的锁"><span class="toc-text">常见的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#包装类"><span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作符"><span class="toc-text">操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashCode和equals"><span class="toc-text">hashCode和equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch-语句"><span class="toc-text">switch 语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符常量"><span class="toc-text">字符常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#反射"><span class="toc-text">反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#导致InterruptedException异常"><span class="toc-text">导致InterruptedException异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#汉字长度"><span class="toc-text">汉字长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#类加载器"><span class="toc-text">类加载器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱"><span class="toc-text">自动装箱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk命令"><span class="toc-text">jdk命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static属性和方法"><span class="toc-text">static属性和方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#存根类"><span class="toc-text">存根类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static与重载"><span class="toc-text">static与重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运算符优先级"><span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java体系结构"><span class="toc-text">Java体系结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java不可被继承的类"><span class="toc-text">Java不可被继承的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#四舍五入"><span class="toc-text">四舍五入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#switch作用选择"><span class="toc-text">switch作用选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算提高计算性能"><span class="toc-text">位运算提高计算性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#描述一下JVM加载class文件的原理机制？"><span class="toc-text">描述一下JVM加载class文件的原理机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态嵌套类（Static-Nested-Class）和内部类（Inner-Class）的不同？"><span class="toc-text">静态嵌套类（Static Nested Class）和内部类（Inner Class）的不同？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程状态"><span class="toc-text">线程状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm"><span class="toc-text">jvm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#复制算法"><span class="toc-text">复制算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行时常量池"><span class="toc-text">运行时常量池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMS的GC过程"><span class="toc-text">CMS的GC过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数配置"><span class="toc-text">参数配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Java-Web"><span class="toc-text">Java Web</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie的获取方式"><span class="toc-text">Cookie的获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#request-属性参数"><span class="toc-text">request 属性参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpSessionAttributeListener"><span class="toc-text">HttpSessionAttributeListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forward和redirect区别"><span class="toc-text">forward和redirect区别</span></a></li></ol></li></ol>
    </div>
  </section>


  


</aside>


  
  <footer class="clearfix">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='list'
      fixed='false'
      list-max-height='340px'
      server='netease'
      type='playlist'
      id='3175833810'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://github.com/enenzhuyi"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
            
              <a href="https://music.163.com/#/user/home?id=1552208459"
                class="social fas fa-headphones-alt flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer">
              </a>
            
          
        </div>
      
    
      
        <div><p>Blog content follows the <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener">Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0) License</a></p>
</div>
      
    
      
        Use
        <a href="https://volantis.js.org/" target="_blank" class="codename">Volantis</a>
        as theme, total visits
          <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span>
          times
        
      
    
      
        <div class='copyright'>
        <p><a href="https://enenzhuyi.github.io">Copyright © 2017-2020 QianXiao</a></p>

        </div>
      
    
  </footer>

<script>setLoadingBarProgress(80);</script>


      <script>setLoadingBarProgress(60);</script>
    </div>
    <a class="s-top fas fa-arrow-up fa-fw" href='javascript:void(0)'></a>
  </div>
  
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4/dist/jquery.min.js"></script>


  <script>
    
    var SEARCH_SERVICE = "hexo" || "hexo";
    var ROOT = "/" || "/";
    if (!ROOT.endsWith('/')) ROOT += '/';
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/instant_page.js" type="module" defer integrity="sha384-OeDn4XE77tdHo8pGtE1apMPmAipjoxUQ++eeJa6EtJCfHlvijigWiJpD7VDPWXV1"></script>



  
<script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script>

  <script type="text/javascript">
    $(function() {
      Waves.attach('.flat-btn', ['waves-button']);
      Waves.attach('.float-btn', ['waves-button', 'waves-float']);
      Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
      Waves.attach('.flat-box', ['waves-block']);
      Waves.attach('.float-box', ['waves-block', 'waves-float']);
      Waves.attach('.waves-image');
      Waves.init();
    });
  </script>


  <script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script>



  
  
  
    
<script src="https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js"></script>

    <script type="text/javascript">
      $(function(){
        var imgs=["https://cdn.jsdelivr.net/gh/xaoxuu/cdn-wallpaper/abstract/41F215B9-261F-48B4-80B5-4E86E165259E.jpeg"];
        if ('true' == 'true') {
          function shuffle(arr){
            /*From countercurrent-time*/
            var n = arr.length;
            while(n--) {
              var index = Math.floor(Math.random() * n);
              var temp = arr[index];
              arr[index] = arr[n];
              arr[n] = temp;
            }
          }
          shuffle(imgs);
        }
        if ('.cover') {
          $('.cover').backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        } else {
          $.backstretch(
            imgs,
          {
            duration: "20000",
            fade: "1500"
          });
        }
      });
    </script>
  



  
    
<script src="https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js"></script>

  
    
<script src="https://cdn.jsdelivr.net/npm/meting@2.0/dist/Meting.min.js"></script>

  












  
<script src="/js/app.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2.4/js/search.js"></script>



  
<script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-volantis@2/js/comment_typing.js"></script>






<!-- 复制 -->

  <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="fas fa-copy"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-check-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-check-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('fa-copy');
        $icon.addClass('fa-times-circle');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('fa-times-circle');
          $icon.addClass('fa-copy');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>




<!-- fancybox -->

  <script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script>
<script>
  let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("div.fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });
</script>






  <script>setLoadingBarProgress(100);</script>
</body>
</html>
